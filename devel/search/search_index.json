{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"The python library for data valuation","text":"<p>pyDVL collects algorithms for data valuation and influence function computation. It runs most of them in parallel either locally or in a cluster and supports distributed caching of results.</p> <p>If you're a first time user of pyDVL, we recommend you to go through the Getting Started and Installing pyDVL guides.</p> <p>To the installation guide</p> <p>To the code</p> <p>Browse the API</p> <p>To the examples</p>"},{"location":"10-getting-started/","title":"Getting started","text":"<p>Warning</p> <p>Make sure you have read Installing pyDVL before using the library.  In particular read about how caching and parallelization work, since they require additional setup.</p> <p>pyDVL aims to be a repository of production-ready, reference implementations of algorithms for data valuation and influence functions. You can read:</p> <ul> <li>Computing Data Values for key objects and usage patterns for Shapley value   computation and related methods.</li> <li>Computing Influence Values for instructions on how to compute influence functions (still   in a pre-alpha state)</li> </ul> <p>We only briefly introduce key concepts in the documentation. For a thorough introduction and survey of the field, we refer to the upcoming review at the TransferLab website.</p>"},{"location":"10-getting-started/#running-the-examples","title":"Running the examples","text":"<p>If you are somewhat familiar with the concepts of data valuation, you can start by browsing our worked-out examples illustrating pyDVL's capabilities either:</p> <ul> <li>Examples.</li> <li>Using binder notebooks, deployed from each   example's page.</li> <li>Locally, by starting a jupyter server at the root of the project. You will   have to install jupyter first manually since it's not a dependency of the   library.</li> </ul>"},{"location":"20-install/","title":"Installing pyDVL","text":"<p>To install the latest release use:</p> <pre><code>pip install pyDVL\n</code></pre> <p>To use all features of influence functions use instead:</p> <pre><code>pip install pyDVL[influence]\n</code></pre> <p>This includes a dependency on PyTorch (Version 2.0 and above)  and thus is left out by default.</p> <p>In the case you use Cuda v11.2 ~ 11.8, you can enable eigen computations (for low-rank approximations) with CuPy on GPU:</p> <pre><code>pip install pyDVL[cupy]\n````\nIf you use a different version of Cuda,\nplease install CuPy [manually](https://docs.cupy.dev/en/stable/install.html).\n\nIn order to check the installation you can use:\n\n```shell\npython -c \"import pydvl; print(pydvl.__version__)\"\n</code></pre> <p>You can also install the latest development version from TestPyPI:</p> <pre><code>pip install pyDVL --index-url https://test.pypi.org/simple/\n</code></pre>"},{"location":"20-install/#dependencies","title":"Dependencies","text":"<p>pyDVL requires Python &gt;= 3.8, Memcached for caching and Ray for parallelization. Additionally, the Influence functions module requires PyTorch (see  Installing pyDVL).</p> <p>ray is used to distribute workloads both locally and across nodes. Please follow the instructions in their documentation for installation.</p>"},{"location":"20-install/#setting-up-the-cache","title":"Setting up the cache","text":"<p>memcached is an in-memory key-value store accessible over the network. pyDVL uses it to cache certain results and speed-up the computations. You can either install it as a package or run it inside a docker container (the simplest). For installation instructions, refer to the Getting started section in memcached's wiki. Then you can run it with:</p> <pre><code>memcached -u user\n</code></pre> <p>To run memcached inside a container in daemon mode instead, do:</p> <pre><code>docker container run -d --rm -p 11211:11211 memcached:latest\n</code></pre> <p>Warning</p> <p>To read more about caching and how it might affect your usage, in particular about cache reuse and its pitfalls, please read the documentation for the caching module.</p>"},{"location":"20-install/#whats-next","title":"What's next","text":"<ul> <li>Read on Computing Data Values</li> <li>Read on Computing Influence Values</li> <li>Browse the Examples</li> </ul>"},{"location":"30-data-valuation/","title":"Computing Data Values","text":"<p>Data valuation is the task of assigning a number to each element of a training set which reflects its contribution to the final performance of a model trained on it. This value is not an intrinsic property of the element of interest, but a function of three factors:</p> <ol> <li> <p>The dataset \\(D\\), or more generally, the distribution it was sampled    from (with this we mean that value would ideally be the (expected)    contribution of a data point to any random set \\(D\\) sampled from the same    distribution).</p> </li> <li> <p>The algorithm \\(\\mathcal{A}\\) mapping the data \\(D\\) to some estimator \\(f\\)    in a model class \\(\\mathcal{F}\\). E.g. MSE minimization to find the parameters    of a linear model.</p> </li> <li> <p>The performance metric of interest \\(u\\) for the problem. E.g. the \\(R^2\\)    score or the negative MSE over a test set.</p> </li> </ol> <p>pyDVL collects algorithms for the computation of data values in this sense, mostly those derived from cooperative game theory. The methods can be found in the package pydvl.value , with support from modules pydvl.utils.dataset and pydvl.utils.utility, as detailed below.</p> <p>Warning</p> <p>Be sure to read the section on the difficulties using data values.</p>"},{"location":"30-data-valuation/#creating-a-dataset","title":"Creating a Dataset","text":"<p>The first item in the tuple \\((D, \\mathcal{A}, u)\\) characterising data value is the dataset. The class Dataset is a simple convenience wrapper for the train and test splits that is used throughout pyDVL. The test set will be used to evaluate a scoring function for the model.</p> <p>It can be used as follows:</p> <pre><code>import numpy as np\nfrom pydvl.utils import Dataset\nfrom sklearn.model_selection import train_test_split\nX, y = np.arange(100).reshape((50, 2)), np.arange(50)\nX_train, X_test, y_train, y_test = train_test_split(\nX, y, test_size=0.5, random_state=16\n)\ndataset = Dataset(X_train, X_test, y_train, y_test)\n</code></pre> <p>It is also possible to construct Datasets from sklearn toy datasets for illustrative purposes using from_sklearn.</p>"},{"location":"30-data-valuation/#grouping-data","title":"Grouping data","text":"<p>Be it because data valuation methods are computationally very expensive, or because we are interested in the groups themselves, it can be often useful or necessary to group samples to valuate them together. GroupedDataset provides an alternative to Dataset with the same interface which allows this.</p> <p>You can see an example in action in the Spotify notebook, but here's a simple example grouping a pre-existing <code>Dataset</code>. First we construct an array mapping each index in the dataset to a group, then use from_dataset:</p> <pre><code>import numpy as np\nfrom pydvl.utils import GroupedDataset\n# Randomly assign elements to any one of num_groups:\ndata_groups = np.random.randint(0, num_groups, len(dataset))\ngrouped_dataset = GroupedDataset.from_dataset(dataset, data_groups)\n</code></pre>"},{"location":"30-data-valuation/#creating-a-utility","title":"Creating a Utility","text":"<p>In pyDVL we have slightly overloaded the name \"utility\" and use it to refer to an object that keeps track of all three items in \\((D, \\mathcal{A}, u)\\). This will be an instance of Utility which, as mentioned, is a convenient wrapper for the dataset, model and scoring function used for valuation methods.</p> <p>Here's a minimal example:</p> <pre><code>import sklearn as sk\nfrom pydvl.utils import Dataset, Utility\ndataset = Dataset.from_sklearn(sk.datasets.load_iris())\nmodel = sk.svm.SVC()\nutility = Utility(model, dataset)\n</code></pre> <p>The object <code>utility</code> is a callable that data valuation methods will execute with different subsets of training data. Each call will retrain the model on a subset and evaluate it on the test data using a scoring function. By default, Utility will use <code>model.score()</code>, but it is possible to use any scoring function (greater values must be better). In particular, the constructor accepts the same types as argument as sklearn's cross_validate: a string, a scorer callable or None for the default.</p> <pre><code>utility = Utility(model, dataset, \"explained_variance\")\n</code></pre> <p><code>Utility</code> will wrap the <code>fit()</code> method of the model to cache its results. This greatly reduces computation times of Monte Carlo methods. Because of how caching is implemented, it is important not to reuse <code>Utility</code> objects for different datasets. You can read more about setting up the cache in the installation guide and the documentation of the caching module.</p>"},{"location":"30-data-valuation/#using-custom-scorers","title":"Using custom scorers","text":"<p>The <code>scoring</code> argument of Utility can be used to specify a custom Scorer object. This is a simple wrapper for a callable that takes a model, and test data and returns a score.</p> <p>More importantly, the object provides information about the range of the score, which is used by some methods by estimate the number of samples necessary, and about what default value to use when the model fails to train.</p> <p>Note</p> <p>The most important property of a <code>Scorer</code> is its default value. Because many models will fail to fit on small subsets of the data, it is important to provide a sensible default value for the score.</p> <p>It is possible to skip the construction of the Scorer when constructing the <code>Utility</code> object. The two following calls are equivalent:</p> <pre><code>utility = Utility(\nmodel, dataset, \"explained_variance\", score_range=(-np.inf, 1), default_score=0.0\n)\nutility = Utility(\nmodel, dataset, Scorer(\"explained_variance\", range=(-np.inf, 1), default=0.0)\n)\n</code></pre>"},{"location":"30-data-valuation/#learning-the-utility","title":"Learning the utility","text":"<p>Because each evaluation of the utility entails a full retrain of the model with a new subset of the training set, it is natural to try to learn this mapping from subsets to scores. This is the idea behind Data Utility Learning (DUL)  (Wang et al., 2022)1 and in pyDVL it's as simple as wrapping the <code>Utility</code> inside DataUtilityLearning:</p> <pre><code>from pydvl.utils import Utility, DataUtilityLearning, Dataset\nfrom sklearn.linear_model import LinearRegression, LogisticRegression\nfrom sklearn.datasets import load_iris\ndataset = Dataset.from_sklearn(load_iris())\nu = Utility(LogisticRegression(), dataset, enable_cache=False)\ntraining_budget = 3\nwrapped_u = DataUtilityLearning(u, training_budget, LinearRegression())\n# First 3 calls will be computed normally\nfor i in range(training_budget):\n_ = wrapped_u((i,))\n# Subsequent calls will be computed using the fit model for DUL\nwrapped_u((1, 2, 3))\n</code></pre> <p>As you can see, all that is required is a model to learn the utility itself and the fitting and using of the learned model happens behind the scenes.</p> <p>There is a longer example with an investigation of the results achieved by DUL in a dedicated notebook.</p>"},{"location":"30-data-valuation/#leave-one-out-values","title":"Leave-One-Out values","text":"<p>The Leave-One-Out method is a simple approach that assigns each sample its marginal utility as value:</p> \\[v_u(x_i) = u(D) \u2212 u(D \\setminus \\{x_i\\}).\\] <p>For the purposes of data valuation, this is rarely useful beyond serving as a baseline for benchmarking. One particular weakness is that it does not necessarily correlate with an intrinsic value of a sample: since it is a marginal utility, it is affected by the \"law\" of diminishing returns. Often, the training set is large enough for a single sample not to have any significant effect on training performance, despite any qualities it may possess. Whether this is indicative of low value or not depends on each one's goals and definitions, but other methods are typically preferable.</p> <pre><code>from pydvl.value.loo.naive import naive_loo\nvalues = naive_loo(utility)\n</code></pre> <p>The return value of all valuation functions is an object of type ValuationResult. This can be iterated over, indexed with integers, slices and Iterables, as well as converted to a pandas.DataFrame.</p>"},{"location":"30-data-valuation/#shapley-values","title":"Shapley values","text":"<p>The Shapley method is an approach to compute data values originating in cooperative game theory. Shapley values are a common way of assigning payoffs to each participant in a cooperative game (i.e. one in which players can form coalitions) in a way that ensures that certain axioms are fulfilled.</p> <p>pyDVL implements several methods for the computation and approximation of Shapley values. They can all be accessed via the facade function compute_shapley_values. The supported methods are enumerated in ShapleyMode.</p>"},{"location":"30-data-valuation/#combinatorial-shapley","title":"Combinatorial Shapley","text":"<p>The first algorithm is just a verbatim implementation of the definition. As such it returns as exact a value as the utility function allows (see what this means in Problems of Data Values][problems-of-data-values]).</p> <p>The value \\(v\\) of the \\(i\\)-th sample in dataset \\(D\\) wrt. utility \\(u\\) is computed as a weighted sum of its marginal utility wrt. every possible coalition of training samples within the training set:</p> \\[ v_u(x_i) = \\frac{1}{n} \\sum_{S \\subseteq D \\setminus \\{x_i\\}} \\binom{n-1}{ | S | }^{-1} [u(S \\cup \\{x_i\\}) \u2212 u(S)] ,\\] <pre><code>from pydvl.value import compute_shapley_values\nvalues = compute_shapley_values(utility, mode=\"combinatorial_exact\")\ndf = values.to_dataframe(column='value')\n</code></pre> <p>We can convert the return value to a pandas.DataFrame. and name the column with the results as <code>value</code>. Please refer to the documentation in shapley and ValuationResult for more information.</p>"},{"location":"30-data-valuation/#monte-carlo-combinatorial-shapley","title":"Monte Carlo Combinatorial Shapley","text":"<p>Because the number of subsets \\(S \\subseteq D \\setminus \\{x_i\\}\\) is \\(2^{ | D | - 1 }\\), one typically must resort to approximations. The simplest one is done via Monte Carlo sampling of the powerset \\(\\mathcal{P}(D)\\). In pyDVL this simple technique is called \"Monte Carlo Combinatorial\". The method has very poor converge rate and others are preferred, but if desired, usage follows the same pattern:</p> <pre><code>from pydvl.value import compute_shapley_values, MaxUpdates\nvalues = compute_shapley_values(\nutility, mode=\"combinatorial_montecarlo\", done=MaxUpdates(1000)\n)\ndf = values.to_dataframe(column='cmc')\n</code></pre> <p>The DataFrames returned by most Monte Carlo methods will contain approximate standard errors as an additional column, in this case named <code>cmc_stderr</code>.</p> <p>Note the usage of the object MaxUpdates as the stop condition. This is an instance of a StoppingCriterion. Other examples are MaxTime and AbsoluteStandardError.</p>"},{"location":"30-data-valuation/#owen-sampling","title":"Owen sampling","text":"<p>Owen Sampling (Okhrati and Lipani, 2021)2 is a practical algorithm based on the combinatorial definition. It uses a continuous extension of the utility from \\(\\{0,1\\}^n\\), where a 1 in position \\(i\\) means that sample \\(x_i\\) is used to train the model, to \\([0,1]^n\\). The ensuing expression for Shapley value uses integration instead of discrete weights:</p> \\[ v_u(i) = \\int_0^1 \\mathbb{E}_{S \\sim P_q(D_{\\backslash \\{ i \\}})} [u(S \\cup {i}) - u(S)] .\\] <p>Using Owen sampling follows the same pattern as every other method for Shapley values in pyDVL. First construct the dataset and utility, then call compute_shapley_values:</p> <pre><code>from pydvl.value import compute_shapley_values\nvalues = compute_shapley_values(\nu=utility, mode=\"owen\", n_iterations=4, max_q=200\n)\n</code></pre> <p>There are more details on Owen sampling, and its variant Antithetic Owen Sampling in the documentation for the function doing the work behind the scenes: owen_sampling_shapley.</p> <p>Note that in this case we do not pass a StoppingCriterion to the function, but instead the number of iterations and the maximum number of samples to use in the integration.</p>"},{"location":"30-data-valuation/#permutation-shapley","title":"Permutation Shapley","text":"<p>An equivalent way of computing Shapley values (<code>ApproShapley</code>) appeared in  (Castro et al., 2009)3 and is the basis for the method most often used in practice. It uses permutations over indices instead of subsets:</p> \\[ v_u(x_i) = \\frac{1}{n!} \\sum_{\\sigma \\in \\Pi(n)} [u(\\sigma_{:i} \\cup \\{i\\}) \u2212 u(\\sigma_{:i})] ,\\] <p>where \\(\\sigma_{:i}\\) denotes the set of indices in permutation sigma before the position where \\(i\\) appears. To approximate this sum (which has \\(\\mathcal{O}(n!)\\) terms!) one uses Monte Carlo sampling of permutations, something which has surprisingly low sample complexity. One notable difference wrt. the combinatorial approach above is that the approximations always fulfill the efficiency axiom of Shapley, namely \\(\\sum_{i=1}^n \\hat{v}_i = u(D)\\) (see  (Castro et al., 2009)3, Proposition 3.2).</p> <p>By adding early stopping, the result is the so-called Truncated Monte Carlo Shapley (Ghorbani and Zou, 2019)4, which is efficient enough to be useful in applications.</p> <pre><code>from pydvl.value import compute_shapley_values, MaxUpdates\nvalues = compute_shapley_values(\nu=utility, mode=\"truncated_montecarlo\", done=MaxUpdates(1000)\n)\n</code></pre>"},{"location":"30-data-valuation/#exact-shapley-for-knn","title":"Exact Shapley for KNN","text":"<p>It is possible to exploit the local structure of K-Nearest Neighbours to reduce the amount of subsets to consider: because no sample besides the K closest affects the score, most are irrelevant and it is possible to compute a value in linear time. This method was introduced by (Jia et al., 2019)5, and can be used in pyDVL with:</p> <pre><code>from pydvl.utils import Dataset, Utility\nfrom pydvl.value import compute_shapley_values\nfrom sklearn.neighbors import KNeighborsClassifier\nmodel = KNeighborsClassifier(n_neighbors=5)\ndata = Dataset(...)\nutility = Utility(model, data)\nvalues = compute_shapley_values(u=utility, mode=\"knn\")\n</code></pre>"},{"location":"30-data-valuation/#group-testing","title":"Group testing","text":"<p>An alternative approach introduced in (Jia et al., 2019)5 first approximates the differences of values with a Monte Carlo sum. With</p> \\[\\hat{\\Delta}_{i j} \\approx v_i - v_j,\\] <p>one then solves the following linear constraint satisfaction problem (CSP) to infer the final values:</p> \\[ \\begin{array}{lll} \\sum_{i = 1}^N v_i &amp; = &amp; U (D)\\\\ | v_i - v_j - \\hat{\\Delta}_{i j} | &amp; \\leqslant &amp; \\frac{\\varepsilon}{2 \\sqrt{N}} \\end{array} \\] <p>Warning</p> <p>We have reproduced this method in pyDVL for completeness and benchmarking, but we don't advocate its use because of the speed and memory cost. Despite our best efforts, the number of samples required in practice for convergence can be several orders of magnitude worse than with e.g. Truncated Monte Carlo. Additionally, the CSP can sometimes turn out to be infeasible.</p> <p>Usage follows the same pattern as every other Shapley method, but with the addition of an <code>epsilon</code> parameter required for the solution of the CSP. It should be the same value used to compute the minimum number of samples required. This can be done with num_samples_eps_delta, but note that the number returned will be huge! In practice, fewer samples can be enough, but the actual number will strongly depend on the utility, in particular its variance.</p> <pre><code>from pydvl.utils import Dataset, Utility\nfrom pydvl.value import compute_shapley_values\nmodel = ...\ndata = Dataset(...)\nutility = Utility(model, data, score_range=(_min, _max))\nmin_iterations = num_samples_eps_delta(epsilon, delta, n, utility.score_range)\nvalues = compute_shapley_values(\nu=utility, mode=\"group_testing\", n_iterations=min_iterations, eps=eps\n)\n</code></pre>"},{"location":"30-data-valuation/#core-values","title":"Core values","text":"<p>The Shapley values define a fair way to distribute payoffs amongst all participants when they form a grand coalition. But they do not consider the question of stability: under which conditions do all participants form the grand coalition? Would the participants be willing to form the grand coalition given how the payoffs are assigned, or would some of them prefer to form smaller coalitions?</p> <p>The Core is another approach to computing data values originating in cooperative game theory that attempts to ensure this stability. It is the set of feasible payoffs that cannot be improved upon by a coalition of the participants.</p> <p>It satisfies the following 2 properties:</p> <ul> <li> <p>Efficiency:   The payoffs are distributed such that it is not possible   to make any participant better off   without making another one worse off.   \\(\\(\\sum_{x_i\\in D} v_u(x_i) = u(D)\\,\\)\\)</p> </li> <li> <p>Coalitional rationality:   The sum of payoffs to the agents in any coalition S is at   least as large as the amount that these agents could earn by   forming a coalition on their own.   \\(\\(\\sum_{x_i\\in S} v_u(x_i) \\geq u(S), \\forall S \\subset D\\,\\)\\)</p> </li> </ul> <p>The second property states that the sum of payoffs to the agents in any subcoalition \\(S\\) is at least as large as the amount that these agents could earn by forming a coalition on their own.</p>"},{"location":"30-data-valuation/#least-core-values","title":"Least Core values","text":"<p>Unfortunately, for many cooperative games the Core may be empty. By relaxing the coalitional rationality property by a subsidy \\(e \\gt 0\\), we are then able to find approximate payoffs:</p> \\[ \\sum_{x_i\\in S} v_u(x_i) + e \\geq u(S), \\forall S \\subset D, S \\neq \\emptyset \\ ,\\] <p>The least core value \\(v\\) of the \\(i\\)-th sample in dataset \\(D\\) wrt. utility \\(u\\) is computed by solving the following Linear Program:</p> \\[ \\begin{array}{lll} \\text{minimize} &amp; e &amp; \\\\ \\text{subject to} &amp; \\sum_{x_i\\in D} v_u(x_i) = u(D) &amp; \\\\ &amp; \\sum_{x_i\\in S} v_u(x_i) + e \\geq u(S) &amp;, \\forall S \\subset D, S \\neq \\emptyset  \\\\ \\end{array} \\]"},{"location":"30-data-valuation/#exact-least-core","title":"Exact Least Core","text":"<p>This first algorithm is just a verbatim implementation of the definition. As such it returns as exact a value as the utility function allows (see what this means in Problems of Data Values][problems-of-data-values]).</p> <pre><code>from pydvl.value import compute_least_core_values\nvalues = compute_least_core_values(utility, mode=\"exact\")\n</code></pre>"},{"location":"30-data-valuation/#monte-carlo-least-core","title":"Monte Carlo Least Core","text":"<p>Because the number of subsets \\(S \\subseteq D \\setminus \\{x_i\\}\\) is \\(2^{ | D | - 1 }\\), one typically must resort to approximations.</p> <p>The simplest approximation consists in using a fraction of all subsets for the constraints. (Yan and Procaccia, 2021)6 show that a quantity of order \\(\\mathcal{O}((n - \\log \\Delta ) / \\delta^2)\\) is enough to obtain a so-called \\(\\delta\\)-approximate least core with high probability. I.e. the following property holds with probability \\(1-\\Delta\\) over the choice of subsets:</p> \\[ \\mathbb{P}_{S\\sim D}\\left[\\sum_{x_i\\in S} v_u(x_i) + e^{*} \\geq u(S)\\right] \\geq 1 - \\delta, \\] <p>where \\(e^{*}\\) is the optimal least core subsidy.</p> <pre><code>from pydvl.value import compute_least_core_values\nvalues = compute_least_core_values(\nutility, mode=\"montecarlo\", n_iterations=n_iterations\n)\n</code></pre> <p>Note</p> <p>Although any number is supported, it is best to choose <code>n_iterations</code> to be at least equal to the number of data points.</p> <p>Because computing the Least Core values requires the solution of a linear and a quadratic problem after computing all the utility values, we offer the possibility of splitting the latter from the former. This is useful when running multiple experiments: use mclc_prepare_problem to prepare a list of problems to solve, then solve them in parallel with lc_solve_problems.</p> <pre><code>from pydvl.value.least_core import mclc_prepare_problem, lc_solve_problems\nn_experiments = 10\nproblems = [mclc_prepare_problem(utility, n_iterations=n_iterations)\nfor _ in range(n_experiments)]\nvalues = lc_solve_problems(problems)\n</code></pre>"},{"location":"30-data-valuation/#semi-values","title":"Semi-values","text":"<p>Shapley values are a particular case of a more general concept called semi-value, which is a generalization to different weighting schemes. A semi-value is any valuation function with the form:</p> \\[ v\\_\\text{semi}(i) = \\sum_{i=1}^n w(k) \\sum_{S \\subset D\\_{-i}^{(k)}} [U(S\\_{+i})-U(S)], \\] <p>where the coefficients \\(w(k)\\) satisfy the property:</p> \\[\\sum_{k=1}^n w(k) = 1.\\] <p>Two instances of this are Banzhaf indices (Wang and Jia, 2022)7, and Beta Shapley (Kwon and Zou, 2022)8, with better numerical and rank stability in certain situations.</p> <p>Note</p> <p>Shapley values are a particular case of semi-values and can therefore also be computed with the methods described here. However, as of version 0.6.0, we recommend using compute_shapley_values instead, in particular because it implements truncated Monte Carlo sampling for faster computation.</p>"},{"location":"30-data-valuation/#beta-shapley","title":"Beta Shapley","text":"<p>For some machine learning applications, where the utility is typically the performance when trained on a set \\(S \\subset D\\), diminishing returns are often observed when computing the marginal utility of adding a new data point.</p> <p>Beta Shapley is a weighting scheme that uses the Beta function to place more weight on subsets deemed to be more informative. The weights are defined as:</p> \\[ w(k) := \\frac{B(k+\\beta, n-k+1+\\alpha)}{B(\\alpha, \\beta)}, \\] <p>where \\(B\\) is the Beta function, and \\(\\alpha\\) and \\(\\beta\\) are parameters that control the weighting of the subsets. Setting both to 1 recovers Shapley values, and setting \\(\\alpha = 1\\), and \\(\\beta = 16\\) is reported in (Kwon and Zou, 2022)8 to be a good choice for some applications. See however the Banzhaf indices section  for an alternative choice of weights which is reported to work better.</p> <pre><code>from pydvl.value import compute_semivalues\nvalues = compute_semivalues(\nu=utility, mode=\"beta_shapley\", done=MaxUpdates(500), alpha=1, beta=16\n)\n</code></pre>"},{"location":"30-data-valuation/#banzhaf-indices","title":"Banzhaf indices","text":"<p>As noted below in the Problems of Data Values section, the Shapley value can be very sensitive to variance in the utility function. For machine learning applications, where the utility is typically the performance when trained on a set \\(S \\subset D\\), this variance is often largest for smaller subsets \\(S\\). It is therefore reasonable to try reducing the relative contribution of these subsets with adequate weights.</p> <p>One such choice of weights is the Banzhaf index, which is defined as the constant:</p> \\[w(k) := 2^{n-1},\\] <p>for all set sizes \\(k\\). The intuition for picking a constant weight is that for any choice of weight function \\(w\\), one can always construct a utility with higher variance where \\(w\\) is greater. Therefore, in a worst-case sense, the best one can do is to pick a constant weight.</p> <p>The authors of (Wang and Jia, 2022)7 show that Banzhaf indices are more robust to variance in the utility function than Shapley and Beta Shapley values.</p> <pre><code>from pydvl.value import compute_semivalues, MaxUpdates\nvalues = compute_semivalues( u=utility, mode=\"banzhaf\", done=MaxUpdates(500))\n</code></pre>"},{"location":"30-data-valuation/#problems-of-data-values","title":"Problems of data values","text":"<p>There are a number of factors that affect how useful values can be for your project. In particular, regression can be especially tricky, but the particular nature of every (non-trivial) ML problem can have an effect:</p> <ul> <li>Unbounded utility: Choosing a scorer for a classifier is simple: accuracy   or some F-score provides a bounded number with a clear interpretation. However,   in regression problems most scores, like \\(R^2\\), are not bounded because   regressors can be arbitrarily bad. This leads to great variability in the   utility for low sample sizes, and hence unreliable Monte Carlo approximations   to the values. Nevertheless, in practice it is only the ranking of samples   that matters, and this tends to be accurate (wrt. to the true ranking) despite   inaccurate values.</li> </ul> <p>pyDVL offers a dedicated function composition   for scorer functions which can be used to squash a score.   The following is defined in module score:</p> <pre><code>import numpy as np\nfrom pydvl.utils.types import compose_score\ndef sigmoid(x: float) -&gt; float:\nreturn float(1 / (1 + np.exp(-x)))\nsquashed_r2 = compose_score(\"r2\", sigmoid, \"squashed r2\")\nsquashed_variance = compose_score(\n\"explained_variance\", sigmoid, \"squashed explained variance\"\n)\n</code></pre> <p>These squashed scores can prove useful in regression problems, but they can   also introduce issues in the low-value regime.</p> <ul> <li>High variance utility: Classical applications of game theoretic value   concepts operate with deterministic utilities, but in ML we use an evaluation   of the model on a validation set as a proxy for the true risk. Even if the   utility is bounded, if it has high variance then values will also have high   variance, as will their Monte Carlo estimates. One workaround in pyDVL is to   configure the caching system to allow multiple evaluations of the utility for   every index set. A moving average is computed and returned once the standard   error is small, see MemcachedConfig.</li> </ul> <p>(Wang and Jia, 2022)7 prove that by relaxing one of the Shapley axioms   and considering the general class of semi-values, of which Shapley is an   instance, one can prove that a choice of constant weights is the best one can   do in a utility-agnostic setting. So-called Data Banzhaf is on our to-do   list!</p> <ul> <li> <p>Data set size: Computing exact Shapley values is NP-hard, and Monte Carlo   approximations can converge slowly. Massive datasets are thus impractical, at   least with current techniques. A workaround is to group samples and investigate   their value together. In pyDVL you can do this using   GroupedDataset.    There is a fully worked-out example here.   Some algorithms also provide different sampling strategies to reduce    the variance, but due to a no-free-lunch-type theorem,   no single strategy can be optimal for all utilities.</p> </li> <li> <p>Model size: Since every evaluation of the utility entails retraining the   whole model on a subset of the data, large models require great amounts of   computation. But also, they will effortlessly interpolate small to medium   datasets, leading to great variance in the evaluation of performance on the   dedicated validation set. One mitigation for this problem is cross-validation,   but this would incur massive computational cost. As of v.0.3.0 there are no   facilities in pyDVL for cross-validating the utility (note that this would   require cross-validating the whole value computation).</p> </li> </ul> <ol> <li> <p>Wang, T., Yang, Y., Jia, R., 2022. Improving Cooperative Game Theory-based Data Valuation via Data Utility Learning, in: International Conference on Learning Representations (ICLR 2022). Workshop on Socially Responsible Machine Learning. arXiv. https://doi.org/10.48550/arXiv.2107.06336 \u21a9</p> </li> <li> <p>Okhrati, R., Lipani, A., 2021. A Multilinear Sampling Algorithm to Estimate Shapley Values, in: 2020 25th International Conference on Pattern Recognition (ICPR). IEEE, pp. 7992\u20137999. https://doi.org/10.1109/ICPR48806.2021.9412511 \u21a9</p> </li> <li> <p>Castro, J., G\u00f3mez, D., Tejada, J., 2009. Polynomial calculation of the Shapley value based on sampling. Computers   &amp; Operations Research, Selected papers presented at the Tenth International Symposium on Locational Decisions (ISOLDE X) 36, 1726\u20131730. https://doi.org/10.1016/j.cor.2008.04.004 \u21a9\u21a9</p> </li> <li> <p>Ghorbani, A., Zou, J., 2019. Data Shapley: Equitable Valuation of Data for Machine Learning, in: Proceedings of the 36th International Conference on Machine Learning, PMLR. PMLR, pp. 2242\u20132251.\u00a0\u21a9</p> </li> <li> <p>Jia, R., Dao, D., Wang, B., Hubis, F.A., Gurel, N.M., Li, B., Zhang, C., Spanos, C., Song, D., 2019. Efficient task-specific data valuation for nearest neighbor algorithms. Proceedings of the VLDB Endowment 12, 1610\u20131623. https://doi.org/10.14778/3342263.3342637 \u21a9\u21a9</p> </li> <li> <p>Yan, T., Procaccia, A.D., 2021. If You Like Shapley Then You\u2019ll Love the Core, in: Proceedings of the 35th AAAI Conference on Artificial Intelligence, 2021. Association for the Advancement of Artificial Intelligence, Virtual conference, pp. 5751\u20135759. https://doi.org/10.1609/aaai.v35i6.16721 \u21a9</p> </li> <li> <p>Wang, J.T., Jia, R., 2022. Data Banzhaf: A Robust Data Valuation Framework for Machine Learning. https://doi.org/10.48550/arXiv.2205.15466 \u21a9\u21a9\u21a9</p> </li> <li> <p>Kwon, Y., Zou, J., 2022. Beta Shapley: A Unified and Noise-reduced Data Valuation Framework for Machine Learning, in: Proceedings of the 25th International Conference on Artificial Intelligence and Statistics (AISTATS) 2022,. PMLR, Valencia, Spain.\u00a0\u21a9\u21a9</p> </li> </ol>"},{"location":"40-influence/","title":"Computing influence values","text":"<p>Warning</p> <p>Much of the code in the package pydvl.influence is experimental or untested. Package structure and basic API are bound to change before v1.0.0</p> <p>The influence function (IF) is a method to quantify the effect (influence) that each training point has on the parameters of a model, and by extension on any function thereof. In particular, it allows to estimate how much each training sample affects the error on a test point, making the IF useful for understanding and debugging models.</p> <p>pyDVL implements several methods for the efficient computation of the IF for machine learning.</p>"},{"location":"40-influence/#the-influence-function","title":"The Influence Function","text":"<p>First introduced in the context of robust statistics in  (Hampel, 1974)1, the IF was popularized in the context of machine learning in (Koh and Liang, 2017)2. </p> <p>Following their formulation, consider an input space \\(\\mathcal{X}\\) (e.g. images) and an output space \\(\\mathcal{Y}\\) (e.g. labels).  Let's take \\(z_i = (x_i, y_i)\\), for \\(i \\in  \\{1,...,n\\}\\) to be the \\(i\\)-th training point, and \\(\\theta\\) to be the (potentially highly) multi-dimensional parameters of a model (e.g. \\(\\theta\\) is a big array with all of a neural network's parameters, including biases and/or dropout rates). We will denote with \\(L(z, \\theta)\\) the loss of the model for point \\(z\\) when the parameters are \\(\\theta.\\)</p> <p>To train a model, we typically minimize the loss over all \\(z_i\\), i.e. the optimal parameters are</p> \\[\\hat{\\theta} = \\arg \\min_\\theta \\sum_{i=1}^n L(z_i, \\theta).\\] <p>In practice, lack of convexity means that one doesn't really obtain the minimizer of the loss, and the training is stopped when the validation loss stops decreasing.</p> <p>For notational convenience, let's define</p> \\[\\hat{\\theta}_{-z} = \\arg \\min_\\theta \\sum_{z_i \\ne z} L(z_i, \\theta), \\] <p>i.e. \\(\\hat{\\theta}_{-z}\\) are the model parameters that minimize the total loss when \\(z\\) is not in the training dataset.</p> <p>In order to compute the impact of each training point on the model, we would need to calculate \\(\\hat{\\theta}_{-z}\\) for each \\(z\\) in the training dataset, thus re-training the model at least ~\\(n\\) times (more if model training is stochastic). This is computationally very expensive, especially for big neural networks. To circumvent this problem, we can just calculate a first order approximation of \\(\\hat{\\theta}\\). This can be done through single backpropagation and without re-training the full model.</p> <p>There are two ways to compute influences. For linear regression, the influences can be computed analytically. For more general models or loss functions, one can implement the TwiceDifferentiable protocol, which provides the required  methods for computing the influences.</p> <p>pyDVL supports two ways of computing the empirical influence function, namely up-weighting of samples and perturbation influences. The choice is done by a parameter in the call to the main entry points, compute_linear_influences and compute_influences.</p>"},{"location":"40-influence/#approximating-the-influence-of-a-point","title":"Approximating the influence of a point","text":"<p>Let's define</p> \\[\\hat{\\theta}_{\\epsilon, z} = \\arg \\min_\\theta \\frac{1}{n}\\sum_{i=1}^n L(z_i, \\theta) + \\epsilon L(z, \\theta), \\] <p>which is the optimal \\(\\hat{\\theta}\\) when we up-weight \\(z\\) by an amount \\(\\epsilon \\gt 0\\).</p> <p>From a classical result (a simple derivation is available in Appendix A of  (Koh and Liang, 2017)2), we know that:</p> \\[\\frac{d \\ \\hat{\\theta}_{\\epsilon, z}}{d \\epsilon} \\Big|_{\\epsilon=0} = -H_{\\hat{\\theta}}^{-1} \\nabla_\\theta L(z, \\hat{\\theta}), \\] <p>where \\(H_{\\hat{\\theta}} = \\frac{1}{n} \\sum_{i=1}^n \\nabla_\\theta^2 L(z_i, \\hat{\\theta})\\) is the Hessian of \\(L\\). These quantities are also knows as influence factors.</p> <p>Importantly, notice that this expression is only valid when \\(\\hat{\\theta}\\) is a minimum of \\(L\\), or otherwise \\(H_{\\hat{\\theta}}\\) cannot be inverted! At the same time, in machine learning full convergence is rarely achieved, so direct Hessian inversion is not possible. Approximations need to be developed that circumvent the problem of inverting the Hessian of the model in all those (frequent) cases where it is not positive definite.</p> <p>The influence of training point \\(z\\) on test point \\(z_{\\text{test}}\\) is defined as:</p> \\[\\mathcal{I}(z, z_{\\text{test}}) =  L(z_{\\text{test}}, \\hat{\\theta}_{-z}) - L(z_{\\text{test}}, \\hat{\\theta}). \\] <p>Notice that \\(\\mathcal{I}\\) is higher for points \\(z\\) which positively impact the model score, since the loss is higher when they are excluded from training. In practice, one needs to rely on the following infinitesimal approximation:</p> \\[\\mathcal{I}_{up}(z, z_{\\text{test}}) = - \\frac{d L(z_{\\text{test}}, \\hat{\\theta}_{\\epsilon, z})}{d \\epsilon} \\Big|_{\\epsilon=0} \\] <p>Using the chain rule and the results calculated above, we get:</p> \\[\\mathcal{I}_{up}(z, z_{\\text{test}}) = - \\nabla_\\theta L(z_{\\text{test}}, \\hat{\\theta})^\\top \\ \\frac{d \\hat{\\theta}_{\\epsilon, z}}{d \\epsilon} \\Big|_{\\epsilon=0} = \\nabla_\\theta L(z_{\\text{test}}, \\hat{\\theta})^\\top \\ H_{\\hat{\\theta}}^{-1} \\ \\nabla_\\theta L(z, \\hat{\\theta}) \\] <p>All the resulting factors are gradients of the loss wrt. the model parameters \\(\\hat{\\theta}\\). This can be easily computed through one or more backpropagation passes.</p>"},{"location":"40-influence/#perturbation-definition-of-the-influence-score","title":"Perturbation definition of the influence score","text":"<p>How would the loss of the model change if, instead of up-weighting an individual point \\(z\\), we were to up-weight only a single feature of that point? Given \\(z = (x, y)\\), we can define \\(z_{\\delta} = (x+\\delta, y)\\), where \\(\\delta\\) is a vector of zeros except for a 1 in the position of the feature we want to up-weight. In order to approximate the effect of modifying a single feature of a single point on the model score we can define</p> \\[\\hat{\\theta}_{\\epsilon, z_{\\delta} ,-z} = \\arg \\min_\\theta \\frac{1}{n}\\sum_{i=1}^n L(z_{i}, \\theta) + \\epsilon L(z_{\\delta}, \\theta) - \\epsilon L(z, \\theta), \\] <p>Similarly to what was done above, we up-weight point \\(z_{\\delta}\\), but then we also remove the up-weighting for all the features that are not modified by \\(\\delta\\). From the calculations in the previous section, it is then easy to see that</p> \\[\\frac{d \\ \\hat{\\theta}_{\\epsilon, z_{\\delta} ,-z}}{d \\epsilon} \\Big|_{\\epsilon=0} = -H_{\\hat{\\theta}}^{-1} \\nabla_\\theta \\Big( L(z_{\\delta}, \\hat{\\theta}) - L(z, \\hat{\\theta}) \\Big) \\] <p>and if the feature space is continuous and as \\(\\delta \\to 0\\) we can write</p> \\[\\frac{d \\ \\hat{\\theta}_{\\epsilon, z_{\\delta} ,-z}}{d \\epsilon} \\Big|_{\\epsilon=0} = -H_{\\hat{\\theta}}^{-1} \\ \\nabla_x \\nabla_\\theta L(z, \\hat{\\theta}) \\delta + \\mathcal{o}(\\delta) \\] <p>The influence of each feature of \\(z\\) on the loss of the model can therefore be estimated through the following quantity:</p> \\[\\mathcal{I}_{pert}(z, z_{\\text{test}}) = - \\lim_{\\delta \\to 0} \\ \\frac{1}{\\delta} \\frac{d L(z_{\\text{test}}, \\hat{\\theta}_{\\epsilon, \\ z_{\\delta}, \\ -z})}{d \\epsilon} \\Big|_{\\epsilon=0} \\] <p>which, using the chain rule and the results calculated above, is equal to</p> \\[\\mathcal{I}_{pert}(z, z_{\\text{test}}) = - \\nabla_\\theta L(z_{\\text{test}}, \\hat{\\theta})^\\top \\ \\frac{d \\hat{\\theta}_{\\epsilon, z_{\\delta} ,-z}}{d \\epsilon} \\Big|_{\\epsilon=0} = \\nabla_\\theta L(z_{\\text{test}}, \\hat{\\theta})^\\top \\ H_{\\hat{\\theta}}^{-1} \\ \\nabla_x \\nabla_\\theta L(z, \\hat{\\theta}) \\] <p>The perturbation definition of the influence score is not straightforward to understand, but it has a simple interpretation: it tells how much the loss of the model changes when a certain feature of point z is up-weighted. A positive perturbation influence score indicates that the feature might have a positive effect on the accuracy of the model.</p> <p>It is worth noting that the perturbation influence score is a very rough estimate of the impact of a point on the models loss and it is subject to large approximation errors. It can nonetheless be used to build training-set attacks, as done in (Koh and Liang, 2017)2.</p>"},{"location":"40-influence/#computing-influences","title":"Computing influences","text":"<p>The main entry point of the library for influence calculation is compute_influences. Given a pre-trained pytorch model with a loss, first an instance of TorchTwiceDifferentiable needs to be created:</p> <pre><code>from pydvl.influence import TorchTwiceDifferentiable\nwrapped_model = TorchTwiceDifferentiable(model, loss, device)\n</code></pre> <p>The device specifies where influence calculation will be run. </p> <p>Given training and test data loaders, the influence of each training point on each test point can be calculated via:</p> <pre><code>from pydvl.influence import compute_influences\nfrom torch.utils.data import DataLoader\ntraining_data_loader = DataLoader(...)\ntest_data_loader = DataLoader(...)\ncompute_influences(\nwrapped_model,\ntraining_data_loader,\ntest_data_loader,\n)\n</code></pre> <p>The result is a tensor with one row per test point and one column per training point. Thus, each entry \\((i, j)\\) represents the influence of training point \\(j\\) on test point \\(i\\). A large positive influence indicates that training point \\(j\\) tends to improve the performance of the model on test point \\(i\\), and vice versa, a large negative influence indicates that training point \\(j\\) tends to worsen the performance of the model on test point \\(i\\).</p>"},{"location":"40-influence/#perturbation-influences","title":"Perturbation influences","text":"<p>The method of empirical influence computation can be selected in compute_influences with the parameter <code>influence_type</code>:</p> <pre><code>from pydvl.influence import compute_influences\ncompute_influences(\nwrapped_model,\ntraining_data_loader,\ntest_data_loader,\ninfluence_type=\"perturbation\",\n)\n</code></pre> <p>The result is a tensor with at least three dimensions. The first two dimensions are the same as in the case of <code>influence_type=up</code> case, i.e. one row per test point and one column per training point. The remaining dimensions are the same as the number of input features in the data. Therefore, each entry in the tensor represents the influence of each feature of each training point on each test point.</p>"},{"location":"40-influence/#approximate-matrix-inversion","title":"Approximate matrix inversion","text":"<p>In almost every practical application it is not possible to construct, even less invert the complete Hessian in memory. pyDVL offers several approximate algorithms to invert it by setting the parameter <code>inversion_method</code> of compute_influences.</p> <pre><code>from pydvl.influence import compute_influences\ncompute_influences(\nwrapped_model,\ntraining_data_loader,\ntest_data_loader,\ninversion_method=\"cg\"\n)\n</code></pre> <p>Each inversion method has its own set of parameters that can be tuned to improve the final result. These parameters can be passed directly to compute_influences as keyword arguments. For example, the following code sets the maximum number of iterations for conjugate gradient to \\(100\\) and the minimum relative error to \\(0.01\\):</p> <pre><code>from pydvl.influence import compute_influences\ncompute_influences(\nwrapped_model,\ntraining_data_loader,\ntest_data_loader,\ninversion_method=\"cg\",\nhessian_regularization=1e-4,\nmaxiter=100,\nrtol=0.01\n)\n</code></pre>"},{"location":"40-influence/#hessian-regularization","title":"Hessian regularization","text":"<p>Additionally, and as discussed in the introduction, in machine learning training rarely converges to a global minimum of the loss. Despite good apparent convergence, \\(\\hat{\\theta}\\) might be located in a region with flat curvature or close to a saddle point. In particular, the Hessian might have vanishing eigenvalues making its direct inversion impossible. Certain methods, such as the Arnoldi method are robust against these problems, but most are not.</p> <p>To circumvent this problem, many approximate methods can be implemented. The simplest adds a small hessian perturbation term, i.e. \\(H_{\\hat{\\theta}} + \\lambda \\mathbb{I}\\), with \\(\\mathbb{I}\\) being the identity matrix. This standard trick ensures that the eigenvalues of \\(H_{\\hat{\\theta}}\\) are bounded away from zero and therefore the matrix is invertible. In order for this regularization not to corrupt the outcome too much, the parameter \\(\\lambda\\) should be as small as possible while still allowing a reliable inversion of \\(H_{\\hat{\\theta}} + \\lambda \\mathbb{I}\\).</p> <pre><code>from pydvl.influence import compute_influences\ncompute_influences(\nwrapped_model,\ntraining_data_loader,\ntest_data_loader,\ninversion_method=\"cg\",\nhessian_regularization=1e-4\n)\n</code></pre>"},{"location":"40-influence/#influence-factors","title":"Influence factors","text":"<p>The compute_influences method offers a fast way to obtain the influence scores given a model and a dataset. Nevertheless, it is often more convenient to inspect and save some of the intermediate results of influence calculation for later use.</p> <p>The influence factors(refer to the previous section for a definition) are typically the most computationally demanding part of influence calculation. They can be obtained via the compute_influence_factors function, saved, and later used for influence calculation on different subsets of the training dataset.</p> <pre><code>from pydvl.influence import compute_influence_factors\ninfluence_factors = compute_influence_factors(\nwrapped_model,\ntraining_data_loader,\ntest_data_loader,\ninversion_method=\"cg\"\n)\n</code></pre> <p>The result is an object of type  InverseHvpResult, which holds the calculated influence factors (<code>influence_factors.x</code>) and a dictionary with the info on the inversion process (<code>influence_factors.info</code>).</p>"},{"location":"40-influence/#methods-for-inverse-hvp-calculation","title":"Methods for inverse HVP calculation","text":"<p>In order to calculate influence values, pydvl implements several methods for the calculation of the inverse Hessian vector product (iHVP). More precisely, given a model, training data and a tensor \\(b\\), the function solve_hvp will find \\(x\\) such that \\(H x = b\\), with \\(H\\) is the hessian of model.</p> <p>Many different inversion methods can be selected via the parameter  <code>inversion_method</code> of compute_influences.</p> <p>The following subsections will offer more detailed explanations for each method.</p>"},{"location":"40-influence/#direct-inversion","title":"Direct inversion","text":"<p>With <code>inversion_method = \"direct\"</code> pyDVL will calculate the inverse Hessian using the direct matrix inversion. This means that the Hessian will first be explicitly created and then inverted. This method is the most accurate, but also the most computationally demanding. It is therefore not recommended for large datasets or models with many parameters.</p> <pre><code>import torch\nfrom pydvl.influence.inversion import solve_hvp\nb = torch.Tensor(...)\nsolve_hvp(\n\"direct\",\nwrapped_model,\ntraining_data_loader,\nb,\n)\n</code></pre> <p>The result, an object of type  InverseHvpResult, which holds two objects: <code>influence_factors.x</code> and <code>influence_factors.info</code>. The first one is the inverse Hessian vector product, while the second one is a dictionary with the info on the inversion process. For this method, the info consists of the Hessian matrix itself.</p>"},{"location":"40-influence/#conjugate-gradient","title":"Conjugate Gradient","text":"<p>A classical method for solving linear systems of equations is the conjugate gradient method. It is an iterative method that does not require the explicit inversion of the Hessian matrix. Instead, it only requires the calculation of the Hessian vector product. This makes it a good choice for large datasets or models with many parameters. It is Nevertheless much slower than the direct inversion method and not as accurate. More info on the theory of conjugate gradient can be found on Wikipedia.</p> <p>In pyDVL, you can select conjugate gradient with <code>inversion_method = \"cg\"</code>, like this:</p> <pre><code>from pydvl.influence.inversion import solve_hvp\nsolve_hvp(\n\"cg\",\nwrapped_model,\ntraining_data_loader,\nb,\nx0=None,\nrtol=1e-7,\natol=1e-7,\nmaxiter=None,\n)\n</code></pre> <p>The additional optional parameters <code>x0</code>, <code>rtol</code>, <code>atol</code>, and <code>maxiter</code> are passed to the solve_batch_cg function, and are respecively the initial guess for the solution, the relative tolerance, the absolute tolerance, and the maximum number of iterations.</p> <p>The resulting InverseHvpResult holds the solution of the iHVP, <code>influence_factors.x</code>, and some info on the inversion process <code>influence_factors.info</code>. More specifically, for each batch the infos will report the number of iterations, a boolean indicating if the inversion converged, and the residual of the inversion.</p>"},{"location":"40-influence/#linear-time-stochastic-second-order-approximation-lissa","title":"Linear time Stochastic Second-Order Approximation (LiSSA)","text":"<p>The LiSSA method is a stochastic approximation of the inverse Hessian vector product. Compared to conjugate gradient it is faster but less accurate and typically suffers from  instability.</p> <p>In order to find the solution of the HVP, LiSSA iteratively approximates the inverse of the Hessian matrix with the following update:</p> \\[H^{-1}_{j+1} b = b + (I - d) \\ H - \\frac{H^{-1}_j b}{s},\\] <p>where \\(d\\) and \\(s\\) are a dampening and a scaling factor, which are essential for the convergence of the method and they need to be chosen carefully, and I  is the identity matrix. More info on the theory of LiSSA can be found in the  original paper (Agarwal et al., 2017)3.</p> <p>In pyDVL, you can select LiSSA with <code>inversion_method = \"lissa\"</code>, like this:</p> <pre><code>from pydvl.influence.inversion import solve_hvp\nsolve_hvp(\n\"lissa\",\nwrapped_model,\ntraining_data_loader,\nb,\nmaxiter=1000,\ndampen=0.0,\nscale=10.0,\nh0=None,\nrtol=1e-4,\n)\n</code></pre> <p>with the additional optional parameters <code>maxiter</code>, <code>dampen</code>, <code>scale</code>, <code>h0</code>, and <code>rtol</code>, which are passed to the solve_lissa function, being the maximum number of iterations, the dampening factor, the scaling factor, the initial guess for the solution and the relative tolerance, respectively.</p> <p>The resulting InverseHvpResult holds the solution of the iHVP, <code>influence_factors.x</code>, and, within <code>influence_factors.info</code>, the maximum percentage error and the mean percentage error of the approximation.</p>"},{"location":"40-influence/#arnoldi-solver","title":"Arnoldi solver","text":"<p>The Arnoldi method is a Krylov subspace method for approximating the action of a matrix on a vector. It is a generalization of the power method for finding eigenvectors of a matrix.</p> <ol> <li> <p>Hampel, F.R., 1974. The influence curve and its role in robust estimation. Journal of the american statistical association 69, 383\u2013393.\u00a0\u21a9</p> </li> <li> <p>Koh, P.W., Liang, P., 2017. Understanding Black-box Predictions via Influence Functions, in: Proceedings of the 34th International Conference on Machine Learning. PMLR, pp. 1885\u20131894.\u00a0\u21a9\u21a9\u21a9</p> </li> <li> <p>Agarwal, N., Bullins, B., Hazan, E., 2017. Second-order stochastic optimization for machine learning in linear time. The Journal of Machine Learning Research 18, 4148\u20134187.\u00a0\u21a9</p> </li> </ol>"},{"location":"CHANGELOG/","title":"Changelog","text":""},{"location":"CHANGELOG/#unreleased","title":"Unreleased","text":"<ul> <li>Optimises memory usage in IF calculation   PR #375</li> <li>Breaking Changes   Returns information about hessian inversion to compute_influence_factors,   thus changing signature   PR #375</li> <li>Fix adding valuation results with overlapping indices and different lengths   PR #370</li> <li>Fixed bugs in conjugate gradient and <code>linear_solve</code> PR #358</li> <li>Improvements to IF documentation   PR #371</li> <li>Major changes to IF interface and functionality   PR #278 PR #394</li> <li>New Method: Implements solving the hessian equation via spectral low-rank approximation   PR #365</li> <li>Breaking Changes:</li> <li>Add new joblib backend and set it as default     instead of the ray backend. Simplify the MapReduceJob class.     PR #355</li> <li>Bump torch dependency for influence package to 2.0 PR #365</li> <li>Bug fix Fix installation of dev requirements for Python3.10   PR #382</li> <li>Decouple ray.init from ParallelConfig    PR #373</li> </ul>"},{"location":"CHANGELOG/#061-bug-fixes-and-small-improvement","title":"0.6.1 - \ud83c\udfd7 Bug fixes and small improvement","text":"<ul> <li>Fix parsing keyword arguments of <code>compute_semivalues</code> dispatch function   PR #333</li> <li>Create new <code>RayExecutor</code> class based on the concurrent.futures API,   use the new class to fix an issue with Truncated Monte Carlo Shapley   (TMCS) starting too many processes and dying, plus other small changes   PR #329</li> <li>Fix creation of GroupedDataset objects using the <code>from_arrays</code>   and <code>from_sklearn</code> class methods    PR #324</li> <li>Fix release job not triggering on CI when a new tag is pushed   PR #331</li> <li>Added alias <code>ApproShapley</code> from Castro et al. 2009 for permutation Shapley   PR #332</li> </ul>"},{"location":"CHANGELOG/#060-new-algorithms-cleanup-and-bug-fixes","title":"0.6.0 - \ud83c\udd95 New algorithms, cleanup and bug fixes \ud83c\udfd7","text":"<ul> <li>Fixes in <code>ValuationResult</code>: bugs around data names, semantics of   <code>empty()</code>, new method <code>zeros()</code> and normalised random values   PR #327</li> <li>New method: Implements generalised semi-values for data valuation,   including Data Banzhaf and Beta Shapley, with configurable sampling strategies   PR #319</li> <li>Adds kwargs parameter to <code>from_array</code> and <code>from_sklearn</code> Dataset and   GroupedDataset class methods   PR #316</li> <li>PEP-561 conformance: added <code>py.typed</code> PR #307</li> <li>Removed default non-negativity constraint on least core subsidy   and added instead a <code>non_negative_subsidy</code> boolean flag.   Renamed <code>options</code> to <code>solver_options</code> and pass it as dict.   Change default least-core solver to SCS with 10000 max_iters.   PR #304</li> <li>Cleanup: removed unnecessary decorator <code>@unpackable</code> PR #233</li> <li>Stopping criteria: fixed problem with <code>StandardError</code> and enable proper   composition of index convergence statuses. Fixed a bug with <code>n_jobs</code> in   <code>truncated_montecarlo_shapley</code>.   PR #300 and   PR #305</li> <li>Shuffling code around to allow for simpler user imports, some cleanup and   documentation fixes.   PR #284</li> <li>Bug fix: Warn instead of raising an error when <code>n_iterations</code>   is less than the size of the dataset in Monte Carlo Least Core   PR #281</li> </ul>"},{"location":"CHANGELOG/#050-fixes-nicer-interfaces-and-more-breaking-changes","title":"0.5.0 - \ud83d\udca5 Fixes, nicer interfaces and... more breaking changes \ud83d\ude12","text":"<ul> <li>Fixed parallel and antithetic Owen sampling for Shapley values. Simplified   and extended tests.   PR #267</li> <li>Added <code>Scorer</code> class for a cleaner interface. Fixed minor bugs around   Group-Testing Shapley, added more tests and switched to cvxpy for the solver.   PR #264</li> <li>Generalised stopping criteria for valuation algorithms. Improved classes   <code>ValuationResult</code> and <code>Status</code> with more operations. Some minor issues fixed.   PR #252</li> <li>Fixed a bug whereby <code>compute_shapley_values</code> would only spawn one process when   using <code>n_jobs=-1</code> and Monte Carlo methods.   PR #270</li> <li>Bugfix in <code>RayParallelBackend</code>: wrong semantics for <code>kwargs</code>.   PR #268</li> <li>Splitting of problem preparation and solution in Least-Core computation.   Umbrella function for LC methods.   PR #257 </li> <li>Operations on <code>ValuationResult</code> and <code>Status</code> and some cleanup   PR #248</li> <li>Bug fix and minor improvements: Fixes bug in TMCS with remote Ray cluster,   raises an error for dummy sequential parallel backend with TMCS, clones model   inside <code>Utility</code> before fitting by default, with flag <code>clone_before_fit</code>    to disable it, catches all warnings in <code>Utility</code> when <code>show_warnings</code> is    <code>False</code>. Adds Miner and Gloves toy games utilities   PR #247</li> </ul>"},{"location":"CHANGELOG/#040-new-algorithms-and-more-breaking-changes","title":"0.4.0 - \ud83c\udfed\ud83d\udca5 New algorithms and more breaking changes","text":"<ul> <li>GH action to mark issues as stale   PR #201</li> <li>Disabled caching of Utility values as well as repeated evaluations by default   PR #211</li> <li>Test and officially support Python version 3.9 and 3.10    PR #208</li> <li>Breaking change: Introduces a class ValuationResult to gather and inspect   results from all valuation algorithms   PR #214</li> <li>Fixes bug in Influence calculation with multidimensional input and adds new   example notebook   PR #195</li> <li>Breaking change: Passes the input to <code>MapReduceJob</code> at initialization,   removes <code>chunkify_inputs</code> argument from <code>MapReduceJob</code>, removes <code>n_runs</code>   argument from <code>MapReduceJob</code>, calls the parallel backend's <code>put()</code> method for   each generated chunk in <code>_chunkify()</code>, renames ParallelConfig's <code>num_workers</code>   attribute to <code>n_local_workers</code>, fixes a bug in <code>MapReduceJob</code>'s chunkification   when <code>n_runs</code> &gt;= <code>n_jobs</code>, and defines a sequential parallel backend to run   all jobs in the current thread   PR #232</li> <li>New method: Implements exact and monte carlo Least Core for data valuation,   adds <code>from_arrays()</code> class method to the <code>Dataset</code> and <code>GroupedDataset</code>   classes, adds <code>extra_values</code> argument to <code>ValuationResult</code>, adds   <code>compute_removal_score()</code> and <code>compute_random_removal_score()</code> helper functions   PR #237</li> <li>New method: Group Testing Shapley for valuation, from Jia et al. 2019 PR #240</li> <li>Fixes bug in ray initialization in <code>RayParallelBackend</code> class   PR #239</li> <li>Implements \"Egalitarian Least Core\", adds cvxpy as a   dependency and uses it instead of scipy as optimizer   PR #243</li> </ul>"},{"location":"CHANGELOG/#030-breaking-changes","title":"0.3.0 - \ud83d\udca5 Breaking changes","text":"<ul> <li>Simplified and fixed powerset sampling and testing   PR #181</li> <li>Simplified and fixed publishing to PyPI from CI   PR #183</li> <li>Fixed bug in release script and updated contributing docs.   PR #184</li> <li>Added Pull Request template   PR #185</li> <li>Modified Pull Request template to automatically link PR to issue   PR ##186</li> <li>First implementation of Owen Sampling, squashed scores, better testing   PR #194</li> <li>Improved documentation on caching, Shapley, caveats of values, bibtex   PR #194</li> <li>Breaking change: Rearranging of modules to accommodate for new methods   PR #194</li> </ul>"},{"location":"CHANGELOG/#020-better-docs","title":"0.2.0 - \ud83d\udcda Better docs","text":"<p>Mostly API documentation and notebooks, plus some bugfixes.</p>"},{"location":"CHANGELOG/#added","title":"Added","text":"<p>In PR #161: - Support for $$ math in sphinx docs. - Usage of sphinx extension for external links (introducing new directives like   <code>:gh:</code>, <code>:issue:</code> and <code>:tfl:</code> to construct standardised links to external   resources). - Only update auto-generated documentation files if there are changes. Some   minor additions to <code>update_docs.py</code>. - Parallelization of exact combinatorial Shapley. - Integrated KNN shapley into the main interface <code>compute_shapley_values</code>.</p>"},{"location":"CHANGELOG/#changed","title":"Changed","text":"<p>In PR #161: - Improved main docs and Shapley notebooks. Added or fixed many docstrings,   readme and documentation for contributors. Typos, grammar and style in code,   documentation and notebooks. - Internal renaming and rearranging in the parallelization and caching modules.</p>"},{"location":"CHANGELOG/#fixed","title":"Fixed","text":"<ul> <li>Bug in random matrix generation   PR #161.</li> <li>Bugs in MapReduceJob's <code>_chunkify</code> and <code>_backpressure</code> methods   PR #176.</li> </ul>"},{"location":"CHANGELOG/#010-first-release","title":"0.1.0 - \ud83c\udf89 first release","text":"<p>This is very first release of pyDVL.</p> <p>It contains:</p> <ul> <li> <p>Data Valuation Methods:</p> </li> <li> <p>Leave-One-Out</p> </li> <li>Influence Functions</li> <li>Shapley:<ul> <li>Exact Permutation and Combinatorial</li> <li>Montecarlo Permutation and Combinatorial</li> <li>Truncated Montecarlo Permutation</li> </ul> </li> <li>Caching of results with Memcached</li> <li>Parallelization of computations with Ray</li> <li>Documentation</li> <li>Notebooks containing examples of different use cases</li> </ul>"},{"location":"code-reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>pydvl<ul> <li>influence<ul> <li>general</li> <li>inversion</li> <li>torch<ul> <li>functional</li> <li>torch_differentiable</li> <li>util</li> </ul> </li> <li>twice_differentiable</li> </ul> </li> <li>reporting<ul> <li>plots</li> <li>scores</li> </ul> </li> <li>utils<ul> <li>caching</li> <li>config</li> <li>dataset</li> <li>numeric</li> <li>parallel<ul> <li>backend</li> <li>futures<ul> <li>ray</li> </ul> </li> <li>map_reduce</li> </ul> </li> <li>progress</li> <li>score</li> <li>status</li> <li>types</li> <li>utility</li> </ul> </li> <li>value<ul> <li>least_core<ul> <li>common</li> <li>montecarlo</li> <li>naive</li> </ul> </li> <li>loo<ul> <li>naive</li> </ul> </li> <li>result</li> <li>sampler</li> <li>semivalues</li> <li>shapley<ul> <li>common</li> <li>gt</li> <li>knn</li> <li>montecarlo</li> <li>naive</li> <li>owen</li> <li>truncated</li> <li>types</li> </ul> </li> <li>stopping</li> </ul> </li> </ul> </li> </ul>"},{"location":"code-reference/pydvl/","title":"pydvl","text":""},{"location":"code-reference/pydvl/#pydvl--the-python-data-valuation-library-api","title":"The Python Data Valuation Library API","text":"<p>This is the API documentation for the Python Data Valuation Library (PyDVL). Use the table of contents to access the documentation for each module.</p> <p>The two main modules you will want to look at are value and influence.</p>"},{"location":"code-reference/pydvl/influence/","title":"influence","text":"<p>This package contains algorithms for the computation of the influence function.</p> <p>.. warning::    Much of the code in this package is experimental or untested and is subject    to modification. In particular, the package structure and basic API will    probably change.</p>"},{"location":"code-reference/pydvl/influence/general/","title":"general","text":"<p>This module contains parallelized influence calculation functions for general models, as introduced in :footcite:t:<code>koh_understanding_2017</code>.</p>"},{"location":"code-reference/pydvl/influence/general/#pydvl.influence.general.InfluenceType","title":"<code>InfluenceType</code>","text":"<p>             Bases: <code>str</code>, <code>Enum</code></p> <p>Different influence types.</p>"},{"location":"code-reference/pydvl/influence/general/#pydvl.influence.general.compute_influence_factors","title":"<code>compute_influence_factors(model, training_data, test_data, inversion_method, *, hessian_perturbation=0.0, progress=False, **kwargs)</code>","text":"<p>Calculates influence factors of a model for training and test data. Given a test point \\(z_test = (x_{test}, y_{test})\\), a loss \\(L(z_{test}, \\theta)\\) (\\(\\theta\\) being the parameters of the model) and the Hessian of the model \\(H_{\\theta}\\), influence factors are defined as \\(\\(s_{test} = H_{\\theta}^{-1} \\grad_{\\theta} L(z_{test}, \\theta).\\)\\). They are used for efficient influence calculation. This method first (implicitly) calculates the Hessian and then (explicitly) finds the influence factors for the model using the given inversion method. The parameter <code>hessian_perturbation</code> is used to regularize the inversion of the Hessian. For more info, refer to :footcite:t:<code>koh_understanding_2017</code>, paragraph 3.</p> <p>:param model: A model wrapped in the TwiceDifferentiable interface. :param training_data: A DataLoader containing the training data. :param test_data: A DataLoader containing the test data. :param inversion_method: name of method for computing inverse hessian vector     products. :param hessian_perturbation: regularization of the hessian :param progress: If True, display progress bars. :returns: An array of size (N, D) containing the influence factors for each     dimension (D) and test sample (N).</p> Source code in <code>src/pydvl/influence/general.py</code> <pre><code>def compute_influence_factors(\nmodel: TwiceDifferentiable,\ntraining_data: DataLoaderType,\ntest_data: DataLoaderType,\ninversion_method: InversionMethod,\n*,\nhessian_perturbation: float = 0.0,\nprogress: bool = False,\n**kwargs: Any,\n) -&gt; InverseHvpResult:\nr\"\"\"\n    Calculates influence factors of a model for training and test\n    data. Given a test point $z_test = (x_{test}, y_{test})$, a loss\n    $L(z_{test}, \\theta)$ ($\\theta$ being the parameters of the model) and the\n    Hessian of the model $H_{\\theta}$, influence factors are defined as\n    $$s_{test} = H_{\\theta}^{-1} \\grad_{\\theta} L(z_{test}, \\theta).$$. They are\n    used for efficient influence calculation. This method first\n    (implicitly) calculates the Hessian and then (explicitly) finds the\n    influence factors for the model using the given inversion method. The\n    parameter ``hessian_perturbation`` is used to regularize the inversion of\n    the Hessian. For more info, refer to :footcite:t:`koh_understanding_2017`,\n    paragraph 3.\n    :param model: A model wrapped in the TwiceDifferentiable interface.\n    :param training_data: A DataLoader containing the training data.\n    :param test_data: A DataLoader containing the test data.\n    :param inversion_method: name of method for computing inverse hessian vector\n        products.\n    :param hessian_perturbation: regularization of the hessian\n    :param progress: If True, display progress bars.\n    :returns: An array of size (N, D) containing the influence factors for each\n        dimension (D) and test sample (N).\n    \"\"\"\ntensor_util: Type[TensorUtilities] = TensorUtilities.from_twice_differentiable(\nmodel\n)\nstack = tensor_util.stack\nunsqueeze = tensor_util.unsqueeze\ncat_gen = tensor_util.cat_gen\ncat = tensor_util.cat\ndef test_grads() -&gt; Generator[TensorType, None, None]:\nfor x_test, y_test in maybe_progress(\ntest_data, progress, desc=\"Batch Test Gradients\"\n):\nyield stack(\n[\nmodel.grad(inpt, target)\nfor inpt, target in zip(unsqueeze(x_test, 1), y_test)\n]\n)  # type:ignore\ntry:\n# if provided input_data implements __len__, pre-allocate the result tensor to reduce memory consumption\nresulting_shape = (len(test_data), model.num_params)  # type:ignore\nrhs = cat_gen(\ntest_grads(), resulting_shape, model  # type:ignore\n)  # type:ignore\nexcept Exception as e:\nlogger.warning(\nf\"Failed to pre-allocate result tensor: {e}\\n\"\nf\"Evaluate all resulting tensor and concatenate\"\n)\nrhs = cat(list(test_grads()))\nreturn solve_hvp(\ninversion_method,\nmodel,\ntraining_data,\nrhs,\nhessian_perturbation=hessian_perturbation,\n**kwargs,\n)\n</code></pre>"},{"location":"code-reference/pydvl/influence/general/#pydvl.influence.general.compute_influences_up","title":"<code>compute_influences_up(model, input_data, influence_factors, *, progress=False)</code>","text":"<p>Given the model, the training points and the influence factors, calculates the influences using the upweighting method. More precisely, first it calculates the gradients of the model wrt. each training sample (\\(\\grad_{\\theta} L\\), with \\(L\\) the loss of a single point and \\(\\theta\\) the parameters of the model) and then multiplies each with the influence factors. For more details, refer to section 2.1 of :footcite:t:<code>koh_understanding_2017</code>.</p> <p>:param model: A model which has to implement the TwiceDifferentiable     interface. :param input_data: Data loader containing the samples to calculate the     influence of. :param influence_factors: array containing influence factors :param progress: If True, display progress bars. :returns: An array of size [NxM], where N is number of influence factors, M     number of input points.</p> Source code in <code>src/pydvl/influence/general.py</code> <pre><code>def compute_influences_up(\nmodel: TwiceDifferentiable,\ninput_data: DataLoaderType,\ninfluence_factors: TensorType,\n*,\nprogress: bool = False,\n) -&gt; TensorType:\nr\"\"\"\n    Given the model, the training points and the influence factors, calculates the\n    influences using the upweighting method. More precisely, first it calculates\n    the gradients of the model wrt. each training sample ($\\grad_{\\theta} L$,\n    with $L$ the loss of a single point and $\\theta$ the parameters of the\n    model) and then multiplies each with the influence factors. For more\n    details, refer to section 2.1 of :footcite:t:`koh_understanding_2017`.\n    :param model: A model which has to implement the TwiceDifferentiable\n        interface.\n    :param input_data: Data loader containing the samples to calculate the\n        influence of.\n    :param influence_factors: array containing influence factors\n    :param progress: If True, display progress bars.\n    :returns: An array of size [NxM], where N is number of influence factors, M\n        number of input points.\n    \"\"\"\ntensor_util: Type[TensorUtilities] = TensorUtilities.from_twice_differentiable(\nmodel\n)\nstack = tensor_util.stack\nunsqueeze = tensor_util.unsqueeze\ncat_gen = tensor_util.cat_gen\ncat = tensor_util.cat\neinsum = tensor_util.einsum\ndef train_grads() -&gt; Generator[TensorType, None, None]:\nfor x, y in maybe_progress(\ninput_data, progress, desc=\"Batch Split Input Gradients\"\n):\nyield stack(\n[model.grad(inpt, target) for inpt, target in zip(unsqueeze(x, 1), y)]\n)  # type:ignore\ntry:\n# if provided input_data implements __len__, pre-allocate the result tensor to reduce memory consumption\nresulting_shape = (len(input_data), model.num_params)  # type:ignore\ntrain_grad_tensor = cat_gen(\ntrain_grads(), resulting_shape, model  # type:ignore\n)  # type:ignore\nexcept Exception as e:\nlogger.warning(\nf\"Failed to pre-allocate result tensor: {e}\\n\"\nf\"Evaluate all resulting tensor and concatenate\"\n)\ntrain_grad_tensor = cat([x for x in train_grads()])  # type:ignore\nreturn einsum(\"ta,va-&gt;tv\", influence_factors, train_grad_tensor)  # type:ignore\n</code></pre>"},{"location":"code-reference/pydvl/influence/general/#pydvl.influence.general.compute_influences_pert","title":"<code>compute_influences_pert(model, input_data, influence_factors, *, progress=False)</code>","text":"<p>Calculates the influence values from the influence factors and the training points using the perturbation method. More precisely, for each training sample it calculates \\(\\grad_{\\theta} L\\) (with L the loss of the model over the single point and \\(\\theta\\) the parameters of the model) and then uses the method TwiceDifferentiable.mvp to efficiently calculate the product of the influence factors and \\(\\grad_x \\grad_{\\theta} L\\). For more details, refer to section 2.2 of :footcite:t:<code>koh_understanding_2017</code>.</p> <p>:param model: A model which has to implement the TwiceDifferentiable interface. :param input_data: Data loader containing the samples to calculate the     influence of. :param influence_factors: array containing influence factors :param progress: If True, display progress bars. :returns: An array of size [NxMxP], where N is the number of influence factors, M     the number of input data, and P the number of features.</p> Source code in <code>src/pydvl/influence/general.py</code> <pre><code>def compute_influences_pert(\nmodel: TwiceDifferentiable,\ninput_data: DataLoaderType,\ninfluence_factors: TensorType,\n*,\nprogress: bool = False,\n) -&gt; TensorType:\nr\"\"\"\n    Calculates the influence values from the influence factors and the training\n    points using the perturbation method. More precisely, for each training sample it\n    calculates $\\grad_{\\theta} L$ (with L the loss of the model over the single\n    point and $\\theta$ the parameters of the model) and then uses the method\n    TwiceDifferentiable.mvp to efficiently calculate the product of the\n    influence factors and $\\grad_x \\grad_{\\theta} L$. For more details, refer\n    to section 2.2 of :footcite:t:`koh_understanding_2017`.\n    :param model: A model which has to implement the TwiceDifferentiable interface.\n    :param input_data: Data loader containing the samples to calculate the\n        influence of.\n    :param influence_factors: array containing influence factors\n    :param progress: If True, display progress bars.\n    :returns: An array of size [NxMxP], where N is the number of influence factors, M\n        the number of input data, and P the number of features.\n    \"\"\"\ntensor_util: Type[TensorUtilities] = TensorUtilities.from_twice_differentiable(\nmodel\n)\nstack = tensor_util.stack\ntu_slice = tensor_util.slice\nreshape = tensor_util.reshape\nget_element = tensor_util.get_element\nshape = tensor_util.shape\nall_pert_influences = []\nfor x, y in maybe_progress(\ninput_data,\nprogress,\ndesc=\"Batch Influence Perturbation\",\n):\nfor i in range(len(x)):\ntensor_x = tu_slice(x, i, i + 1)\ngrad_xy = model.grad(tensor_x, get_element(y, i), create_graph=True)\nperturbation_influences = model.mvp(\ngrad_xy,\ninfluence_factors,\nbackprop_on=tensor_x,\n)\nall_pert_influences.append(\nreshape(perturbation_influences, (-1, *shape(get_element(x, i))))\n)\nreturn stack(all_pert_influences, axis=1)  # type:ignore\n</code></pre>"},{"location":"code-reference/pydvl/influence/general/#pydvl.influence.general.compute_influences","title":"<code>compute_influences(differentiable_model, training_data, *, test_data=None, input_data=None, inversion_method=InversionMethod.Direct, influence_type=InfluenceType.Up, hessian_regularization=0.0, progress=False, **kwargs)</code>","text":"<p>Calculates the influence of the input_data point j on the test points i. First it calculates the influence factors of all test points with respect to the model and the training points, and then uses them to get the influences over the complete input_data set.</p> <p>:param differentiable_model: A model wrapped with its loss in TwiceDifferentiable. :param training_data: data loader with the training data, used to calculate     the hessian of the model loss. :param test_data: data loader with the test samples. If None, the samples in     training_data are used. :param input_data: data loader with the samples to calculate the influences     of. If None, the samples in training_data are used. :param progress: whether to display progress bars. :param influence_type: Which algorithm to use to calculate influences.     Currently supported options: 'up' or 'perturbation'. For details refer     to :footcite:t:<code>koh_understanding_2017</code> :param hessian_regularization: lambda to use in Hessian regularization, i.e.     H_reg = H + lambda * 1, with 1 the identity matrix and H the (simple and     regularized) Hessian. Typically used with more complex models to make     sure the Hessian is positive definite. :returns: An array specifying the influences. Shape is [NxM] if     influence_type is'up', where N is number of test points and M number of     train points. If instead influence_type is 'perturbation', output shape     is [NxMxP], with P the number of input features.</p> Source code in <code>src/pydvl/influence/general.py</code> <pre><code>def compute_influences(\ndifferentiable_model: TwiceDifferentiable,\ntraining_data: DataLoaderType,\n*,\ntest_data: Optional[DataLoaderType] = None,\ninput_data: Optional[DataLoaderType] = None,\ninversion_method: InversionMethod = InversionMethod.Direct,\ninfluence_type: InfluenceType = InfluenceType.Up,\nhessian_regularization: float = 0.0,\nprogress: bool = False,\n**kwargs: Any,\n) -&gt; TensorType:  # type: ignore # ToDO fix typing\nr\"\"\"\n    Calculates the influence of the input_data point j on the test points i.\n    First it calculates the influence factors of all test points with respect\n    to the model and the training points, and then uses them to get the\n    influences over the complete input_data set.\n    :param differentiable_model: A model wrapped with its loss in TwiceDifferentiable.\n    :param training_data: data loader with the training data, used to calculate\n        the hessian of the model loss.\n    :param test_data: data loader with the test samples. If None, the samples in\n        training_data are used.\n    :param input_data: data loader with the samples to calculate the influences\n        of. If None, the samples in training_data are used.\n    :param progress: whether to display progress bars.\n    :param influence_type: Which algorithm to use to calculate influences.\n        Currently supported options: 'up' or 'perturbation'. For details refer\n        to :footcite:t:`koh_understanding_2017`\n    :param hessian_regularization: lambda to use in Hessian regularization, i.e.\n        H_reg = H + lambda * 1, with 1 the identity matrix and H the (simple and\n        regularized) Hessian. Typically used with more complex models to make\n        sure the Hessian is positive definite.\n    :returns: An array specifying the influences. Shape is [NxM] if\n        influence_type is'up', where N is number of test points and M number of\n        train points. If instead influence_type is 'perturbation', output shape\n        is [NxMxP], with P the number of input features.\n    \"\"\"\nif input_data is None:\ninput_data = deepcopy(training_data)\nif test_data is None:\ntest_data = deepcopy(training_data)\ninfluence_factors, _ = compute_influence_factors(\ndifferentiable_model,\ntraining_data,\ntest_data,\ninversion_method,\nhessian_perturbation=hessian_regularization,\nprogress=progress,\n**kwargs,\n)\nreturn influence_type_registry[influence_type](\ndifferentiable_model,\ninput_data,\ninfluence_factors,\nprogress=progress,\n)\n</code></pre>"},{"location":"code-reference/pydvl/influence/inversion/","title":"inversion","text":"<p>Contains methods to invert the hessian vector product.</p>"},{"location":"code-reference/pydvl/influence/inversion/#pydvl.influence.inversion.InversionMethod","title":"<code>InversionMethod</code>","text":"<p>             Bases: <code>str</code>, <code>Enum</code></p> <p>Different inversion methods types.</p>"},{"location":"code-reference/pydvl/influence/inversion/#pydvl.influence.inversion.InversionRegistry","title":"<code>InversionRegistry</code>","text":"<p>A registry to hold inversion methods for different models.</p>"},{"location":"code-reference/pydvl/influence/inversion/#pydvl.influence.inversion.InversionRegistry.register","title":"<code>register(model_type, inversion_method, overwrite=False)</code>  <code>classmethod</code>","text":"<p>Register a function for a specific model type and inversion method.</p> <p>The function to be registered must conform to the following signature: <code>(model: TwiceDifferentiable, training_data: DataLoaderType, b: TensorType, hessian_perturbation: float = 0.0, ...)</code>.</p> <p>:param model_type: The type of the model the function should be registered for. :param inversion_method: The inversion method the function should be     registered for. :param overwrite: If <code>True</code>, allows overwriting of an existing registered     function for the same model type and inversion method. If <code>False</code>,     logs a warning when attempting to register a function for an already     registered model type and inversion method.</p> <p>:raises TypeError: If the provided model_type or inversion_method are of the wrong type. :raises ValueError: If the function to be registered does not match the required signature. :return: A decorator for registering a function.</p> Source code in <code>src/pydvl/influence/inversion.py</code> <pre><code>@classmethod\ndef register(\ncls,\nmodel_type: Type[TwiceDifferentiable],\ninversion_method: InversionMethod,\noverwrite: bool = False,\n):\n\"\"\"\n    Register a function for a specific model type and inversion method.\n    The function to be registered must conform to the following signature:\n    `(model: TwiceDifferentiable, training_data: DataLoaderType, b: TensorType,\n    hessian_perturbation: float = 0.0, ...)`.\n    :param model_type: The type of the model the function should be registered for.\n    :param inversion_method: The inversion method the function should be\n        registered for.\n    :param overwrite: If ``True``, allows overwriting of an existing registered\n        function for the same model type and inversion method. If ``False``,\n        logs a warning when attempting to register a function for an already\n        registered model type and inversion method.\n    :raises TypeError: If the provided model_type or inversion_method are of the wrong type.\n    :raises ValueError: If the function to be registered does not match the required signature.\n    :return: A decorator for registering a function.\n    \"\"\"\nif not isinstance(model_type, type):\nraise TypeError(\nf\"'model_type' is of type {type(model_type)} but should be a Type[TwiceDifferentiable]\"\n)\nif not isinstance(inversion_method, InversionMethod):\nraise TypeError(\nf\"'inversion_method' must be an 'InversionMethod' \"\nf\"but has type {type(inversion_method)} instead.\"\n)\nkey = (model_type, inversion_method)\ndef decorator(func):\nif not overwrite and key in cls.registry:\nwarnings.warn(\nf\"There is already a function registered for model type {model_type} \"\nf\"and inversion method {inversion_method}. \"\nf\"To overwrite the existing function {cls.registry.get(key)} with {func}, set overwrite to True.\"\n)\nsig = inspect.signature(func)\nparams = list(sig.parameters.values())\nexpected_args = [\n(\"model\", model_type),\n(\"training_data\", DataLoaderType.__bound__),\n(\"b\", model_type.tensor_type()),\n(\"hessian_perturbation\", float),\n]\nfor (name, typ), param in zip(expected_args, params):\nif not (\nisinstance(param.annotation, typ)\nor issubclass(param.annotation, typ)\n):\nraise ValueError(\nf'Parameter \"{name}\" must be of type \"{typ.__name__}\"'\n)\n@functools.wraps(func)\ndef wrapper(*args, **kwargs):\nreturn func(*args, **kwargs)\ncls.registry[key] = wrapper\nreturn wrapper\nreturn decorator\n</code></pre>"},{"location":"code-reference/pydvl/influence/inversion/#pydvl.influence.inversion.InversionRegistry.call","title":"<code>call(inversion_method, model, training_data, b, hessian_perturbation, **kwargs)</code>  <code>classmethod</code>","text":"<p>Call a registered function with the provided parameters.</p> <p>:param inversion_method: The inversion method to use. :param model: A model wrapped in the TwiceDifferentiable interface. :param training_data: The training data to use. :param b: Array as the right hand side of the equation \\(Ax = b\\). :param hessian_perturbation: Regularization of the hessian. :param kwargs: Additional keyword arguments to pass to the inversion method.</p> <p>:return: An object that contains an array that solves the inverse problem,     i.e. it returns \\(x\\) such that \\(Ax = b\\), and a dictionary containing     information about the inversion process.</p> Source code in <code>src/pydvl/influence/inversion.py</code> <pre><code>@classmethod\ndef call(\ncls,\ninversion_method: InversionMethod,\nmodel: TwiceDifferentiable,\ntraining_data: DataLoaderType,\nb: TensorType,\nhessian_perturbation,\n**kwargs,\n) -&gt; InverseHvpResult:\n\"\"\"\n     Call a registered function with the provided parameters.\n    :param inversion_method: The inversion method to use.\n    :param model: A model wrapped in the TwiceDifferentiable interface.\n    :param training_data: The training data to use.\n    :param b: Array as the right hand side of the equation $Ax = b$.\n    :param hessian_perturbation: Regularization of the hessian.\n    :param kwargs: Additional keyword arguments to pass to the inversion method.\n    :return: An object that contains an array that solves the inverse problem,\n        i.e. it returns $x$ such that $Ax = b$, and a dictionary containing\n        information about the inversion process.\n    \"\"\"\nreturn cls.get(type(model), inversion_method)(\nmodel, training_data, b, hessian_perturbation, **kwargs\n)\n</code></pre>"},{"location":"code-reference/pydvl/influence/inversion/#pydvl.influence.inversion.solve_hvp","title":"<code>solve_hvp(inversion_method, model, training_data, b, *, hessian_perturbation=0.0, **kwargs)</code>","text":"<p>Finds \\(x\\) such that \\(Ax = b\\), where \\(A\\) is the hessian of model, and \\(b\\) a vector. Depending on the inversion method, the hessian is either calculated directly and then inverted, or implicitly and then inverted through matrix vector product. The method also allows to add a small regularization term (hessian_perturbation) to facilitate inversion of non fully trained models.</p> <p>:param inversion_method: :param model: A model wrapped in the TwiceDifferentiable interface. :param training_data: :param b: Array as the right hand side of the equation \\(Ax = b\\) :param hessian_perturbation: regularization of the hessian :param kwargs: kwargs to pass to the inversion method</p> <p>:return: An object that contains an array that solves the inverse problem,     i.e. it returns \\(x\\) such that \\(Ax = b\\), and a dictionary containing     information about the inversion process.</p> Source code in <code>src/pydvl/influence/inversion.py</code> <pre><code>def solve_hvp(\ninversion_method: InversionMethod,\nmodel: TwiceDifferentiable,\ntraining_data: DataLoaderType,\nb: TensorType,\n*,\nhessian_perturbation: float = 0.0,\n**kwargs: Any,\n) -&gt; InverseHvpResult:\n\"\"\"\n    Finds $x$ such that $Ax = b$, where $A$ is the hessian of model,\n    and $b$ a vector.\n    Depending on the inversion method, the hessian is either calculated directly\n    and then inverted, or implicitly and then inverted through matrix vector\n    product. The method also allows to add a small regularization term (hessian_perturbation)\n    to facilitate inversion of non fully trained models.\n    :param inversion_method:\n    :param model: A model wrapped in the TwiceDifferentiable interface.\n    :param training_data:\n    :param b: Array as the right hand side of the equation $Ax = b$\n    :param hessian_perturbation: regularization of the hessian\n    :param kwargs: kwargs to pass to the inversion method\n    :return: An object that contains an array that solves the inverse problem,\n        i.e. it returns $x$ such that $Ax = b$, and a dictionary containing\n        information about the inversion process.\n    \"\"\"\nreturn InversionRegistry.call(\ninversion_method,\nmodel,\ntraining_data,\nb,\nhessian_perturbation=hessian_perturbation,\n**kwargs,\n)\n</code></pre>"},{"location":"code-reference/pydvl/influence/twice_differentiable/","title":"twice_differentiable","text":""},{"location":"code-reference/pydvl/influence/twice_differentiable/#pydvl.influence.twice_differentiable.TwiceDifferentiable","title":"<code>TwiceDifferentiable</code>","text":"<p>             Bases: <code>ABC</code>, <code>Generic[TensorType]</code></p> <p>Wraps a differentiable model and loss and provides methods to compute gradients and second derivative of the loss wrt. the model parameters</p>"},{"location":"code-reference/pydvl/influence/twice_differentiable/#pydvl.influence.twice_differentiable.TwiceDifferentiable.num_params","title":"<code>num_params: int</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Returns the number of parameters of the model</p>"},{"location":"code-reference/pydvl/influence/twice_differentiable/#pydvl.influence.twice_differentiable.TwiceDifferentiable.parameters","title":"<code>parameters: List[TensorType]</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Returns all the model parameters that require differentiation</p>"},{"location":"code-reference/pydvl/influence/twice_differentiable/#pydvl.influence.twice_differentiable.TwiceDifferentiable.grad","title":"<code>grad(x, y, create_graph=False)</code>","text":"<p>Calculates gradient of model parameters wrt. the model parameters.</p> <p>:param x: A matrix representing the features \\(x_i\\). :param y: A matrix representing the target values \\(y_i\\).     gradients. This is important for further differentiation on input     parameters. :param create_graph: :return: A tuple where: the first element is an array with the     gradients of the model, and the second element is the input to the     model as a grad parameters. This can be used for further     differentiation.</p> Source code in <code>src/pydvl/influence/twice_differentiable.py</code> <pre><code>def grad(\nself, x: TensorType, y: TensorType, create_graph: bool = False\n) -&gt; TensorType:\n\"\"\"\n    Calculates gradient of model parameters wrt. the model parameters.\n    :param x: A matrix representing the features $x_i$.\n    :param y: A matrix representing the target values $y_i$.\n        gradients. This is important for further differentiation on input\n        parameters.\n    :param create_graph:\n    :return: A tuple where: the first element is an array with the\n        gradients of the model, and the second element is the input to the\n        model as a grad parameters. This can be used for further\n        differentiation.\n    \"\"\"\npass\n</code></pre>"},{"location":"code-reference/pydvl/influence/twice_differentiable/#pydvl.influence.twice_differentiable.TwiceDifferentiable.hessian","title":"<code>hessian(x, y)</code>","text":"<p>Calculates the full Hessian of \\(L(f(x),y)\\) with respect to the model parameters given data (\\(x\\) and \\(y\\)).</p> <p>:param x: An array representing the features \\(x_i\\). :param y: An array representing the target values \\(y_i\\). :return: The hessian of the model, i.e. the second derivative wrt. the     model parameters.</p> Source code in <code>src/pydvl/influence/twice_differentiable.py</code> <pre><code>def hessian(self, x: TensorType, y: TensorType) -&gt; TensorType:\n\"\"\"Calculates the full Hessian of $L(f(x),y)$ with respect to the model\n    parameters given data ($x$ and $y$).\n    :param x: An array representing the features $x_i$.\n    :param y: An array representing the target values $y_i$.\n    :return: The hessian of the model, i.e. the second derivative wrt. the\n        model parameters.\n    \"\"\"\npass\n</code></pre>"},{"location":"code-reference/pydvl/influence/twice_differentiable/#pydvl.influence.twice_differentiable.TwiceDifferentiable.mvp","title":"<code>mvp(grad_xy, v, backprop_on, *, progress=False)</code>  <code>abstractmethod</code> <code>staticmethod</code>","text":"<p>Calculates second order derivative of the model along directions v. This second order derivative can be selected through the backprop_on argument.</p> <p>:param grad_xy: an array [P] holding the gradients of the model     parameters wrt input \\(x\\) and labels \\(y\\), where P is the number of     parameters of the model. It is typically obtained through     self.grad. :param v: An array ([DxP] or even one dimensional [D]) which     multiplies the matrix, where D is the number of directions. :param progress: True, iff progress shall be printed. :param backprop_on: tensor used in the second backpropagation (the first     one is along \\(x\\) and \\(y\\) as defined via grad_xy). :returns: A matrix representing the implicit matrix vector product     of the model along the given directions. Output shape is [DxP] if     backprop_on is None, otherwise [DxM], with M the number of elements     of backprop_on.</p> Source code in <code>src/pydvl/influence/twice_differentiable.py</code> <pre><code>@staticmethod\n@abstractmethod\ndef mvp(\ngrad_xy: TensorType,\nv: TensorType,\nbackprop_on: TensorType,\n*,\nprogress: bool = False,\n) -&gt; TensorType:\n\"\"\"\n    Calculates second order derivative of the model along directions v.\n    This second order derivative can be selected through the backprop_on argument.\n    :param grad_xy: an array [P] holding the gradients of the model\n        parameters wrt input $x$ and labels $y$, where P is the number of\n        parameters of the model. It is typically obtained through\n        self.grad.\n    :param v: An array ([DxP] or even one dimensional [D]) which\n        multiplies the matrix, where D is the number of directions.\n    :param progress: True, iff progress shall be printed.\n    :param backprop_on: tensor used in the second backpropagation (the first\n        one is along $x$ and $y$ as defined via grad_xy).\n    :returns: A matrix representing the implicit matrix vector product\n        of the model along the given directions. Output shape is [DxP] if\n        backprop_on is None, otherwise [DxM], with M the number of elements\n        of backprop_on.\n    \"\"\"\n</code></pre>"},{"location":"code-reference/pydvl/influence/twice_differentiable/#pydvl.influence.twice_differentiable.TensorUtilities","title":"<code>TensorUtilities</code>","text":"<p>             Bases: <code>Generic[TensorType, ModelType]</code>, <code>ABC</code></p>"},{"location":"code-reference/pydvl/influence/twice_differentiable/#pydvl.influence.twice_differentiable.TensorUtilities.__init_subclass__","title":"<code>__init_subclass__(**kwargs)</code>","text":"<p>Automatically registers non-abstract subclasses in the registry.</p> <p>Checks if <code>twice_differentiable_type</code> is defined in the subclass and is of correct type. Raises <code>TypeError</code> if either attribute is missing or incorrect.</p> <p>:param kwargs: Additional keyword arguments. :raise TypeError: If the subclass does not define <code>twice_differentiable_type</code>, or if it is not of correct type.</p> Source code in <code>src/pydvl/influence/twice_differentiable.py</code> <pre><code>def __init_subclass__(cls, **kwargs):\n\"\"\"\n    Automatically registers non-abstract subclasses in the registry.\n    Checks if `twice_differentiable_type` is defined in the subclass and\n    is of correct type. Raises `TypeError` if either attribute is missing or incorrect.\n    :param kwargs: Additional keyword arguments.\n    :raise TypeError: If the subclass does not define `twice_differentiable_type`,\n    or if it is not of correct type.\n    \"\"\"\nif not hasattr(cls, \"twice_differentiable_type\") or not isinstance(\ncls.twice_differentiable_type, type\n):\nraise TypeError(\nf\"'twice_differentiable_type' must be a Type[TwiceDifferentiable]\"\n)\ncls.registry[cls.twice_differentiable_type] = cls\nsuper().__init_subclass__(**kwargs)\n</code></pre>"},{"location":"code-reference/pydvl/influence/twice_differentiable/#pydvl.influence.twice_differentiable.TensorUtilities.einsum","title":"<code>einsum(equation, *operands)</code>  <code>abstractmethod</code> <code>staticmethod</code>","text":"<p>Sums the product of the elements of the input :attr:<code>operands</code> along dimensions specified using a notation based on the Einstein summation convention.</p> Source code in <code>src/pydvl/influence/twice_differentiable.py</code> <pre><code>@staticmethod\n@abstractmethod\ndef einsum(equation, *operands) -&gt; TensorType:\n\"\"\"Sums the product of the elements of the input :attr:`operands` along dimensions specified using a notation\n    based on the Einstein summation convention.\n    \"\"\"\n</code></pre>"},{"location":"code-reference/pydvl/influence/twice_differentiable/#pydvl.influence.twice_differentiable.TensorUtilities.cat","title":"<code>cat(a, **kwargs)</code>  <code>abstractmethod</code> <code>staticmethod</code>","text":"<p>Concatenates a sequence of tensors into a single torch tensor</p> Source code in <code>src/pydvl/influence/twice_differentiable.py</code> <pre><code>@staticmethod\n@abstractmethod\ndef cat(a: Sequence[TensorType], **kwargs) -&gt; TensorType:\n\"\"\"Concatenates a sequence of tensors into a single torch tensor\"\"\"\n</code></pre>"},{"location":"code-reference/pydvl/influence/twice_differentiable/#pydvl.influence.twice_differentiable.TensorUtilities.stack","title":"<code>stack(a, **kwargs)</code>  <code>abstractmethod</code> <code>staticmethod</code>","text":"<p>Stacks a sequence of tensors into a single torch tensor</p> Source code in <code>src/pydvl/influence/twice_differentiable.py</code> <pre><code>@staticmethod\n@abstractmethod\ndef stack(a: Sequence[TensorType], **kwargs) -&gt; TensorType:\n\"\"\"Stacks a sequence of tensors into a single torch tensor\"\"\"\n</code></pre>"},{"location":"code-reference/pydvl/influence/twice_differentiable/#pydvl.influence.twice_differentiable.TensorUtilities.unsqueeze","title":"<code>unsqueeze(x, dim)</code>  <code>abstractmethod</code> <code>staticmethod</code>","text":"<p>Add a singleton dimension at a specified position in a tensor</p> Source code in <code>src/pydvl/influence/twice_differentiable.py</code> <pre><code>@staticmethod\n@abstractmethod\ndef unsqueeze(x: TensorType, dim: int) -&gt; TensorType:\n\"\"\"Add a singleton dimension at a specified position in a tensor\"\"\"\n</code></pre>"},{"location":"code-reference/pydvl/influence/twice_differentiable/#pydvl.influence.twice_differentiable.TensorUtilities.get_element","title":"<code>get_element(x, idx)</code>  <code>abstractmethod</code> <code>staticmethod</code>","text":"<p>Get the tensor element x[i] from the first non-singular dimension</p> Source code in <code>src/pydvl/influence/twice_differentiable.py</code> <pre><code>@staticmethod\n@abstractmethod\ndef get_element(x: TensorType, idx: int) -&gt; TensorType:\n\"\"\"Get the tensor element x[i] from the first non-singular dimension\"\"\"\n</code></pre>"},{"location":"code-reference/pydvl/influence/twice_differentiable/#pydvl.influence.twice_differentiable.TensorUtilities.slice","title":"<code>slice(x, start, stop, axis=0)</code>  <code>abstractmethod</code> <code>staticmethod</code>","text":"<p>Slice a tensor in the provided axis</p> Source code in <code>src/pydvl/influence/twice_differentiable.py</code> <pre><code>@staticmethod\n@abstractmethod\ndef slice(x: TensorType, start: int, stop: int, axis: int = 0) -&gt; TensorType:\n\"\"\"Slice a tensor in the provided axis\"\"\"\n</code></pre>"},{"location":"code-reference/pydvl/influence/twice_differentiable/#pydvl.influence.twice_differentiable.TensorUtilities.shape","title":"<code>shape(x)</code>  <code>abstractmethod</code> <code>staticmethod</code>","text":"<p>Slice a tensor in the provided axis</p> Source code in <code>src/pydvl/influence/twice_differentiable.py</code> <pre><code>@staticmethod\n@abstractmethod\ndef shape(x: TensorType) -&gt; Tuple[int, ...]:\n\"\"\"Slice a tensor in the provided axis\"\"\"\n</code></pre>"},{"location":"code-reference/pydvl/influence/twice_differentiable/#pydvl.influence.twice_differentiable.TensorUtilities.reshape","title":"<code>reshape(x, shape)</code>  <code>abstractmethod</code> <code>staticmethod</code>","text":"<p>Reshape a tensor to the provided shape</p> Source code in <code>src/pydvl/influence/twice_differentiable.py</code> <pre><code>@staticmethod\n@abstractmethod\ndef reshape(x: TensorType, shape: Tuple[int, ...]) -&gt; TensorType:\n\"\"\"Reshape a tensor to the provided shape\"\"\"\n</code></pre>"},{"location":"code-reference/pydvl/influence/twice_differentiable/#pydvl.influence.twice_differentiable.TensorUtilities.cat_gen","title":"<code>cat_gen(a, resulting_shape, model)</code>  <code>abstractmethod</code> <code>staticmethod</code>","text":"<p>Concatenate tensors from a generator. Resulting tensor is of shape resulting_shape and compatible to model</p> Source code in <code>src/pydvl/influence/twice_differentiable.py</code> <pre><code>@staticmethod\n@abstractmethod\ndef cat_gen(\na: Generator[TensorType, None, None],\nresulting_shape: Tuple[int, ...],\nmodel: ModelType,\n) -&gt; TensorType:\n\"\"\"Concatenate tensors from a generator. Resulting tensor is of shape resulting_shape\n    and compatible to model\n    \"\"\"\n</code></pre>"},{"location":"code-reference/pydvl/influence/twice_differentiable/#pydvl.influence.twice_differentiable.TensorUtilities.from_twice_differentiable","title":"<code>from_twice_differentiable(twice_diff)</code>  <code>classmethod</code>","text":"<p>Factory method to create an instance of <code>TensorUtilities</code> from an instance of <code>TwiceDifferentiable</code>.</p> <p>:param twice_diff: An instance of <code>TwiceDifferentiable</code>     for which a corresponding <code>TensorUtilities</code> object is required. :return: An instance of <code>TensorUtilities</code> corresponding to the provided <code>TwiceDifferentiable</code> object. :raises KeyError: If there's no registered <code>TensorUtilities</code> for the provided <code>TwiceDifferentiable</code> type.</p> Source code in <code>src/pydvl/influence/twice_differentiable.py</code> <pre><code>@classmethod\ndef from_twice_differentiable(\ncls,\ntwice_diff: TwiceDifferentiable,\n) -&gt; Type[\"TensorUtilities\"]:\n\"\"\"\n    Factory method to create an instance of `TensorUtilities` from an instance of `TwiceDifferentiable`.\n    :param twice_diff: An instance of `TwiceDifferentiable`\n        for which a corresponding `TensorUtilities` object is required.\n    :return: An instance of `TensorUtilities` corresponding to the provided `TwiceDifferentiable` object.\n    :raises KeyError: If there's no registered `TensorUtilities` for the provided `TwiceDifferentiable` type.\n    \"\"\"\ntu = cls.registry.get(type(twice_diff), None)\nif tu is None:\nraise KeyError(\nf\"No registered TensorUtilities for the type {type(twice_diff).__name__}\"\n)\nreturn tu\n</code></pre>"},{"location":"code-reference/pydvl/influence/torch/","title":"torch","text":""},{"location":"code-reference/pydvl/influence/torch/functional/","title":"functional","text":""},{"location":"code-reference/pydvl/influence/torch/functional/#pydvl.influence.torch.functional.hvp","title":"<code>hvp(func, params, vec, reverse_only=True)</code>","text":"<p>Computes the Hessian-vector product (HVP) for a given function at given parameters.  This function can operate in two modes, either reverse-mode autodiff only or both  forward- and reverse-mode autodiff.</p> <p>:param func: The scalar-valued function for which the HVP is computed. :param params: The parameters at which the HVP is computed. :param vec: The vector with which the Hessian is multiplied. :param reverse_only: Whether to use only reverse-mode autodiff          (True, default) or both forward- and reverse-mode autodiff (False).</p> <p>:return: Input_type: The HVP of the function at the given parameters with the given vector.</p> <p>:Example:</p> <p>def f(z): return torch.sum(z**2) u = torch.ones(10, requires_grad=True) v = torch.ones(10) hvp_vec = hvp(f, u, v) assert torch.allclose(hvp_vec, torch.full((10, ), 2.0))</p> Source code in <code>src/pydvl/influence/torch/functional.py</code> <pre><code>def hvp(\nfunc: Callable[[TorchTensorContainerType], torch.Tensor],\nparams: TorchTensorContainerType,\nvec: TorchTensorContainerType,\nreverse_only: bool = True,\n) -&gt; TorchTensorContainerType:\n\"\"\"\n     Computes the Hessian-vector product (HVP) for a given function at given parameters.\n     This function can operate in two modes, either reverse-mode autodiff only or both\n     forward- and reverse-mode autodiff.\n    :param func: The scalar-valued function for which the HVP is computed.\n    :param params: The parameters at which the HVP is computed.\n    :param vec: The vector with which the Hessian is multiplied.\n    :param reverse_only: Whether to use only reverse-mode autodiff\n             (True, default) or both forward- and reverse-mode autodiff (False).\n     :return: Input_type: The HVP of the function at the given parameters with the given vector.\n     :Example:\n      &gt;&gt;&gt; def f(z): return torch.sum(z**2)\n      &gt;&gt;&gt; u = torch.ones(10, requires_grad=True)\n      &gt;&gt;&gt; v = torch.ones(10)\n      &gt;&gt;&gt; hvp_vec = hvp(f, u, v)\n      &gt;&gt;&gt; assert torch.allclose(hvp_vec, torch.full((10, ), 2.0))\n    \"\"\"\noutput: TorchTensorContainerType\nif reverse_only:\n_, vjp_fn = vjp(grad(func), params)\noutput = vjp_fn(vec)[0]\nelse:\noutput = jvp(grad(func), (params,), (vec,))[1]\nreturn output\n</code></pre>"},{"location":"code-reference/pydvl/influence/torch/functional/#pydvl.influence.torch.functional.batch_hvp_gen","title":"<code>batch_hvp_gen(model, loss, data_loader, reverse_only=True)</code>","text":"<p>Generates a sequence of batch Hessian-vector product (HVP) computations for the provided model, loss function, and data loader.</p> <p>The generator iterates over the data_loader, creating partial function calls for calculating HVPs.</p> <p>:param model: The PyTorch model for which the HVP is calculated. :param loss: The loss function used to calculate the gradient and HVP. :param data_loader: PyTorch DataLoader object containing the dataset for which the HVP is calculated. :param reverse_only: :yield: A partial function H(vec)=hvp(model, loss, inputs, targets, vec) that when called,         will compute the Hessian-vector product H(vec) for the given model, loss, inputs and targets.</p> Source code in <code>src/pydvl/influence/torch/functional.py</code> <pre><code>def batch_hvp_gen(\nmodel: torch.nn.Module,\nloss: Callable[[torch.Tensor, torch.Tensor], torch.Tensor],\ndata_loader: DataLoader,\nreverse_only: bool = True,\n) -&gt; Generator[Callable[[torch.Tensor], torch.Tensor], None, None]:\n\"\"\"\n    Generates a sequence of batch Hessian-vector product (HVP) computations for the provided model, loss function,\n    and data loader.\n    The generator iterates over the data_loader, creating partial function calls for calculating HVPs.\n    :param model: The PyTorch model for which the HVP is calculated.\n    :param loss: The loss function used to calculate the gradient and HVP.\n    :param data_loader: PyTorch DataLoader object containing the dataset for which the HVP is calculated.\n    :param reverse_only:\n    :yield: A partial function H(vec)=hvp(model, loss, inputs, targets, vec) that when called,\n            will compute the Hessian-vector product H(vec) for the given model, loss, inputs and targets.\n    \"\"\"\nfor inputs, targets in iter(data_loader):\nbatch_loss = batch_loss_function(model, loss, inputs, targets)\nmodel_params = dict(model.named_parameters())\ndef batch_hvp(vec: torch.Tensor):\nreturn flatten_tensors_to_vector(\nhvp(\nbatch_loss,\nmodel_params,\nalign_structure(model_params, vec),\nreverse_only=reverse_only,\n).values()\n)\nyield batch_hvp\n</code></pre>"},{"location":"code-reference/pydvl/influence/torch/functional/#pydvl.influence.torch.functional.empirical_loss_function","title":"<code>empirical_loss_function(model, loss, data_loader)</code>","text":"<p>Creates a function to compute the empirical loss of a given model on a given dataset. If we denote the model parameters with $    heta$, the resulting function approximates</p> <p>.. math::</p> <pre><code>f(      heta) = \frac{1}{N}\\sum_{i=1}^N \\operatorname{loss}(y_i, \\operatorname{model}(   heta, x_i)))\n</code></pre> <p>:param model: The model for which the loss should be computed. :param loss: The loss function to be used. :param data_loader: The data loader for iterating over the dataset.</p> <p>:return: A function that computes the empirical loss               of the model on the dataset for given model parameters.</p> Source code in <code>src/pydvl/influence/torch/functional.py</code> <pre><code>def empirical_loss_function(\nmodel: torch.nn.Module,\nloss: Callable[[torch.Tensor, torch.Tensor], torch.Tensor],\ndata_loader: DataLoader,\n) -&gt; Callable[[Dict[str, torch.Tensor]], torch.Tensor]:\n\"\"\"\n    Creates a function to compute the empirical loss of a given model on a given dataset.\n    If we denote the model parameters with $\\theta$, the resulting function approximates\n    .. math::\n        f(\\theta) = \\frac{1}{N}\\sum_{i=1}^N \\operatorname{loss}(y_i, \\operatorname{model}(\\theta, x_i)))\n    :param model: The model for which the loss should be computed.\n    :param loss: The loss function to be used.\n    :param data_loader: The data loader for iterating over the dataset.\n    :return: A function that computes the empirical loss\n                  of the model on the dataset for given model parameters.\n    \"\"\"\ndef empirical_loss(params: Dict[str, torch.Tensor]):\ntotal_loss = to_model_device(torch.zeros((), requires_grad=True), model)\ntotal_samples = to_model_device(torch.zeros(()), model)\nfor x, y in iter(data_loader):\noutput = functional_call(\nmodel, params, (to_model_device(x, model),), strict=True\n)\nloss_value = loss(output, to_model_device(y, model))\ntotal_loss = total_loss + loss_value * x.size(0)\ntotal_samples += x.size(0)\nreturn total_loss / total_samples\nreturn empirical_loss\n</code></pre>"},{"location":"code-reference/pydvl/influence/torch/functional/#pydvl.influence.torch.functional.batch_loss_function","title":"<code>batch_loss_function(model, loss, x, y)</code>","text":"<p>Creates a function to compute the loss of a given model on a given batch of data.</p> <p>:param model: The model for which the loss should be computed. :param loss: The loss function to be used. :param x: The input data for the batch. :param y: The true labels for the batch.</p> <p>:return: A function that computes the loss                of the model on the batch for given model parameters.</p> Source code in <code>src/pydvl/influence/torch/functional.py</code> <pre><code>def batch_loss_function(\nmodel: torch.nn.Module,\nloss: Callable[[torch.Tensor, torch.Tensor], torch.Tensor],\nx: torch.Tensor,\ny: torch.Tensor,\n) -&gt; Callable[[Dict[str, torch.Tensor]], torch.Tensor]:\n\"\"\"\n     Creates a function to compute the loss of a given model on a given batch of data.\n    :param model: The model for which the loss should be computed.\n    :param loss: The loss function to be used.\n    :param x: The input data for the batch.\n    :param y: The true labels for the batch.\n    :return: A function that computes the loss\n                   of the model on the batch for given model parameters.\n    \"\"\"\ndef batch_loss(params: Dict[str, torch.Tensor]):\noutputs = functional_call(\nmodel, params, (to_model_device(x, model),), strict=True\n)\nreturn loss(outputs, y)\nreturn batch_loss\n</code></pre>"},{"location":"code-reference/pydvl/influence/torch/functional/#pydvl.influence.torch.functional.get_hvp_function","title":"<code>get_hvp_function(model, loss, data_loader, use_hessian_avg=True, reverse_only=True, track_gradients=False)</code>","text":"<p>Returns a function that calculates the approximate Hessian-vector product for a given vector. If you want to compute the exact hessian, i.e. pulling all data into memory and compute a full gradient computation, use the function :func:<code>hvp</code>.</p> <p>:param model: A PyTorch module representing the model whose loss function's Hessian is to be computed. :param loss: A callable that takes the model's output and target as input and returns the scalar loss. :param data_loader: A DataLoader instance that provides batches of data for calculating the Hessian-vector product.                     Each batch from the DataLoader is assumed to return a tuple where the first element                     is the model's input and the second element is the target output. :param use_hessian_avg: If True, it will use batch-wise Hessian computation. If False, the function averages                         the batch gradients and perform backpropagation on the full (averaged) gradient,                         which is more accurate than averaging the batch hessians,                         but probably has a way higher memory usage. :param reverse_only: Whether to use only reverse-mode autodiff         (True, default) or both forward- and reverse-mode autodiff (False) :param track_gradients: Whether to track gradients for the resulting tensor of the hessian vector products are         (False, default).</p> <p>:return: A function that takes a single argument, a vector, and returns the product of the Hessian of the          <code>loss</code> function with respect to the <code>model</code>'s parameters and the input vector.</p> Source code in <code>src/pydvl/influence/torch/functional.py</code> <pre><code>def get_hvp_function(\nmodel: torch.nn.Module,\nloss: Callable[[torch.Tensor, torch.Tensor], torch.Tensor],\ndata_loader: DataLoader,\nuse_hessian_avg: bool = True,\nreverse_only: bool = True,\ntrack_gradients: bool = False,\n) -&gt; Callable[[torch.Tensor], torch.Tensor]:\n\"\"\"\n    Returns a function that calculates the approximate Hessian-vector product for a given vector. If you want to\n    compute the exact hessian, i.e. pulling all data into memory and compute a full gradient computation, use\n    the function :func:`hvp`.\n    :param model: A PyTorch module representing the model whose loss function's Hessian is to be computed.\n    :param loss: A callable that takes the model's output and target as input and returns the scalar loss.\n    :param data_loader: A DataLoader instance that provides batches of data for calculating the Hessian-vector product.\n                        Each batch from the DataLoader is assumed to return a tuple where the first element\n                        is the model's input and the second element is the target output.\n    :param use_hessian_avg: If True, it will use batch-wise Hessian computation. If False, the function averages\n                            the batch gradients and perform backpropagation on the full (averaged) gradient,\n                            which is more accurate than averaging the batch hessians,\n                            but probably has a way higher memory usage.\n    :param reverse_only: Whether to use only reverse-mode autodiff\n            (True, default) or both forward- and reverse-mode autodiff (False)\n    :param track_gradients: Whether to track gradients for the resulting tensor of the hessian vector products are\n            (False, default).\n    :return: A function that takes a single argument, a vector, and returns the product of the Hessian of the\n             `loss` function with respect to the `model`'s parameters and the input vector.\n    \"\"\"\nparams = {\nk: p if track_gradients else p.detach() for k, p in model.named_parameters()\n}\ndef hvp_function(vec: torch.Tensor) -&gt; torch.Tensor:\nv = align_structure(params, vec)\nempirical_loss = empirical_loss_function(model, loss, data_loader)\nreturn flatten_tensors_to_vector(\nhvp(empirical_loss, params, v, reverse_only=reverse_only).values()\n)\ndef avg_hvp_function(vec: torch.Tensor) -&gt; torch.Tensor:\nv = align_structure(params, vec)\nbatch_hessians_vector_products: Iterable[torch.Tensor] = map(\nlambda x: x(v), batch_hvp_gen(model, loss, data_loader, reverse_only)\n)\nnum_batches = len(data_loader)\navg_hessian = to_model_device(torch.zeros_like(vec), model)\nfor batch_hvp in batch_hessians_vector_products:\navg_hessian += batch_hvp\nreturn avg_hessian / float(num_batches)\nreturn avg_hvp_function if use_hessian_avg else hvp_function\n</code></pre>"},{"location":"code-reference/pydvl/influence/torch/torch_differentiable/","title":"torch_differentiable","text":"<p>Contains methods for differentiating  a pyTorch model. Most of the methods focus on ways to calculate matrix vector products. Moreover, it contains several methods to invert the Hessian vector product. These are used to calculate the influence of a training point on the model.</p>"},{"location":"code-reference/pydvl/influence/torch/torch_differentiable/#pydvl.influence.torch.torch_differentiable.TorchTwiceDifferentiable","title":"<code>TorchTwiceDifferentiable(model, loss)</code>","text":"<p>             Bases: <code>TwiceDifferentiable[torch.Tensor]</code></p> <pre><code>mapping a prediction and a target to a real value.\n</code></pre> Source code in <code>src/pydvl/influence/torch/torch_differentiable.py</code> <pre><code>def __init__(\nself,\nmodel: nn.Module,\nloss: Callable[[torch.Tensor, torch.Tensor], torch.Tensor],\n):\nr\"\"\"\n    :param model: A (differentiable) function.\n    :param loss:  A differentiable scalar loss $L(\\hat{y}, y)$,\n        mapping a prediction and a target to a real value.\n    \"\"\"\nif model.training:\nlogger.warning(\n\"Passed model not in evaluation mode. This can create several issues in influence \"\n\"computation, e.g. due to batch normalization. Please call model.eval() before \"\n\"computing influences.\"\n)\nself.loss = loss\nself.model = model\nfirst_param = next(model.parameters())\nself.device = first_param.device\nself.dtype = first_param.dtype\n</code></pre>"},{"location":"code-reference/pydvl/influence/torch/torch_differentiable/#pydvl.influence.torch.torch_differentiable.TorchTwiceDifferentiable.parameters","title":"<code>parameters: List[torch.Tensor]</code>  <code>property</code>","text":"<p>Returns all the model parameters that require differentiating</p>"},{"location":"code-reference/pydvl/influence/torch/torch_differentiable/#pydvl.influence.torch.torch_differentiable.TorchTwiceDifferentiable.num_params","title":"<code>num_params: int</code>  <code>property</code>","text":"<p>Get number of parameters of model f. :returns: Number of parameters as integer.</p>"},{"location":"code-reference/pydvl/influence/torch/torch_differentiable/#pydvl.influence.torch.torch_differentiable.TorchTwiceDifferentiable.grad","title":"<code>grad(x, y, create_graph=False)</code>","text":"<p>Calculates gradient of model parameters wrt the model parameters.</p> <p>:param x: A matrix [NxD] representing the features \\(x_i\\). :param y: A matrix [NxK] representing the target values \\(y_i\\). :param create_graph: If True, the resulting gradient tensor, can be used for further differentiation :returns: An array [P] with the gradients of the model.</p> Source code in <code>src/pydvl/influence/torch/torch_differentiable.py</code> <pre><code>def grad(\nself, x: torch.Tensor, y: torch.Tensor, create_graph: bool = False\n) -&gt; torch.Tensor:\n\"\"\"\n    Calculates gradient of model parameters wrt the model parameters.\n    :param x: A matrix [NxD] representing the features $x_i$.\n    :param y: A matrix [NxK] representing the target values $y_i$.\n    :param create_graph: If True, the resulting gradient tensor, can be used for further differentiation\n    :returns: An array [P] with the gradients of the model.\n    \"\"\"\nx = x.to(self.device)\ny = y.to(self.device)\nif create_graph and not x.requires_grad:\nx = x.requires_grad_(True)\nloss_value = self.loss(torch.squeeze(self.model(x)), torch.squeeze(y))\ngrad_f = torch.autograd.grad(\nloss_value, self.parameters, create_graph=create_graph\n)\nreturn flatten_tensors_to_vector(grad_f)\n</code></pre>"},{"location":"code-reference/pydvl/influence/torch/torch_differentiable/#pydvl.influence.torch.torch_differentiable.TorchTwiceDifferentiable.hessian","title":"<code>hessian(x, y)</code>","text":"<p>Calculates the explicit hessian of model parameters given data (\\(x\\) and \\(y\\)). :param x: A matrix [NxD] representing the features \\(x_i\\). :param y: A matrix [NxK] representing the target values \\(y_i\\). :returns: A tensor representing the hessian of the loss wrt. the model parameters.</p> Source code in <code>src/pydvl/influence/torch/torch_differentiable.py</code> <pre><code>def hessian(self, x: torch.Tensor, y: torch.Tensor) -&gt; torch.Tensor:\n\"\"\"Calculates the explicit hessian of model parameters given data ($x$ and $y$).\n    :param x: A matrix [NxD] representing the features $x_i$.\n    :param y: A matrix [NxK] representing the target values $y_i$.\n    :returns: A tensor representing the hessian of the loss wrt. the model parameters.\n    \"\"\"\ndef model_func(param):\noutputs = torch.func.functional_call(\nself.model,\nalign_structure(\n{k: p for k, p in self.model.named_parameters() if p.requires_grad},\nparam,\n),\n(x.to(self.device),),\nstrict=True,\n)\nreturn self.loss(outputs, y.to(self.device))\nparams = flatten_tensors_to_vector(\np.detach() for p in self.model.parameters() if p.requires_grad\n)\nreturn torch.func.hessian(model_func)(params)\n</code></pre>"},{"location":"code-reference/pydvl/influence/torch/torch_differentiable/#pydvl.influence.torch.torch_differentiable.TorchTwiceDifferentiable.mvp","title":"<code>mvp(grad_xy, v, backprop_on, *, progress=False)</code>  <code>staticmethod</code>","text":"<p>Calculates second order derivative of the model along directions v. This second order derivative can be selected through the backprop_on argument.</p> <p>:param grad_xy: an array [P] holding the gradients of the model     parameters wrt input \\(x\\) and labels \\(y\\), where P is the number of     parameters of the model. It is typically obtained through     self.grad. :param v: An array ([DxP] or even one dimensional [D]) which     multiplies the matrix, where D is the number of directions. :param progress: True, iff progress shall be printed. :param backprop_on: tensor used in the second backpropagation (the first     one is along \\(x\\) and \\(y\\) as defined via grad_xy). :returns: A matrix representing the implicit matrix vector product     of the model along the given directions. Output shape is [DxP] if     backprop_on is None, otherwise [DxM], with M the number of elements     of backprop_on.</p> Source code in <code>src/pydvl/influence/torch/torch_differentiable.py</code> <pre><code>@staticmethod\ndef mvp(\ngrad_xy: torch.Tensor,\nv: torch.Tensor,\nbackprop_on: torch.Tensor,\n*,\nprogress: bool = False,\n) -&gt; torch.Tensor:\n\"\"\"\n    Calculates second order derivative of the model along directions v.\n    This second order derivative can be selected through the backprop_on argument.\n    :param grad_xy: an array [P] holding the gradients of the model\n        parameters wrt input $x$ and labels $y$, where P is the number of\n        parameters of the model. It is typically obtained through\n        self.grad.\n    :param v: An array ([DxP] or even one dimensional [D]) which\n        multiplies the matrix, where D is the number of directions.\n    :param progress: True, iff progress shall be printed.\n    :param backprop_on: tensor used in the second backpropagation (the first\n        one is along $x$ and $y$ as defined via grad_xy).\n    :returns: A matrix representing the implicit matrix vector product\n        of the model along the given directions. Output shape is [DxP] if\n        backprop_on is None, otherwise [DxM], with M the number of elements\n        of backprop_on.\n    \"\"\"\ndevice = grad_xy.device\nv = as_tensor(v, warn=False).to(device)\nif v.ndim == 1:\nv = v.unsqueeze(0)\nz = (grad_xy * Variable(v)).sum(dim=1)\nmvp = []\nfor i in maybe_progress(range(len(z)), progress, desc=\"MVP\"):\nmvp.append(\nflatten_tensors_to_vector(\nautograd.grad(z[i], backprop_on, retain_graph=True)\n)\n)\nreturn torch.stack([grad.contiguous().view(-1) for grad in mvp]).detach()\n</code></pre>"},{"location":"code-reference/pydvl/influence/torch/torch_differentiable/#pydvl.influence.torch.torch_differentiable.LowRankProductRepresentation","title":"<code>LowRankProductRepresentation</code>  <code>dataclass</code>","text":"<p>Representation of a low rank product of the form \\(H = V D V^T\\), where D is a diagonal matrix and V is orthogonal :param eigen_vals: diagonal of D :param projections: the matrix V</p>"},{"location":"code-reference/pydvl/influence/torch/torch_differentiable/#pydvl.influence.torch.torch_differentiable.LowRankProductRepresentation.to","title":"<code>to(device)</code>","text":"<p>Move the representing tensors to a device</p> Source code in <code>src/pydvl/influence/torch/torch_differentiable.py</code> <pre><code>def to(self, device: torch.device):\n\"\"\"\n    Move the representing tensors to a device\n    \"\"\"\nreturn LowRankProductRepresentation(\nself.eigen_vals.to(device), self.projections.to(device)\n)\n</code></pre>"},{"location":"code-reference/pydvl/influence/torch/torch_differentiable/#pydvl.influence.torch.torch_differentiable.TorchTensorUtilities","title":"<code>TorchTensorUtilities</code>","text":"<p>             Bases: <code>TensorUtilities[Tensor, TorchTwiceDifferentiable]</code></p>"},{"location":"code-reference/pydvl/influence/torch/torch_differentiable/#pydvl.influence.torch.torch_differentiable.TorchTensorUtilities.einsum","title":"<code>einsum(equation, *operands)</code>  <code>staticmethod</code>","text":"<p>Sums the product of the elements of the input :attr:<code>operands</code> along dimensions specified using a notation based on the Einstein summation convention.</p> Source code in <code>src/pydvl/influence/torch/torch_differentiable.py</code> <pre><code>@staticmethod\ndef einsum(equation: str, *operands) -&gt; torch.Tensor:\n\"\"\"Sums the product of the elements of the input :attr:`operands` along dimensions specified using a notation\n    based on the Einstein summation convention.\n    \"\"\"\nreturn torch.einsum(equation, *operands)\n</code></pre>"},{"location":"code-reference/pydvl/influence/torch/torch_differentiable/#pydvl.influence.torch.torch_differentiable.TorchTensorUtilities.cat","title":"<code>cat(a, **kwargs)</code>  <code>staticmethod</code>","text":"<p>Concatenates a sequence of tensors into a single torch tensor</p> Source code in <code>src/pydvl/influence/torch/torch_differentiable.py</code> <pre><code>@staticmethod\ndef cat(a: Sequence[torch.Tensor], **kwargs) -&gt; torch.Tensor:\n\"\"\"Concatenates a sequence of tensors into a single torch tensor\"\"\"\nreturn torch.cat(a, **kwargs)\n</code></pre>"},{"location":"code-reference/pydvl/influence/torch/torch_differentiable/#pydvl.influence.torch.torch_differentiable.TorchTensorUtilities.stack","title":"<code>stack(a, **kwargs)</code>  <code>staticmethod</code>","text":"<p>Stacks a sequence of tensors into a single torch tensor</p> Source code in <code>src/pydvl/influence/torch/torch_differentiable.py</code> <pre><code>@staticmethod\ndef stack(a: Sequence[torch.Tensor], **kwargs) -&gt; torch.Tensor:\n\"\"\"Stacks a sequence of tensors into a single torch tensor\"\"\"\nreturn torch.stack(a, **kwargs)\n</code></pre>"},{"location":"code-reference/pydvl/influence/torch/torch_differentiable/#pydvl.influence.torch.torch_differentiable.TorchTensorUtilities.unsqueeze","title":"<code>unsqueeze(x, dim)</code>  <code>staticmethod</code>","text":"<p>Add a singleton dimension at a specified position in a tensor.</p> <p>:param x: A PyTorch tensor. :param dim: The position at which to add the singleton dimension. Zero-based indexing. :return: A new tensor with an additional singleton dimension.</p> Source code in <code>src/pydvl/influence/torch/torch_differentiable.py</code> <pre><code>@staticmethod\ndef unsqueeze(x: torch.Tensor, dim: int) -&gt; torch.Tensor:\n\"\"\"\n    Add a singleton dimension at a specified position in a tensor.\n    :param x: A PyTorch tensor.\n    :param dim: The position at which to add the singleton dimension. Zero-based indexing.\n    :return: A new tensor with an additional singleton dimension.\n    \"\"\"\nreturn x.unsqueeze(dim)\n</code></pre>"},{"location":"code-reference/pydvl/influence/torch/torch_differentiable/#pydvl.influence.torch.torch_differentiable.as_tensor","title":"<code>as_tensor(a, warn=True, **kwargs)</code>","text":"<p>Converts an array into a torch tensor</p> <p>:param a: array to convert to tensor :param warn: if True, warns that a will be converted</p> Source code in <code>src/pydvl/influence/torch/util.py</code> <pre><code>def as_tensor(a: Any, warn=True, **kwargs) -&gt; torch.Tensor:\n\"\"\"Converts an array into a torch tensor\n    :param a: array to convert to tensor\n    :param warn: if True, warns that a will be converted\n    \"\"\"\nif warn and not isinstance(a, torch.Tensor):\nlogger.warning(\"Converting tensor to type torch.Tensor.\")\nreturn torch.as_tensor(a, **kwargs)\n</code></pre>"},{"location":"code-reference/pydvl/influence/torch/torch_differentiable/#pydvl.influence.torch.torch_differentiable.lanzcos_low_rank_hessian_approx","title":"<code>lanzcos_low_rank_hessian_approx(hessian_vp, matrix_shape, hessian_perturbation=0.0, rank_estimate=10, krylov_dimension=None, tol=1e-06, max_iter=None, device=None, eigen_computation_on_gpu=False, torch_dtype=None)</code>","text":"<p>Calculates a low-rank approximation of the Hessian matrix of a scalar-valued function using the implicitly restarted Lanczos algorithm.</p> <p>:param hessian_vp: A function that takes a vector and returns the product of     the Hessian of the loss function. :param matrix_shape: The shape of the matrix, represented by hessian vector     product. :param hessian_perturbation: Optional regularization parameter added to the     Hessian-vector product for numerical stability. :param rank_estimate: The number of eigenvalues and corresponding eigenvectors     to compute. Represents the desired rank of the Hessian approximation. :param krylov_dimension: The number of Krylov vectors to use for the Lanczos     method. If not provided, it defaults to     \\(min(model.num_parameters, max(2*rank_estimate + 1, 20))\\). :param tol: The stopping criteria for the Lanczos algorithm, which stops when     the difference in the approximated eigenvalue is less than <code>tol</code>.     Defaults to 1e-6. :param max_iter: The maximum number of iterations for the Lanczos method. If     not provided, it defaults to <code>10 * model.num_parameters</code>. :param device: The device to use for executing the hessian vector product. :param eigen_computation_on_gpu: If <code>True</code>, tries to execute the eigen pair     approximation on the provided device via <code>cupy &lt;https://cupy.dev/&gt;</code>_     implementation. Make sure that either your model is small enough, or you     use a small rank_estimate to fit your device's memory. If <code>False</code>, the     eigen pair approximation is executed on the CPU with scipy's wrapper to     ARPACK. :param torch_dtype: if not provided, current torch default dtype is used for     conversion to torch.</p> <p>:return: An object that contains the top- <code>rank_estimate</code> eigenvalues and     corresponding eigenvectors of the Hessian.</p> Source code in <code>src/pydvl/influence/torch/torch_differentiable.py</code> <pre><code>def lanzcos_low_rank_hessian_approx(\nhessian_vp: Callable[[torch.Tensor], torch.Tensor],\nmatrix_shape: Tuple[int, int],\nhessian_perturbation: float = 0.0,\nrank_estimate: int = 10,\nkrylov_dimension: Optional[int] = None,\ntol: float = 1e-6,\nmax_iter: Optional[int] = None,\ndevice: Optional[torch.device] = None,\neigen_computation_on_gpu: bool = False,\ntorch_dtype: torch.dtype = None,\n) -&gt; LowRankProductRepresentation:\n\"\"\"\n    Calculates a low-rank approximation of the Hessian matrix of a scalar-valued\n    function using the implicitly restarted Lanczos algorithm.\n    :param hessian_vp: A function that takes a vector and returns the product of\n        the Hessian of the loss function.\n    :param matrix_shape: The shape of the matrix, represented by hessian vector\n        product.\n    :param hessian_perturbation: Optional regularization parameter added to the\n        Hessian-vector product for numerical stability.\n    :param rank_estimate: The number of eigenvalues and corresponding eigenvectors\n        to compute. Represents the desired rank of the Hessian approximation.\n    :param krylov_dimension: The number of Krylov vectors to use for the Lanczos\n        method. If not provided, it defaults to\n        $min(model.num_parameters, max(2*rank_estimate + 1, 20))$.\n    :param tol: The stopping criteria for the Lanczos algorithm, which stops when\n        the difference in the approximated eigenvalue is less than ``tol``.\n        Defaults to 1e-6.\n    :param max_iter: The maximum number of iterations for the Lanczos method. If\n        not provided, it defaults to ``10 * model.num_parameters``.\n    :param device: The device to use for executing the hessian vector product.\n    :param eigen_computation_on_gpu: If ``True``, tries to execute the eigen pair\n        approximation on the provided device via `cupy &lt;https://cupy.dev/&gt;`_\n        implementation. Make sure that either your model is small enough, or you\n        use a small rank_estimate to fit your device's memory. If ``False``, the\n        eigen pair approximation is executed on the CPU with scipy's wrapper to\n        ARPACK.\n    :param torch_dtype: if not provided, current torch default dtype is used for\n        conversion to torch.\n    :return: An object that contains the top- ``rank_estimate`` eigenvalues and\n        corresponding eigenvectors of the Hessian.\n    \"\"\"\ntorch_dtype = torch.get_default_dtype() if torch_dtype is None else torch_dtype\nif eigen_computation_on_gpu:\ntry:\nimport cupy as cp\nfrom cupyx.scipy.sparse.linalg import LinearOperator, eigsh\nfrom torch.utils.dlpack import from_dlpack, to_dlpack\nexcept ImportError as e:\nraise ImportError(\nf\"Try to install missing dependencies or set eigen_computation_on_gpu to False: {e}\"\n)\nif device is None:\nraise ValueError(\n\"Without setting an explicit device, cupy is not supported\"\n)\ndef to_torch_conversion_function(x):\nreturn from_dlpack(x.toDlpack()).to(torch_dtype)\ndef mv(x):\nx = to_torch_conversion_function(x)\ny = hessian_vp(x) + hessian_perturbation * x\nreturn cp.from_dlpack(to_dlpack(y))\nelse:\nfrom scipy.sparse.linalg import LinearOperator, eigsh\ndef mv(x):\nx_torch = torch.as_tensor(x, device=device, dtype=torch_dtype)\ny: NDArray = (\n(hessian_vp(x_torch) + hessian_perturbation * x_torch)\n.detach()\n.cpu()\n.numpy()\n)\nreturn y\nto_torch_conversion_function = partial(torch.as_tensor, dtype=torch_dtype)\ntry:\neigen_vals, eigen_vecs = eigsh(\nLinearOperator(matrix_shape, matvec=mv),\nk=rank_estimate,\nmaxiter=max_iter,\ntol=tol,\nncv=krylov_dimension,\nreturn_eigenvectors=True,\n)\nexcept ArpackNoConvergence as e:\nlogger.warning(\nf\"ARPACK did not converge for parameters {max_iter=}, {tol=}, {krylov_dimension=}, \"\nf\"{rank_estimate=}. \\n Returning the best approximation found so far. Use those with care or \"\nf\"modify parameters.\\n Original error: {e}\"\n)\neigen_vals, eigen_vecs = e.eigenvalues, e.eigenvectors\neigen_vals = to_torch_conversion_function(eigen_vals)\neigen_vecs = to_torch_conversion_function(eigen_vecs)\nreturn LowRankProductRepresentation(eigen_vals, eigen_vecs)\n</code></pre>"},{"location":"code-reference/pydvl/influence/torch/torch_differentiable/#pydvl.influence.torch.torch_differentiable.model_hessian_low_rank","title":"<code>model_hessian_low_rank(model, training_data, hessian_perturbation=0.0, rank_estimate=10, krylov_dimension=None, tol=1e-06, max_iter=None, eigen_computation_on_gpu=False)</code>","text":"<p>Calculates a low-rank approximation of the Hessian matrix of the model's loss function using the implicitly restarted Lanczos algorithm.</p> <p>:param model: A PyTorch model instance that is twice differentiable, wrapped into :class:<code>TorchTwiceDifferential</code>.               The Hessian will be calculated with respect to this model's parameters. :param training_data: A DataLoader instance that provides the model's training data.                       Used in calculating the Hessian-vector products. :param hessian_perturbation: Optional regularization parameter added to the Hessian-vector product                              for numerical stability. :param rank_estimate: The number of eigenvalues and corresponding eigenvectors to compute.                       Represents the desired rank of the Hessian approximation. :param krylov_dimension: The number of Krylov vectors to use for the Lanczos method.                          If not provided, it defaults to \\(min(model.num_parameters, max(2*rank_estimate + 1, 20))\\). :param tol: The stopping criteria for the Lanczos algorithm, which stops when the difference             in the approximated eigenvalue is less than <code>tol</code>. Defaults to 1e-6. :param max_iter: The maximum number of iterations for the Lanczos method. If not provided, it defaults to                  \\(10*model.num_parameters\\) :param eigen_computation_on_gpu: If True, tries to execute the eigen pair approximation on the provided                                  device via cupy implementation.                                  Make sure, that either your model is small enough or you use a                                  small rank_estimate to fit your device's memory.                                  If False, the eigen pair approximation is executed on the CPU by scipy wrapper to                                  ARPACK. :return: A <code>LowRankProductRepresentation</code> instance that contains the top (up until rank_estimate) eigenvalues          and corresponding eigenvectors of the Hessian.</p> Source code in <code>src/pydvl/influence/torch/torch_differentiable.py</code> <pre><code>def model_hessian_low_rank(\nmodel: TorchTwiceDifferentiable,\ntraining_data: DataLoader,\nhessian_perturbation: float = 0.0,\nrank_estimate: int = 10,\nkrylov_dimension: Optional[int] = None,\ntol: float = 1e-6,\nmax_iter: Optional[int] = None,\neigen_computation_on_gpu: bool = False,\n) -&gt; LowRankProductRepresentation:\n\"\"\"\n    Calculates a low-rank approximation of the Hessian matrix of the model's loss function using the implicitly\n    restarted Lanczos algorithm.\n    :param model: A PyTorch model instance that is twice differentiable, wrapped into :class:`TorchTwiceDifferential`.\n                  The Hessian will be calculated with respect to this model's parameters.\n    :param training_data: A DataLoader instance that provides the model's training data.\n                          Used in calculating the Hessian-vector products.\n    :param hessian_perturbation: Optional regularization parameter added to the Hessian-vector product\n                                 for numerical stability.\n    :param rank_estimate: The number of eigenvalues and corresponding eigenvectors to compute.\n                          Represents the desired rank of the Hessian approximation.\n    :param krylov_dimension: The number of Krylov vectors to use for the Lanczos method.\n                             If not provided, it defaults to $min(model.num_parameters, max(2*rank_estimate + 1, 20))$.\n    :param tol: The stopping criteria for the Lanczos algorithm, which stops when the difference\n                in the approximated eigenvalue is less than `tol`. Defaults to 1e-6.\n    :param max_iter: The maximum number of iterations for the Lanczos method. If not provided, it defaults to\n                     $10*model.num_parameters$\n    :param eigen_computation_on_gpu: If True, tries to execute the eigen pair approximation on the provided\n                                     device via cupy implementation.\n                                     Make sure, that either your model is small enough or you use a\n                                     small rank_estimate to fit your device's memory.\n                                     If False, the eigen pair approximation is executed on the CPU by scipy wrapper to\n                                     ARPACK.\n    :return: A `LowRankProductRepresentation` instance that contains the top (up until rank_estimate) eigenvalues\n             and corresponding eigenvectors of the Hessian.\n    \"\"\"\nraw_hvp = get_hvp_function(\nmodel.model, model.loss, training_data, use_hessian_avg=True\n)\nreturn lanzcos_low_rank_hessian_approx(\nhessian_vp=raw_hvp,\nmatrix_shape=(model.num_params, model.num_params),\nhessian_perturbation=hessian_perturbation,\nrank_estimate=rank_estimate,\nkrylov_dimension=krylov_dimension,\ntol=tol,\nmax_iter=max_iter,\ndevice=model.device if hasattr(model, \"device\") else None,\neigen_computation_on_gpu=eigen_computation_on_gpu,\n)\n</code></pre>"},{"location":"code-reference/pydvl/influence/torch/torch_differentiable/#pydvl.influence.torch.torch_differentiable.solve_linear","title":"<code>solve_linear(model, training_data, b, hessian_perturbation=0.0)</code>","text":"<p>Given a model and training data, it finds x s.t. \\(Hx = b\\), with \\(H\\) being the model hessian.</p> <p>:param model: A model wrapped in the TwiceDifferentiable interface. :param training_data: A DataLoader containing the training data. :param b: a vector or matrix, the right hand side of the equation \\(Hx = b\\). :param hessian_perturbation: regularization of the hessian</p> <p>:return: An array that solves the inverse problem,     i.e. it returns \\(x\\) such that \\(Hx = b\\), and a dictionary containing     information about the solution.</p> Source code in <code>src/pydvl/influence/torch/torch_differentiable.py</code> <pre><code>@InversionRegistry.register(TorchTwiceDifferentiable, InversionMethod.Direct)\ndef solve_linear(\nmodel: TorchTwiceDifferentiable,\ntraining_data: DataLoader,\nb: torch.Tensor,\nhessian_perturbation: float = 0.0,\n) -&gt; InverseHvpResult:\n\"\"\"Given a model and training data, it finds x s.t. $Hx = b$, with $H$ being\n    the model hessian.\n    :param model: A model wrapped in the TwiceDifferentiable interface.\n    :param training_data: A DataLoader containing the training data.\n    :param b: a vector or matrix, the right hand side of the equation $Hx = b$.\n    :param hessian_perturbation: regularization of the hessian\n    :return: An array that solves the inverse problem,\n        i.e. it returns $x$ such that $Hx = b$, and a dictionary containing\n        information about the solution.\n    \"\"\"\nall_x, all_y = [], []\nfor x, y in training_data:\nall_x.append(x)\nall_y.append(y)\nhessian = model.hessian(torch.cat(all_x), torch.cat(all_y))\nmatrix = hessian + hessian_perturbation * torch.eye(\nmodel.num_params, device=model.device\n)\ninfo = {\"hessian\": hessian}\nreturn InverseHvpResult(x=torch.linalg.solve(matrix, b.T).T, info=info)\n</code></pre>"},{"location":"code-reference/pydvl/influence/torch/torch_differentiable/#pydvl.influence.torch.torch_differentiable.solve_batch_cg","title":"<code>solve_batch_cg(model, training_data, b, hessian_perturbation=0.0, *, x0=None, rtol=1e-07, atol=1e-07, maxiter=None, progress=False)</code>","text":"<p>Given a model and training data, it uses conjugate gradient to calculate the inverse of the Hessian Vector Product. More precisely, it finds x s.t. \\(Hx = b\\), with \\(H\\) being the model hessian. For more info, see <code>Wikipedia &lt;https://en.wikipedia.org/wiki/Conjugate_gradient_method&gt;</code>_</p> <p>:param model: A model wrapped in the TwiceDifferentiable interface. :param training_data: A DataLoader containing the training data. :param b: a vector or matrix, the right hand side of the equation \\(Hx = b\\). :param hessian_perturbation: regularization of the hessian :param x0: initial guess for hvp. If None, defaults to b :param rtol: maximum relative tolerance of result :param atol: absolute tolerance of result :param maxiter: maximum number of iterations. If None, defaults to 10*len(b) :param progress: If True, display progress bars.</p> <p>:return: A matrix of shape [NxP] with each line being a solution of \\(Ax=b\\),     and a dictionary containing information about the convergence of CG, one     entry for each line of the matrix.</p> Source code in <code>src/pydvl/influence/torch/torch_differentiable.py</code> <pre><code>@InversionRegistry.register(TorchTwiceDifferentiable, InversionMethod.Cg)\ndef solve_batch_cg(\nmodel: TorchTwiceDifferentiable,\ntraining_data: DataLoader,\nb: torch.Tensor,\nhessian_perturbation: float = 0.0,\n*,\nx0: Optional[torch.Tensor] = None,\nrtol: float = 1e-7,\natol: float = 1e-7,\nmaxiter: Optional[int] = None,\nprogress: bool = False,\n) -&gt; InverseHvpResult:\n\"\"\"\n    Given a model and training data, it uses conjugate gradient to calculate the\n    inverse of the Hessian Vector Product. More precisely, it finds x s.t. $Hx =\n    b$, with $H$ being the model hessian. For more info, see\n    `Wikipedia &lt;https://en.wikipedia.org/wiki/Conjugate_gradient_method&gt;`_\n    :param model: A model wrapped in the TwiceDifferentiable interface.\n    :param training_data: A DataLoader containing the training data.\n    :param b: a vector or matrix, the right hand side of the equation $Hx = b$.\n    :param hessian_perturbation: regularization of the hessian\n    :param x0: initial guess for hvp. If None, defaults to b\n    :param rtol: maximum relative tolerance of result\n    :param atol: absolute tolerance of result\n    :param maxiter: maximum number of iterations. If None, defaults to 10*len(b)\n    :param progress: If True, display progress bars.\n    :return: A matrix of shape [NxP] with each line being a solution of $Ax=b$,\n        and a dictionary containing information about the convergence of CG, one\n        entry for each line of the matrix.\n    \"\"\"\ntotal_grad_xy = 0\ntotal_points = 0\nfor x, y in maybe_progress(training_data, progress, desc=\"Batch Train Gradients\"):\ngrad_xy = model.grad(x, y, create_graph=True)\ntotal_grad_xy += grad_xy * len(x)\ntotal_points += len(x)\nbackprop_on = model.parameters\nreg_hvp = lambda v: model.mvp(\ntotal_grad_xy / total_points, v, backprop_on\n) + hessian_perturbation * v.type(torch.float64)\nbatch_cg = torch.zeros_like(b)\ninfo = {}\nfor idx, bi in enumerate(maybe_progress(b, progress, desc=\"Conjugate gradient\")):\nbatch_result, batch_info = solve_cg(\nreg_hvp, bi, x0=x0, rtol=rtol, atol=atol, maxiter=maxiter\n)\nbatch_cg[idx] = batch_result\ninfo[f\"batch_{idx}\"] = batch_info\nreturn InverseHvpResult(x=batch_cg, info=info)\n</code></pre>"},{"location":"code-reference/pydvl/influence/torch/torch_differentiable/#pydvl.influence.torch.torch_differentiable.solve_cg","title":"<code>solve_cg(hvp, b, *, x0=None, rtol=1e-07, atol=1e-07, maxiter=None)</code>","text":"<p>Conjugate gradient solver for the Hessian vector product</p> <p>:param hvp: a Callable Hvp, operating with tensors of size N :param b: a vector or matrix, the right hand side of the equation \\(Hx = b\\). :param x0: initial guess for hvp :param rtol: maximum relative tolerance of result :param atol: absolute tolerance of result :param maxiter: maximum number of iterations. If None, defaults to 10*len(b)</p> <p>:return: A vector x, solution of \\(Ax=b\\), and a dictionary containing     information about the convergence of CG.</p> Source code in <code>src/pydvl/influence/torch/torch_differentiable.py</code> <pre><code>def solve_cg(\nhvp: Callable[[torch.Tensor], torch.Tensor],\nb: torch.Tensor,\n*,\nx0: Optional[torch.Tensor] = None,\nrtol: float = 1e-7,\natol: float = 1e-7,\nmaxiter: Optional[int] = None,\n) -&gt; InverseHvpResult:\n\"\"\"Conjugate gradient solver for the Hessian vector product\n    :param hvp: a Callable Hvp, operating with tensors of size N\n    :param b: a vector or matrix, the right hand side of the equation $Hx = b$.\n    :param x0: initial guess for hvp\n    :param rtol: maximum relative tolerance of result\n    :param atol: absolute tolerance of result\n    :param maxiter: maximum number of iterations. If None, defaults to 10*len(b)\n    :return: A vector x, solution of $Ax=b$, and a dictionary containing\n        information about the convergence of CG.\n    \"\"\"\nif x0 is None:\nx0 = torch.clone(b)\nif maxiter is None:\nmaxiter = len(b) * 10\ny_norm = torch.sum(torch.matmul(b, b)).item()\nstopping_val = max([rtol**2 * y_norm, atol**2])\nx = x0\np = r = (b - hvp(x)).squeeze().type(torch.float64)\ngamma = torch.sum(torch.matmul(r, r)).item()\noptimal = False\nfor k in range(maxiter):\nif gamma &lt; stopping_val:\noptimal = True\nbreak\nAp = hvp(p).squeeze()\nalpha = gamma / torch.sum(torch.matmul(p, Ap)).item()\nx += alpha * p\nr -= alpha * Ap\ngamma_ = torch.sum(torch.matmul(r, r)).item()\nbeta = gamma_ / gamma\ngamma = gamma_\np = r + beta * p\ninfo = {\"niter\": k, \"optimal\": optimal, \"gamma\": gamma}\nreturn InverseHvpResult(x=x, info=info)\n</code></pre>"},{"location":"code-reference/pydvl/influence/torch/torch_differentiable/#pydvl.influence.torch.torch_differentiable.solve_lissa","title":"<code>solve_lissa(model, training_data, b, hessian_perturbation=0.0, *, maxiter=1000, dampen=0.0, scale=10.0, h0=None, rtol=0.0001, progress=False)</code>","text":"<p>Uses LISSA, Linear time Stochastic Second-Order Algorithm, to iteratively approximate the inverse Hessian. More precisely, it finds x s.t. \\(Hx = b\\), with \\(H\\) being the model's second derivative wrt. the parameters. This is done with the update</p> \\[H^{-1}_{j+1} b = b + (I - d) \\ H - \\frac{H^{-1}_j b}{s},\\] <p>where \\(I\\) is the identity matrix, \\(d\\) is a dampening term and \\(s\\) a scaling factor that are applied to help convergence. For details, see :footcite:t:<code>koh_understanding_2017</code> and the original paper :footcite:t:<code>agarwal_2017_second</code>.</p> <p>:param model: A model wrapped in the TwiceDifferentiable interface. :param training_data: A DataLoader containing the training data. :param b: a vector or matrix, the right hand side of the equation \\(Hx = b\\). :param hessian_perturbation: regularization of the hessian :param progress: If True, display progress bars. :param maxiter: maximum number of iterations, :param dampen: dampening factor, defaults to 0 for no dampening :param scale: scaling factor, defaults to 10 :param h0: initial guess for hvp</p> <p>:return: A matrix of shape [NxP] with each line being a solution of \\(Ax=b\\),     and a dictionary containing information about the accuracy of the solution.</p> Source code in <code>src/pydvl/influence/torch/torch_differentiable.py</code> <pre><code>@InversionRegistry.register(TorchTwiceDifferentiable, InversionMethod.Lissa)\ndef solve_lissa(\nmodel: TorchTwiceDifferentiable,\ntraining_data: DataLoader,\nb: torch.Tensor,\nhessian_perturbation: float = 0.0,\n*,\nmaxiter: int = 1000,\ndampen: float = 0.0,\nscale: float = 10.0,\nh0: Optional[torch.Tensor] = None,\nrtol: float = 1e-4,\nprogress: bool = False,\n) -&gt; InverseHvpResult:\nr\"\"\"\n    Uses LISSA, Linear time Stochastic Second-Order Algorithm, to iteratively\n    approximate the inverse Hessian. More precisely, it finds x s.t. $Hx = b$,\n    with $H$ being the model's second derivative wrt. the parameters.\n    This is done with the update\n    $$H^{-1}_{j+1} b = b + (I - d) \\ H - \\frac{H^{-1}_j b}{s},$$\n    where $I$ is the identity matrix, $d$ is a dampening term and $s$ a scaling\n    factor that are applied to help convergence. For details, see\n    :footcite:t:`koh_understanding_2017` and the original paper\n    :footcite:t:`agarwal_2017_second`.\n    :param model: A model wrapped in the TwiceDifferentiable interface.\n    :param training_data: A DataLoader containing the training data.\n    :param b: a vector or matrix, the right hand side of the equation $Hx = b$.\n    :param hessian_perturbation: regularization of the hessian\n    :param progress: If True, display progress bars.\n    :param maxiter: maximum number of iterations,\n    :param dampen: dampening factor, defaults to 0 for no dampening\n    :param scale: scaling factor, defaults to 10\n    :param h0: initial guess for hvp\n    :return: A matrix of shape [NxP] with each line being a solution of $Ax=b$,\n        and a dictionary containing information about the accuracy of the solution.\n    \"\"\"\nif h0 is None:\nh_estimate = torch.clone(b)\nelse:\nh_estimate = h0\nshuffled_training_data = DataLoader(\ntraining_data.dataset, training_data.batch_size, shuffle=True\n)\ndef lissa_step(\nh: torch.Tensor, reg_hvp: Callable[[torch.Tensor], torch.Tensor]\n) -&gt; torch.Tensor:\n\"\"\"Given an estimate of the hessian inverse and the regularised hessian\n        vector product, it computes the next estimate.\n        :param h: an estimate of the hessian inverse\n        :param reg_hvp: regularised hessian vector product\n        :return: the next estimate of the hessian inverse\n        \"\"\"\nreturn b + (1 - dampen) * h - reg_hvp(h) / scale\nfor _ in maybe_progress(range(maxiter), progress, desc=\"Lissa\"):\nx, y = next(iter(shuffled_training_data))\ngrad_xy = model.grad(x, y, create_graph=True)\nreg_hvp = (\nlambda v: model.mvp(grad_xy, v, model.parameters) + hessian_perturbation * v\n)\nresidual = lissa_step(h_estimate, reg_hvp) - h_estimate\nh_estimate += residual\nif torch.isnan(h_estimate).any():\nraise RuntimeError(\"NaNs in h_estimate. Increase scale or dampening.\")\nmax_residual = torch.max(torch.abs(residual / h_estimate))\nif max_residual &lt; rtol:\nbreak\nmean_residual = torch.mean(torch.abs(residual / h_estimate))\nlogger.info(\nf\"Terminated Lissa with {max_residual*100:.2f} % max residual.\"\nf\" Mean residual: {mean_residual*100:.5f} %\"\n)\ninfo = {\n\"max_perc_residual\": max_residual * 100,\n\"mean_perc_residual\": mean_residual * 100,\n}\nreturn InverseHvpResult(x=h_estimate / scale, info=info)\n</code></pre>"},{"location":"code-reference/pydvl/influence/torch/torch_differentiable/#pydvl.influence.torch.torch_differentiable.solve_arnoldi","title":"<code>solve_arnoldi(model, training_data, b, hessian_perturbation=0.0, *, rank_estimate=10, krylov_dimension=None, low_rank_representation=None, tol=1e-06, max_iter=None, eigen_computation_on_gpu=False)</code>","text":"<p>Solves the linear system Hx = b, where H is the Hessian of the model's loss function and b is the given right-hand side vector. The Hessian is approximated using a low-rank representation.</p> <p>:param model: A PyTorch model instance that is twice differentiable, wrapped into :class:<code>TorchTwiceDifferential</code>.               The Hessian will be calculated with respect to this model's parameters. :param training_data: A DataLoader instance that provides the model's training data.                       Used in calculating the Hessian-vector products. :param b: The right-hand side vector in the system Hx = b. :param hessian_perturbation: Optional regularization parameter added to the Hessian-vector product                              for numerical stability. :param rank_estimate: The number of eigenvalues and corresponding eigenvectors to compute.                       Represents the desired rank of the Hessian approximation. :param krylov_dimension: The number of Krylov vectors to use for the Lanczos method.                          If not provided, it defaults to \\(min(model.num_parameters, max(2*rank_estimate + 1, 20))\\). :param low_rank_representation: A LowRankProductRepresentation instance containing a previously computed                                 low-rank representation of the Hessian. I provided, all other parameters                                 are ignored, if not, a new low-rank representation will be computed,                                 using provided parameters. :param tol: The stopping criteria for the Lanczos algorithm.             If <code>low_rank_representation</code> is provided, this parameter is ignored. :param max_iter: The maximum number of iterations for the Lanczos method.                  If <code>low_rank_representation</code> is provided, this parameter is ignored. :param eigen_computation_on_gpu: If True, tries to execute the eigen pair approximation on the model's                                  device via cupy implementation.                                  Make sure, that either your model is small enough or you use a                                  small rank_estimate to fit your device's memory.                                  If False, the eigen pair approximation is executed on the CPU by scipy wrapper to                                  ARPACK. :return: Returns the solution vector x that satisfies the system Hx = b,          where H is a low-rank approximation of the Hessian of the model's loss function.</p> Source code in <code>src/pydvl/influence/torch/torch_differentiable.py</code> <pre><code>@InversionRegistry.register(TorchTwiceDifferentiable, InversionMethod.Arnoldi)\ndef solve_arnoldi(\nmodel: TorchTwiceDifferentiable,\ntraining_data: DataLoader,\nb: torch.Tensor,\nhessian_perturbation: float = 0.0,\n*,\nrank_estimate: int = 10,\nkrylov_dimension: Optional[int] = None,\nlow_rank_representation: Optional[LowRankProductRepresentation] = None,\ntol: float = 1e-6,\nmax_iter: Optional[int] = None,\neigen_computation_on_gpu: bool = False,\n) -&gt; InverseHvpResult:\n\"\"\"\n    Solves the linear system Hx = b, where H is the Hessian of the model's loss function and b is the given right-hand\n    side vector. The Hessian is approximated using a low-rank representation.\n    :param model: A PyTorch model instance that is twice differentiable, wrapped into :class:`TorchTwiceDifferential`.\n                  The Hessian will be calculated with respect to this model's parameters.\n    :param training_data: A DataLoader instance that provides the model's training data.\n                          Used in calculating the Hessian-vector products.\n    :param b: The right-hand side vector in the system Hx = b.\n    :param hessian_perturbation: Optional regularization parameter added to the Hessian-vector product\n                                 for numerical stability.\n    :param rank_estimate: The number of eigenvalues and corresponding eigenvectors to compute.\n                          Represents the desired rank of the Hessian approximation.\n    :param krylov_dimension: The number of Krylov vectors to use for the Lanczos method.\n                             If not provided, it defaults to $min(model.num_parameters, max(2*rank_estimate + 1, 20))$.\n    :param low_rank_representation: A LowRankProductRepresentation instance containing a previously computed\n                                    low-rank representation of the Hessian. I provided, all other parameters\n                                    are ignored, if not, a new low-rank representation will be computed,\n                                    using provided parameters.\n    :param tol: The stopping criteria for the Lanczos algorithm.\n                If `low_rank_representation` is provided, this parameter is ignored.\n    :param max_iter: The maximum number of iterations for the Lanczos method.\n                     If `low_rank_representation` is provided, this parameter is ignored.\n    :param eigen_computation_on_gpu: If True, tries to execute the eigen pair approximation on the model's\n                                     device via cupy implementation.\n                                     Make sure, that either your model is small enough or you use a\n                                     small rank_estimate to fit your device's memory.\n                                     If False, the eigen pair approximation is executed on the CPU by scipy wrapper to\n                                     ARPACK.\n    :return: Returns the solution vector x that satisfies the system Hx = b,\n             where H is a low-rank approximation of the Hessian of the model's loss function.\n    \"\"\"\nb_device = b.device if hasattr(b, \"device\") else torch.device(\"cpu\")\nif low_rank_representation is None:\nif b_device.type == \"cuda\" and not eigen_computation_on_gpu:\nraise ValueError(\n\"Using 'eigen_computation_on_gpu=False' while 'b' is on a 'cuda' device is not supported. \"\n\"To address this, consider the following options:\\n\"\n\" - Set eigen_computation_on_gpu=True if your model and data are small enough \"\n\"and if 'cupy' is available in your environment.\\n\"\n\" - Move 'b' to the CPU with b.to('cpu').\\n\"\n\" - Precompute a low rank representation and move it to the 'b' device using:\\n\"\n\"     low_rank_representation = model_hessian_low_rank(model, training_data, ..., \"\n\"eigen_computation_on_gpu=False).to(b.device)\"\n)\nlow_rank_representation = model_hessian_low_rank(\nmodel,\ntraining_data,\nhessian_perturbation=hessian_perturbation,\nrank_estimate=rank_estimate,\nkrylov_dimension=krylov_dimension,\ntol=tol,\nmax_iter=max_iter,\neigen_computation_on_gpu=eigen_computation_on_gpu,\n)\nelse:\nif b_device.type != low_rank_representation.device.type:\nraise RuntimeError(\nf\"The devices for 'b' and 'low_rank_representation' do not match.\\n\"\nf\" - 'b' is on device: {b_device}\\n\"\nf\" - 'low_rank_representation' is on device: {low_rank_representation.device}\\n\"\nf\"\\nTo resolve this, consider moving 'low_rank_representation' to '{b_device}' by using:\\n\"\nf\"low_rank_representation = low_rank_representation.to(b.device)\"\n)\nlogger.info(\"Using provided low rank representation, ignoring other parameters\")\nresult = low_rank_representation.projections @ (\ntorch.diag_embed(1.0 / low_rank_representation.eigen_vals)\n@ (low_rank_representation.projections.t() @ b.t())\n)\nreturn InverseHvpResult(\nx=result.t(),\ninfo={\n\"eigenvalues\": low_rank_representation.eigen_vals,\n\"eigenvectors\": low_rank_representation.projections,\n},\n)\n</code></pre>"},{"location":"code-reference/pydvl/influence/torch/util/","title":"util","text":""},{"location":"code-reference/pydvl/influence/torch/util/#pydvl.influence.torch.util.to_model_device","title":"<code>to_model_device(x, model)</code>","text":"<p>Returns the tensor <code>x</code> moved to the device of the <code>model</code>, if device of model is set</p> Source code in <code>src/pydvl/influence/torch/util.py</code> <pre><code>def to_model_device(x: torch.Tensor, model: torch.nn.Module) -&gt; torch.Tensor:\n\"\"\"\n    Returns the tensor `x` moved to the device of the `model`, if device of model is set\n    \"\"\"\nif hasattr(model, \"device\"):\nreturn x.to(model.device)\nreturn x\n</code></pre>"},{"location":"code-reference/pydvl/influence/torch/util/#pydvl.influence.torch.util.flatten_tensors_to_vector","title":"<code>flatten_tensors_to_vector(tensors)</code>","text":"<p>Flatten multiple tensors into a single 1D tensor (vector).</p> <p>The function takes an iterable of tensors and reshapes each of them into a 1D tensor. These reshaped tensors are then concatenated together into a single 1D tensor in the order they were given.</p> <p>:param tensors: An iterable of tensors to be reshaped and concatenated. :return: A 1D tensor that is the concatenation of all the reshaped input tensors.</p> Source code in <code>src/pydvl/influence/torch/util.py</code> <pre><code>def flatten_tensors_to_vector(tensors: Iterable[torch.Tensor]) -&gt; torch.Tensor:\n\"\"\"\n    Flatten multiple tensors into a single 1D tensor (vector).\n    The function takes an iterable of tensors and reshapes each of them into a 1D tensor.\n    These reshaped tensors are then concatenated together into a single 1D tensor in the order they were given.\n    :param tensors: An iterable of tensors to be reshaped and concatenated.\n    :return: A 1D tensor that is the concatenation of all the reshaped input tensors.\n    \"\"\"\nreturn torch.cat([t.contiguous().view(-1) for t in tensors])\n</code></pre>"},{"location":"code-reference/pydvl/influence/torch/util/#pydvl.influence.torch.util.reshape_vector_to_tensors","title":"<code>reshape_vector_to_tensors(input_vector, target_shapes)</code>","text":"<p>Reshape a 1D tensor into multiple tensors with specified shapes.</p> <p>The function takes a 1D tensor (input_vector) and reshapes it into a series of tensors with shapes given by 'target_shapes'. The reshaped tensors are returned as a tuple in the same order as their corresponding shapes.</p> <p>Note: The total number of elements in 'input_vector' must be equal to the sum of the products of the shapes in 'target_shapes'.</p> <p>:param input_vector: The 1D tensor to be reshaped. Must be 1D. :param target_shapes: An iterable of tuples. Each tuple defines the shape of a tensor to be        reshaped from the 'input_vector'. :return: A tuple of reshaped tensors. :raises:     ValueError: If 'input_vector' is not a 1D tensor or if the total number of elements         in 'input_vector' does not match the sum of the products of the shapes in 'target_shapes'.</p> Source code in <code>src/pydvl/influence/torch/util.py</code> <pre><code>def reshape_vector_to_tensors(\ninput_vector: torch.Tensor, target_shapes: Iterable[Tuple[int, ...]]\n) -&gt; Tuple[torch.Tensor, ...]:\n\"\"\"\n    Reshape a 1D tensor into multiple tensors with specified shapes.\n    The function takes a 1D tensor (input_vector) and reshapes it into a series of tensors with shapes given by 'target_shapes'.\n    The reshaped tensors are returned as a tuple in the same order as their corresponding shapes.\n    Note: The total number of elements in 'input_vector' must be equal to the sum of the products of the shapes in 'target_shapes'.\n    :param input_vector: The 1D tensor to be reshaped. Must be 1D.\n    :param target_shapes: An iterable of tuples. Each tuple defines the shape of a tensor to be\n           reshaped from the 'input_vector'.\n    :return: A tuple of reshaped tensors.\n    :raises:\n        ValueError: If 'input_vector' is not a 1D tensor or if the total number of elements\n            in 'input_vector' does not match the sum of the products of the shapes in 'target_shapes'.\n    \"\"\"\nif input_vector.dim() != 1:\nraise ValueError(\"Input vector must be a 1D tensor\")\ntotal_elements = sum(math.prod(shape) for shape in target_shapes)\nif total_elements != input_vector.shape[0]:\nraise ValueError(\nf\"The total elements in shapes {total_elements} does not match the vector length {input_vector.shape[0]}\"\n)\ntensors = []\nstart = 0\nfor shape in target_shapes:\nsize = math.prod(shape)  # compute the total size of the tensor with this shape\ntensors.append(\ninput_vector[start : start + size].view(shape)\n)  # slice the vector and reshape it\nstart += size\nreturn tuple(tensors)\n</code></pre>"},{"location":"code-reference/pydvl/influence/torch/util/#pydvl.influence.torch.util.align_structure","title":"<code>align_structure(source, target)</code>","text":"<p>This function transforms <code>target</code> to have the same structure as <code>source</code>, i.e., it should be a dictionary with the same keys as <code>source</code> and each corresponding value in <code>target</code> should have the same shape as the value in <code>source</code>.</p> <p>:param source: The reference dictionary containing PyTorch tensors. :param target: The input to be harmonized. It can be a dictionary, tuple, or tensor.</p> <p>:return: The harmonized version of <code>target</code>.</p> <p>:raises ValueError: If <code>target</code> cannot be harmonized to match <code>source</code>.</p> Source code in <code>src/pydvl/influence/torch/util.py</code> <pre><code>def align_structure(\nsource: Dict[str, torch.Tensor],\ntarget: TorchTensorContainerType,\n) -&gt; Dict[str, torch.Tensor]:\n\"\"\"\n    This function transforms `target` to have the same structure as `source`, i.e.,\n    it should be a dictionary with the same keys as `source` and each corresponding\n    value in `target` should have the same shape as the value in `source`.\n    :param source: The reference dictionary containing PyTorch tensors.\n    :param target: The input to be harmonized. It can be a dictionary, tuple, or tensor.\n    :return: The harmonized version of `target`.\n    :raises ValueError: If `target` cannot be harmonized to match `source`.\n    \"\"\"\ntangent_dict: Dict[str, torch.Tensor]\nif isinstance(target, dict):\nif list(target.keys()) != list(source.keys()):\nraise ValueError(\"The keys in 'target' do not match the keys in 'source'.\")\nif [v.shape for v in target.values()] != [v.shape for v in source.values()]:\nraise ValueError(\n\"The shapes of the values in 'target' do not match the shapes of the values in 'source'.\"\n)\ntangent_dict = target\nelif isinstance(target, tuple) or isinstance(target, list):\nif [v.shape for v in target] != [v.shape for v in source.values()]:\nraise ValueError(\n\"'target' is a tuple/list but its elements' shapes do not match the shapes \"\n\"of the values in 'source'.\"\n)\ntangent_dict = dict(zip(source.keys(), target))\nelif isinstance(target, torch.Tensor):\ntry:\ntangent_dict = dict(\nzip(\nsource.keys(),\nreshape_vector_to_tensors(\ntarget, [p.shape for p in source.values()]\n),\n)\n)\nexcept Exception as e:\nraise ValueError(\nf\"'target' is a tensor but cannot be reshaped to match 'source'. Original error: {e}\"\n)\nelse:\nraise ValueError(f\"'target' is of type {type(target)} which is not supported.\")\nreturn tangent_dict\n</code></pre>"},{"location":"code-reference/pydvl/influence/torch/util/#pydvl.influence.torch.util.as_tensor","title":"<code>as_tensor(a, warn=True, **kwargs)</code>","text":"<p>Converts an array into a torch tensor</p> <p>:param a: array to convert to tensor :param warn: if True, warns that a will be converted</p> Source code in <code>src/pydvl/influence/torch/util.py</code> <pre><code>def as_tensor(a: Any, warn=True, **kwargs) -&gt; torch.Tensor:\n\"\"\"Converts an array into a torch tensor\n    :param a: array to convert to tensor\n    :param warn: if True, warns that a will be converted\n    \"\"\"\nif warn and not isinstance(a, torch.Tensor):\nlogger.warning(\"Converting tensor to type torch.Tensor.\")\nreturn torch.as_tensor(a, **kwargs)\n</code></pre>"},{"location":"code-reference/pydvl/reporting/","title":"reporting","text":""},{"location":"code-reference/pydvl/reporting/plots/","title":"plots","text":""},{"location":"code-reference/pydvl/reporting/plots/#pydvl.reporting.plots.shaded_mean_std","title":"<code>shaded_mean_std(data, abscissa=None, num_std=1.0, mean_color='dodgerblue', shade_color='lightblue', title=None, xlabel=None, ylabel=None, ax=None, **kwargs)</code>","text":"<p>The usual mean +- std deviation plot to aggregate runs of experiments.</p> PARAMETER  DESCRIPTION <code>data</code> <p>axis 0 is to be aggregated on (e.g. runs) and axis 1 is the data for each run.</p> <p> TYPE: <code>ndarray</code> </p> <code>abscissa</code> <p>values for the x axis. Leave empty to use increasing integers.</p> <p> TYPE: <code>Optional[Sequence[Any]]</code> DEFAULT: <code>None</code> </p> <code>num_std</code> <p>number of standard deviations to shade around the mean.</p> <p> TYPE: <code>float</code> DEFAULT: <code>1.0</code> </p> <code>mean_color</code> <p>color for the mean</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>'dodgerblue'</code> </p> <code>shade_color</code> <p>color for the shaded region</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>'lightblue'</code> </p> <code>title</code> <p>Title text. To use mathematics, use LaTeX notation.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>xlabel</code> <p>Text for the horizontal axis.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>ylabel</code> <p>Text for the vertical axis</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>ax</code> <p>If passed, axes object into which to insert the figure. Otherwise, a new figure is created and returned</p> <p> TYPE: <code>Optional[Axes]</code> DEFAULT: <code>None</code> </p> <code>kwargs</code> <p>these are forwarded to the ax.plot() call for the mean.</p> <p> TYPE: <code>dict</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>Axes</code> <p>The axes used (or created)</p> Source code in <code>src/pydvl/reporting/plots.py</code> <pre><code>def shaded_mean_std(\ndata: np.ndarray,\nabscissa: Optional[Sequence[Any]] = None,\nnum_std: float = 1.0,\nmean_color: Optional[str] = \"dodgerblue\",\nshade_color: Optional[str] = \"lightblue\",\ntitle: Optional[str] = None,\nxlabel: Optional[str] = None,\nylabel: Optional[str] = None,\nax: Optional[Axes] = None,\n**kwargs: dict,\n) -&gt; Axes:\n\"\"\"The usual mean +- std deviation plot to aggregate runs of experiments.\n    Args:\n        data: axis 0 is to be aggregated on (e.g. runs) and axis 1 is the\n            data for each run.\n        abscissa: values for the x axis. Leave empty to use increasing integers.\n        num_std: number of standard deviations to shade around the mean.\n        mean_color: color for the mean\n        shade_color: color for the shaded region\n        title: Title text. To use mathematics, use LaTeX notation.\n        xlabel: Text for the horizontal axis.\n        ylabel: Text for the vertical axis\n        ax: If passed, axes object into which to insert the figure. Otherwise,\n            a new figure is created and returned\n        kwargs: these are forwarded to the ax.plot() call for the mean.\n    Returns:\n        The axes used (or created)\n    \"\"\"\nassert len(data.shape) == 2\nmean = data.mean(axis=0)\nstd = num_std * data.std(axis=0)\nif ax is None:\nfig, ax = plt.subplots()\nif abscissa is None:\nabscissa = list(range(data.shape[1]))\nax.fill_between(abscissa, mean - std, mean + std, alpha=0.3, color=shade_color)\nax.plot(abscissa, mean, color=mean_color, **kwargs)\nax.set_title(title)\nax.set_xlabel(xlabel)\nax.set_ylabel(ylabel)\nreturn ax\n</code></pre>"},{"location":"code-reference/pydvl/reporting/plots/#pydvl.reporting.plots.spearman_correlation","title":"<code>spearman_correlation(vv, num_values, pvalue)</code>","text":"<p>Simple matrix plots with spearman correlation for each pair in vv.</p> PARAMETER  DESCRIPTION <code>vv</code> <p>list of OrderedDicts with index: value. Spearman correlation is computed for the keys.</p> <p> TYPE: <code>List[OrderedDict]</code> </p> <code>num_values</code> <p>Use only these many values from the data (from the start of the OrderedDicts)</p> <p> TYPE: <code>int</code> </p> <code>pvalue</code> <p>correlation coefficients for which the p-value is below the threshold <code>pvalue/len(vv)</code> will be discarded.</p> <p> TYPE: <code>float</code> </p> Source code in <code>src/pydvl/reporting/plots.py</code> <pre><code>def spearman_correlation(vv: List[OrderedDict], num_values: int, pvalue: float):\n\"\"\"Simple matrix plots with spearman correlation for each pair in vv.\n    Args:\n        vv: list of OrderedDicts with index: value. Spearman correlation\n            is computed for the keys.\n        num_values: Use only these many values from the data (from the start\n            of the OrderedDicts)\n        pvalue: correlation coefficients for which the p-value is below the\n            threshold `pvalue/len(vv)` will be discarded.\n    \"\"\"\nr: np.ndarray = np.ndarray((len(vv), len(vv)))\np: np.ndarray = np.ndarray((len(vv), len(vv)))\nfor i, a in enumerate(vv):\nfor j, b in enumerate(vv):\nfrom scipy.stats._stats_py import SpearmanrResult\nspearman: SpearmanrResult = sp.stats.spearmanr(\nlist(a.keys())[:num_values], list(b.keys())[:num_values]\n)\nr[i][j] = (\nspearman.correlation if spearman.pvalue &lt; pvalue / len(vv) else np.nan\n)  # Bonferroni correction\np[i][j] = spearman.pvalue\nfig, axs = plt.subplots(1, 2, figsize=(16, 7))\nplot1 = axs[0].matshow(r, vmin=-1, vmax=1)\naxs[0].set_title(f\"Spearman correlation (top {num_values} values)\")\naxs[0].set_xlabel(\"Runs\")\naxs[0].set_ylabel(\"Runs\")\nfig.colorbar(plot1, ax=axs[0])\nplot2 = axs[1].matshow(p, vmin=0, vmax=1)\naxs[1].set_title(\"p-value\")\naxs[1].set_xlabel(\"Runs\")\naxs[1].set_ylabel(\"Runs\")\nfig.colorbar(plot2, ax=axs[1])\nreturn fig\n</code></pre>"},{"location":"code-reference/pydvl/reporting/plots/#pydvl.reporting.plots.plot_shapley","title":"<code>plot_shapley(df, *, level=0.05, ax=None, title=None, xlabel=None, ylabel=None)</code>","text":"<p>Plots the shapley values, as returned from compute_shapley_values(), with error bars corresponding to an \\(\u0007lpha\\)-level confidence interval.</p> PARAMETER  DESCRIPTION <code>df</code> <p>dataframe with the shapley values</p> <p> TYPE: <code>DataFrame</code> </p> <code>level</code> <p>confidence level for the error bars</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.05</code> </p> <code>ax</code> <p>axes to plot on or None if a new subplots should be created</p> <p> TYPE: <code>Axes</code> DEFAULT: <code>None</code> </p> <code>title</code> <p>string, title of the plot</p> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> <code>xlabel</code> <p>string, x label of the plot</p> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> <code>ylabel</code> <p>string, y label of the plot</p> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Axes</code> <p>The axes created or used</p> Source code in <code>src/pydvl/reporting/plots.py</code> <pre><code>def plot_shapley(\ndf: pd.DataFrame,\n*,\nlevel: float = 0.05,\nax: plt.Axes = None,\ntitle: str = None,\nxlabel: str = None,\nylabel: str = None,\n) -&gt; plt.Axes:\n\"\"\"Plots the shapley values, as returned from\n    [compute_shapley_values()][pydvl.value.shapley.common.compute_shapley_values], with error bars\n    corresponding to an $\\alpha$-level confidence interval.\n    Args:\n        df: dataframe with the shapley values\n        level: confidence level for the error bars\n        ax: axes to plot on or None if a new subplots should be created\n        title: string, title of the plot\n        xlabel: string, x label of the plot\n        ylabel: string, y label of the plot\n    Returns:\n        The axes created or used\n    \"\"\"\nif ax is None:\n_, ax = plt.subplots()\nyerr = norm.ppf(1 - level / 2) * df[\"data_value_stderr\"]\nax.errorbar(x=df.index, y=df[\"data_value\"], yerr=yerr, fmt=\"o\", capsize=6)\nax.set_xlabel(xlabel)\nax.set_ylabel(ylabel)\nax.set_title(title)\nplt.xticks(rotation=60)\nreturn ax\n</code></pre>"},{"location":"code-reference/pydvl/reporting/plots/#pydvl.reporting.plots.plot_influence_distribution_by_label","title":"<code>plot_influence_distribution_by_label(influences, labels, title_extra='')</code>","text":"<p>Plots the histogram of the influence that all samples in the training set have over a single sample index, separated by labels.</p> <p>influences: array of influences (training samples x test samples)    labels: labels for the training set.    title_extra:</p> Source code in <code>src/pydvl/reporting/plots.py</code> <pre><code>def plot_influence_distribution_by_label(\ninfluences: NDArray[np.float_], labels: NDArray[np.float_], title_extra: str = \"\"\n):\n\"\"\"Plots the histogram of the influence that all samples in the training set\n    have over a single sample index, separated by labels.\n       influences: array of influences (training samples x test samples)\n       labels: labels for the training set.\n       title_extra:\n    \"\"\"\n_, ax = plt.subplots()\nunique_labels = np.unique(labels)\nfor label in unique_labels:\nax.hist(influences[labels == label], label=label, alpha=0.7)\nax.set_xlabel(\"Influence values\")\nax.set_ylabel(\"Number of samples\")\nax.set_title(f\"Distribution of influences \" + title_extra)\nax.legend()\nplt.show()\n</code></pre>"},{"location":"code-reference/pydvl/reporting/scores/","title":"scores","text":""},{"location":"code-reference/pydvl/reporting/scores/#pydvl.reporting.scores.compute_removal_score","title":"<code>compute_removal_score(u, values, percentages, *, remove_best=False, progress=False)</code>","text":"<p>Fits model and computes score on the test set after incrementally removing a percentage of data points from the training set, based on their values.</p> PARAMETER  DESCRIPTION <code>u</code> <p>Utility object with model, data, and scoring function.</p> <p> TYPE: <code>Utility</code> </p> <code>values</code> <p>Data values of data instances in the training set.</p> <p> TYPE: <code>ValuationResult</code> </p> <code>percentages</code> <p>Sequence of removal percentages.</p> <p> TYPE: <code>Union[NDArray[numpy.float_], Iterable[float]]</code> </p> <code>remove_best</code> <p>If True, removes data points in order of decreasing valuation.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>progress</code> <p>If True, display a progress bar.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>Dict[float, float]</code> <p>Dictionary that maps the percentages to their respective scores.</p> Source code in <code>src/pydvl/reporting/scores.py</code> <pre><code>def compute_removal_score(\nu: Utility,\nvalues: ValuationResult,\npercentages: Union[NDArray[np.float_], Iterable[float]],\n*,\nremove_best: bool = False,\nprogress: bool = False,\n) -&gt; Dict[float, float]:\nr\"\"\"Fits model and computes score on the test set after incrementally removing\n    a percentage of data points from the training set, based on their values.\n    Args:\n        u: Utility object with model, data, and scoring function.\n        values: Data values of data instances in the training set.\n        percentages: Sequence of removal percentages.\n        remove_best: If True, removes data points in order of decreasing valuation.\n        progress: If True, display a progress bar.\n    Returns:\n        Dictionary that maps the percentages to their respective scores.\n    \"\"\"\n# Sanity checks\nif np.any([x &gt;= 1.0 or x &lt; 0.0 for x in percentages]):\nraise ValueError(\"All percentages should be in the range [0.0, 1.0)\")\nif len(values) != len(u.data.indices):\nraise ValueError(\nf\"The number of values, {len(values) }, should be equal to the number of data indices, {len(u.data.indices)}\"\n)\nscores = {}\n# We sort in descending order if we want to remove the best values\nvalues.sort(reverse=remove_best)\nfor pct in maybe_progress(percentages, display=progress, desc=\"Removal Scores\"):\nn_removal = int(pct * len(u.data))\nindices = values.indices[n_removal:]\nscore = u(indices)\nscores[pct] = score\nreturn scores\n</code></pre>"},{"location":"code-reference/pydvl/utils/","title":"utils","text":""},{"location":"code-reference/pydvl/utils/caching/","title":"caching","text":"<p>Distributed caching of functions.</p> <p>pyDVL uses memcached to cache utility values, through pymemcache. This allows sharing evaluations across processes and nodes in a cluster. You can run memcached as a service, locally or remotely, see :ref:<code>caching setup</code>.</p> <p>Warning</p> <p>Function evaluations are cached with a key based on the function's signature and code. This can lead to undesired cache hits, see :ref:<code>cache reuse</code>.</p> <p>Remember not to reuse utility objects for different datasets.</p>"},{"location":"code-reference/pydvl/utils/caching/#pydvl.utils.caching--configuration","title":"Configuration","text":"<p>Memoization is disabled by default but can be enabled easily, see :ref:<code>caching setup</code>. When enabled, it will be added to any callable used to construct a Utility (done with the decorator @memcached). Depending on the nature of the utility you might want to enable the computation of a running average of function values, see :ref:<code>caching stochastic functions</code>. You can see all configuration options under MemcachedConfig.</p>"},{"location":"code-reference/pydvl/utils/caching/#pydvl.utils.caching--default-configuration","title":"Default configuration","text":"<p><pre><code>default_config = dict(\nserver=('localhost', 11211),\nconnect_timeout=1.0,\ntimeout=0.1,\n# IMPORTANT! Disable small packet consolidation:\nno_delay=True,\nserde=serde.PickleSerde(pickle_version=PICKLE_VERSION)\n)\n</code></pre> .. _caching stochastic functions:</p>"},{"location":"code-reference/pydvl/utils/caching/#pydvl.utils.caching--usage-with-stochastic-functions","title":"Usage with stochastic functions","text":"<p>In addition to standard memoization, the decorator memcached() can compute running average and standard error of repeated evaluations for the same input. This can be useful for stochastic functions with high variance (e.g. model training for small sample sizes), but drastically reduces the speed benefits of memoization.</p> <p>This behaviour can be activated with the argument <code>allow_repeated_evaluations</code> to memcached().</p>"},{"location":"code-reference/pydvl/utils/caching/#pydvl.utils.caching--cache-reuse","title":"Cache reuse","text":"<p>When working directly with memcached(), it is essential to only cache pure functions. If they have any kind of state, either internal or external (e.g. a closure over some data that may change), then the cache will fail to notice this and the same value will be returned.</p> <p>When a function is wrapped with memcached() for memoization, its signature (input and output names) and code are used as a key for the cache. Alternatively you can pass a custom value to be used as key with</p> <pre><code>cached_fun = memcached(**asdict(cache_options))(fun, signature=custom_signature)\n</code></pre> <p>If you are running experiments with the same Utility but different datasets, this will lead to evaluations of the utility on new data returning old values because utilities only use sample indices as arguments (so there is no way to tell the difference between '1' for dataset A and '1' for dataset 2 from the point of view of the cache). One solution is to empty the cache between runs, but the preferred one is to use a different Utility object for each dataset.</p>"},{"location":"code-reference/pydvl/utils/caching/#pydvl.utils.caching--unexpected-cache-misses","title":"Unexpected cache misses","text":"<p>Because all arguments to a function are used as part of the key for the cache, sometimes one must exclude some of them. For example, If a function is going to run across multiple processes and some reporting arguments are added (like a <code>job_id</code> for logging purposes), these will be part of the signature and make the functions distinct to the eyes of the cache. This can be avoided with the use of ignore_args in the configuration.</p>"},{"location":"code-reference/pydvl/utils/caching/#pydvl.utils.caching.CacheStats","title":"<code>CacheStats</code>  <code>dataclass</code>","text":"<p>Statistics gathered by cached functions.</p> ATTRIBUTE DESCRIPTION <code>sets</code> <p>number of times a value was set in the cache</p> <p> TYPE: <code>int</code> </p> <code>misses</code> <p>number of times a value was not found in the cache</p> <p> TYPE: <code>int</code> </p> <code>hits</code> <p>number of times a value was found in the cache</p> <p> TYPE: <code>int</code> </p> <code>timeouts</code> <p>number of times a timeout occurred</p> <p> TYPE: <code>int</code> </p> <code>errors</code> <p>number of times an error occurred</p> <p> TYPE: <code>int</code> </p> <code>reconnects</code> <p>number of times the client reconnected to the server</p> <p> TYPE: <code>int</code> </p>"},{"location":"code-reference/pydvl/utils/caching/#pydvl.utils.caching.serialize","title":"<code>serialize(x)</code>","text":"<p>Serialize an object to bytes.</p> Source code in <code>src/pydvl/utils/caching.py</code> <pre><code>def serialize(x: Any) -&gt; bytes:\n\"\"\"Serialize an object to bytes.\"\"\"\npickled_output = BytesIO()\npickler = Pickler(pickled_output, PICKLE_VERSION)\npickler.dump(x)\nreturn pickled_output.getvalue()\n</code></pre>"},{"location":"code-reference/pydvl/utils/caching/#pydvl.utils.caching.memcached","title":"<code>memcached(client_config=None, time_threshold=0.3, allow_repeated_evaluations=False, rtol_stderr=0.1, min_repetitions=3, ignore_args=None)</code>","text":"<p>Transparent, distributed memoization of function calls.</p> <p>Given a function and its signature, memcached uses a distributed cache that, for each set of inputs, keeps track of the average returned value, with variance and number of times it was calculated.</p> <p>If the function is deterministic, i.e. same input corresponds to the same exact output, set <code>allow_repeated_evaluations</code> to <code>False</code>. If instead the function is stochastic (like the training of a model depending on random initializations), memcached allows to set a minimum number of evaluations to compute a running average, and a tolerance after which the function will not be called anymore. In other words, the function will be recomputed until the value has stabilized with a standard error smaller than <code>rtol_stderr * running average</code>.</p> <p>Warning</p> <p>Do not cache functions with state! See :ref:<code>cache reuse</code></p> <p>Example</p> <pre><code>cached_fun = memcached(**asdict(cache_options))(heavy_computation)\n</code></pre> PARAMETER  DESCRIPTION <code>client_config</code> <p>configuration for <code>pymemcache's Client() &lt;https://pymemcache.readthedocs.io/en/stable/apidoc/pymemcache.client.base.html&gt;</code>_. Will be merged on top of the default configuration (see below).</p> <p> TYPE: <code>Optional[MemcachedClientConfig]</code> DEFAULT: <code>None</code> </p> <code>time_threshold</code> <p>computations taking less time than this many seconds are not cached.</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.3</code> </p> <code>allow_repeated_evaluations</code> <p>If <code>True</code>, repeated calls to a function with the same arguments will be allowed and outputs averaged until the running standard deviation of the mean stabilises below <code>rtol_stderr * mean</code>.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>rtol_stderr</code> <p>relative tolerance for repeated evaluations. More precisely, memcached() will stop evaluating the function once the standard deviation of the mean is smaller than <code>rtol_stderr * mean</code>.</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.1</code> </p> <code>min_repetitions</code> <p>minimum number of times that a function evaluation on the same arguments is repeated before returning cached values. Useful for stochastic functions only. If the model training is very noisy, set this number to higher values to reduce variance.</p> <p> TYPE: <code>int</code> DEFAULT: <code>3</code> </p> <code>ignore_args</code> <p>Do not take these keyword arguments into account when hashing the wrapped function for usage as key in memcached. This allows sharing the cache among different jobs for the same experiment run if the callable happens to have \"nuisance\" parameters like \"job_id\" which do not affect the result of the computation.</p> <p> TYPE: <code>Optional[Iterable[str]]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Callable[[Callable[..., T], bytes | None], Callable[..., T]]</code> <p>A wrapped function</p> Source code in <code>src/pydvl/utils/caching.py</code> <pre><code>def memcached(\nclient_config: Optional[MemcachedClientConfig] = None,\ntime_threshold: float = 0.3,\nallow_repeated_evaluations: bool = False,\nrtol_stderr: float = 0.1,\nmin_repetitions: int = 3,\nignore_args: Optional[Iterable[str]] = None,\n) -&gt; Callable[[Callable[..., T], bytes | None], Callable[..., T]]:\n\"\"\"\n    Transparent, distributed memoization of function calls.\n    Given a function and its signature, memcached uses a distributed cache\n    that, for each set of inputs, keeps track of the average returned value,\n    with variance and number of times it was calculated.\n    If the function is deterministic, i.e. same input corresponds to the same\n    exact output, set `allow_repeated_evaluations` to `False`. If instead the\n    function is stochastic (like the training of a model depending on random\n    initializations), memcached allows to set a minimum number of evaluations\n    to compute a running average, and a tolerance after which the function will\n    not be called anymore. In other words, the function will be recomputed\n    until the value has stabilized with a standard error smaller than\n    `rtol_stderr * running average`.\n    !!! Warning\n        Do not cache functions with state! See :ref:`cache reuse`\n    !!! example\n        ```python\n        cached_fun = memcached(**asdict(cache_options))(heavy_computation)\n        ```\n    Args:\n        client_config: configuration for `pymemcache's Client()\n            &lt;https://pymemcache.readthedocs.io/en/stable/apidoc/pymemcache.client.base.html&gt;`_.\n            Will be merged on top of the default configuration (see below).\n        time_threshold: computations taking less time than this many seconds are\n            not cached.\n        allow_repeated_evaluations: If `True`, repeated calls to a function\n            with the same arguments will be allowed and outputs averaged until the\n            running standard deviation of the mean stabilises below\n            `rtol_stderr * mean`.\n        rtol_stderr: relative tolerance for repeated evaluations. More precisely,\n            [memcached()][pydvl.utils.caching.memcached] will stop evaluating the function once the\n            standard deviation of the mean is smaller than `rtol_stderr * mean`.\n        min_repetitions: minimum number of times that a function evaluation\n            on the same arguments is repeated before returning cached values. Useful\n            for stochastic functions only. If the model training is very noisy, set\n            this number to higher values to reduce variance.\n        ignore_args: Do not take these keyword arguments into account when\n            hashing the wrapped function for usage as key in memcached. This allows\n            sharing the cache among different jobs for the same experiment run if\n            the callable happens to have \"nuisance\" parameters like \"job_id\" which\n            do not affect the result of the computation.\n    Returns:\n        A wrapped function\n    \"\"\"\nif ignore_args is None:\nignore_args = []\n# Do I really need this?\ndef connect(config: MemcachedClientConfig):\n\"\"\"First tries to establish a connection, then tries setting and\n        getting a value.\"\"\"\ntry:\nclient = RetryingClient(\nClient(**asdict(config)),\nattempts=3,\nretry_delay=0.1,\nretry_for=[MemcacheUnexpectedCloseError],\n)\ntemp_key = str(uuid.uuid4())\nclient.set(temp_key, 7)\nassert client.get(temp_key) == 7\nclient.delete(temp_key, 0)\nreturn client\nexcept ConnectionRefusedError as e:\nlogger.error(  # type: ignore\nf\"@memcached: Timeout connecting \"\nf\"to {config.server} after \"\nf\"{config.connect_timeout} seconds: {str(e)}. Did you start memcached?\"\n)\nraise e\nexcept AssertionError as e:\nlogger.error(  # type: ignore\nf\"@memcached: Failure saving dummy value \"\nf\"to {config.server}: {str(e)}\"\n)\ndef wrapper(fun: Callable[..., T], signature: Optional[bytes] = None):\nif signature is None:\nsignature = serialize((fun.__code__.co_code, fun.__code__.co_consts))\n@wraps(fun, updated=[])  # don't try to use update() for a class\nclass Wrapped:\nconfig: MemcachedClientConfig\nstats: CacheStats\nclient: RetryingClient\ndef __init__(self, config: MemcachedClientConfig):\nself.config = config\nself.stats = CacheStats()\nself.client = connect(self.config)\nself._signature = signature\ndef __call__(self, *args, **kwargs) -&gt; T:\nkey_kwargs = {k: v for k, v in kwargs.items() if k not in ignore_args}  # type: ignore\narg_signature: bytes = serialize((args, list(key_kwargs.items())))\nkey = blake2b(self._signature + arg_signature).hexdigest().encode(\"ASCII\")  # type: ignore\nresult_dict: Dict[str, float] = self.get_key_value(key)\nif result_dict is None:\nresult_dict = {}\nstart = time()\nvalue = fun(*args, **kwargs)\nend = time()\nresult_dict[\"value\"] = value\nif end - start &gt;= time_threshold or allow_repeated_evaluations:\nresult_dict[\"count\"] = 1\nresult_dict[\"variance\"] = 0\nself.client.set(key, result_dict, noreply=True)\nself.stats.sets += 1\nself.stats.misses += 1\nelif allow_repeated_evaluations:\nself.stats.hits += 1\nvalue = result_dict[\"value\"]\ncount = result_dict[\"count\"]\nvariance = result_dict[\"variance\"]\nerror_on_average = (variance / count) ** (1 / 2)\nif (\nerror_on_average &gt; rtol_stderr * value\nor count &lt;= min_repetitions\n):\nnew_value = fun(*args, **kwargs)\nnew_avg, new_var = running_moments(\nvalue, variance, int(count), cast(float, new_value)\n)\nresult_dict[\"value\"] = new_avg\nresult_dict[\"count\"] = count + 1\nresult_dict[\"variance\"] = new_var\nself.client.set(key, result_dict, noreply=True)\nself.stats.sets += 1\nelse:\nself.stats.hits += 1\nreturn result_dict[\"value\"]  # type: ignore\ndef __getstate__(self):\n\"\"\"Enables pickling after a socket has been opened to the\n                memcached server, by removing the client from the stored\n                data.\"\"\"\nodict = self.__dict__.copy()\ndel odict[\"client\"]\nreturn odict\ndef __setstate__(self, d: dict):\n\"\"\"Restores a client connection after loading from a pickle.\"\"\"\nself.config = d[\"config\"]\nself.stats = d[\"stats\"]\nself.client = Client(**asdict(self.config))\nself._signature = signature\ndef get_key_value(self, key: bytes):\nresult = None\ntry:\nresult = self.client.get(key)\nexcept socket.timeout as e:\nself.stats.timeouts += 1\nwarnings.warn(f\"{type(self).__name__}: {str(e)}\", RuntimeWarning)\nexcept OSError as e:\nself.stats.errors += 1\nwarnings.warn(f\"{type(self).__name__}: {str(e)}\", RuntimeWarning)\nexcept AttributeError as e:\n# FIXME: this depends on _recv() failing on invalid sockets\n# See pymemcache.base.py,\nself.stats.reconnects += 1\nwarnings.warn(f\"{type(self).__name__}: {str(e)}\", RuntimeWarning)\nself.client = connect(self.config)\nreturn result\nWrapped.__doc__ = (\nf\"A wrapper around {fun.__name__}() with remote caching enabled.\\n\"\n+ (Wrapped.__doc__ or \"\")\n)\nWrapped.__name__ = f\"memcached_{fun.__name__}\"\npath = list(reversed(fun.__qualname__.split(\".\")))\npatched = [f\"memcached_{path[0]}\"] + path[1:]\nWrapped.__qualname__ = \".\".join(reversed(patched))\n# TODO: pick from some config file or something\nreturn Wrapped(client_config or MemcachedClientConfig())\nreturn wrapper\n</code></pre>"},{"location":"code-reference/pydvl/utils/config/","title":"config","text":""},{"location":"code-reference/pydvl/utils/config/#pydvl.utils.config.ParallelConfig","title":"<code>ParallelConfig</code>  <code>dataclass</code>","text":"<p>Configuration for parallel computation backend.</p> PARAMETER  DESCRIPTION <code>backend</code> <p>Type of backend to use. Defaults to 'joblib'</p> <p> TYPE: <code>Literal['joblib', 'ray']</code> DEFAULT: <code>'joblib'</code> </p> <code>address</code> <p>Address of existing remote or local cluster to use.</p> <p> TYPE: <code>Optional[Union[str, Tuple[str, int]]]</code> DEFAULT: <code>None</code> </p> <code>n_cpus_local</code> <p>Number of CPUs to use when creating a local ray cluster. This has no effect when using an existing ray cluster.</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>logging_level</code> <p>Logging level for the parallel backend's worker.</p> <p> TYPE: <code>int</code> DEFAULT: <code>WARNING</code> </p>"},{"location":"code-reference/pydvl/utils/config/#pydvl.utils.config.MemcachedClientConfig","title":"<code>MemcachedClientConfig</code>  <code>dataclass</code>","text":"<p>Configuration of the memcached client.</p> PARAMETER  DESCRIPTION <code>server</code> <p>A tuple of (IP|domain name, port).</p> <p> TYPE: <code>Tuple[str, int]</code> DEFAULT: <code>('localhost', 11211)</code> </p> <code>connect_timeout</code> <p>How many seconds to wait before raising <code>ConnectionRefusedError</code> on failure to connect.</p> <p> TYPE: <code>float</code> DEFAULT: <code>1.0</code> </p> <code>timeout</code> <p>seconds to wait for send or recv calls on the socket connected to memcached.</p> <p> TYPE: <code>float</code> DEFAULT: <code>1.0</code> </p> <code>no_delay</code> <p>set the <code>TCP_NODELAY</code> flag, which may help with performance in some cases.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>serde</code> <p>a serializer / deserializer (\"serde\"). The default <code>PickleSerde</code> should work in most cases. See pymemcached's documentation for details.</p> <p> TYPE: <code>PickleSerde</code> DEFAULT: <code>PickleSerde(pickle_version=PICKLE_VERSION)</code> </p>"},{"location":"code-reference/pydvl/utils/config/#pydvl.utils.config.MemcachedConfig","title":"<code>MemcachedConfig</code>  <code>dataclass</code>","text":"<p>Configuration for memcached(), providing memoization of function calls.</p> <p>Instances of this class are typically used as arguments for the construction of a Utility.</p> PARAMETER  DESCRIPTION <code>client_config</code> <p>Configuration for the connection to the memcached server.</p> <p> TYPE: <code>MemcachedClientConfig</code> DEFAULT: <code>field(default_factory=MemcachedClientConfig)</code> </p> <code>time_threshold</code> <p>computations taking less time than this many seconds are not cached.</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.3</code> </p> <code>allow_repeated_evaluations</code> <p>If <code>True</code>, repeated calls to a function with the same arguments will be allowed and outputs averaged until the running standard deviation of the mean stabilises below <code>rtol_stderr * mean</code>.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>rtol_stderr</code> <p>relative tolerance for repeated evaluations. More precisely, memcached() will stop evaluating the function once the standard deviation of the mean is smaller than <code>rtol_stderr * mean</code>.</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.1</code> </p> <code>min_repetitions</code> <p>minimum number of times that a function evaluation on the same arguments is repeated before returning cached values. Useful for stochastic functions only. If the model training is very noisy, set this number to higher values to reduce variance.</p> <p> TYPE: <code>int</code> DEFAULT: <code>3</code> </p> <code>ignore_args</code> <p>Do not take these keyword arguments into account when hashing the wrapped function for usage as key in memcached.</p> <p> TYPE: <code>Optional[Iterable[str]]</code> DEFAULT: <code>None</code> </p>"},{"location":"code-reference/pydvl/utils/dataset/","title":"dataset","text":"<p>This module contains convenience classes to handle data and groups thereof.</p> <p>Shapley and Least Core value computations require evaluation of a scoring function (the utility). This is typically the performance of the model on a test set (as an approximation to its true expected performance). It is therefore convenient to keep both the training data and the test data together to be passed around to methods in shapley and least_core. This is done with Dataset.</p> <p>This abstraction layer also seamlessly grouping data points together if one is interested in computing their value as a group, see GroupedDataset.</p> <p>Objects of both types are used to construct a Utility object.</p>"},{"location":"code-reference/pydvl/utils/dataset/#pydvl.utils.dataset.Dataset","title":"<code>Dataset(x_train, y_train, x_test, y_test, feature_names=None, target_names=None, data_names=None, description=None, is_multi_output=False)</code>","text":"<p>A convenience class to handle datasets.</p> <p>It holds a dataset, split into training and test data, together with several labels on feature names, data point names and a description.</p> PARAMETER  DESCRIPTION <code>x_train</code> <p>training data</p> <p> TYPE: <code>Union[ndarray, DataFrame]</code> </p> <code>y_train</code> <p>labels for training data</p> <p> TYPE: <code>Union[ndarray, DataFrame]</code> </p> <code>x_test</code> <p>test data</p> <p> TYPE: <code>Union[ndarray, DataFrame]</code> </p> <code>y_test</code> <p>labels for test data</p> <p> TYPE: <code>Union[ndarray, DataFrame]</code> </p> <code>feature_names</code> <p>name of the features of input data</p> <p> TYPE: <code>Optional[Sequence[str]]</code> DEFAULT: <code>None</code> </p> <code>target_names</code> <p>names of the features of target data</p> <p> TYPE: <code>Optional[Sequence[str]]</code> DEFAULT: <code>None</code> </p> <code>data_names</code> <p>names assigned to data points. For example, if the dataset is a time series, each entry can be a timestamp which can be referenced directly instead of using a row number.</p> <p> TYPE: <code>Optional[Sequence[str]]</code> DEFAULT: <code>None</code> </p> <code>description</code> <p>A textual description of the dataset.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>is_multi_output</code> <p>set to <code>False</code> if labels are scalars, or to <code>True</code> if they are vectors of dimension &gt; 1.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>src/pydvl/utils/dataset.py</code> <pre><code>def __init__(\nself,\nx_train: Union[np.ndarray, pd.DataFrame],\ny_train: Union[np.ndarray, pd.DataFrame],\nx_test: Union[np.ndarray, pd.DataFrame],\ny_test: Union[np.ndarray, pd.DataFrame],\nfeature_names: Optional[Sequence[str]] = None,\ntarget_names: Optional[Sequence[str]] = None,\ndata_names: Optional[Sequence[str]] = None,\ndescription: Optional[str] = None,\n# FIXME: use same parameter name as in check_X_y()\nis_multi_output: bool = False,\n):\n\"\"\"Constructs a Dataset from data and labels.\n    Args:\n        x_train: training data\n        y_train: labels for training data\n        x_test: test data\n        y_test: labels for test data\n        feature_names: name of the features of input data\n        target_names: names of the features of target data\n        data_names: names assigned to data points.\n            For example, if the dataset is a time series, each entry can be a\n            timestamp which can be referenced directly instead of using a row\n            number.\n        description: A textual description of the dataset.\n        is_multi_output: set to `False` if labels are scalars, or to\n            `True` if they are vectors of dimension &gt; 1.\n    \"\"\"\nself.x_train, self.y_train = check_X_y(\nx_train, y_train, multi_output=is_multi_output\n)\nself.x_test, self.y_test = check_X_y(\nx_test, y_test, multi_output=is_multi_output\n)\nif x_train.shape[-1] != x_test.shape[-1]:\nraise ValueError(\nf\"Mismatching number of features: \"\nf\"{x_train.shape[-1]} and {x_test.shape[-1]}\"\n)\nif x_train.shape[0] != y_train.shape[0]:\nraise ValueError(\nf\"Mismatching number of samples: \"\nf\"{x_train.shape[-1]} and {x_test.shape[-1]}\"\n)\nif x_test.shape[0] != y_test.shape[0]:\nraise ValueError(\nf\"Mismatching number of samples: \"\nf\"{x_test.shape[-1]} and {y_test.shape[-1]}\"\n)\ndef make_names(s: str, a: np.ndarray) -&gt; List[str]:\nn = a.shape[1] if len(a.shape) &gt; 1 else 1\nreturn [f\"{s}{i:0{1 + int(np.log10(n))}d}\" for i in range(1, n + 1)]\nself.feature_names = feature_names\nself.target_names = target_names\nif self.feature_names is None:\nif isinstance(x_train, pd.DataFrame):\nself.feature_names = x_train.columns.tolist()\nelse:\nself.feature_names = make_names(\"x\", x_train)\nif self.target_names is None:\nif isinstance(y_train, pd.DataFrame):\nself.target_names = y_train.columns.tolist()\nelse:\nself.target_names = make_names(\"y\", y_train)\nif len(self.x_train.shape) &gt; 1:\nif (\nlen(self.feature_names) != self.x_train.shape[-1]\nor len(self.feature_names) != self.x_test.shape[-1]\n):\nraise ValueError(\"Mismatching number of features and names\")\nif len(self.y_train.shape) &gt; 1:\nif (\nlen(self.target_names) != self.y_train.shape[-1]\nor len(self.target_names) != self.y_test.shape[-1]\n):\nraise ValueError(\"Mismatching number of targets and names\")\nself.description = description or \"No description\"\nself._indices = np.arange(len(self.x_train))\nself._data_names = data_names if data_names is not None else self._indices\n</code></pre>"},{"location":"code-reference/pydvl/utils/dataset/#pydvl.utils.dataset.Dataset.indices","title":"<code>indices</code>  <code>property</code>","text":"<p>Index of positions in data.x_train.</p> <p>Contiguous integers from 0 to len(Dataset).</p>"},{"location":"code-reference/pydvl/utils/dataset/#pydvl.utils.dataset.Dataset.data_names","title":"<code>data_names</code>  <code>property</code>","text":"<p>Names of each individual datapoint.</p> <p>Used for reporting Shapley values.</p>"},{"location":"code-reference/pydvl/utils/dataset/#pydvl.utils.dataset.Dataset.dim","title":"<code>dim</code>  <code>property</code>","text":"<p>Returns the number of dimensions of a sample.</p>"},{"location":"code-reference/pydvl/utils/dataset/#pydvl.utils.dataset.Dataset.get_training_data","title":"<code>get_training_data(indices=None)</code>","text":"<p>Given a set of indices, returns the training data that refer to those indices.</p> <p>This is used mainly by Utility to retrieve subsets of the data from indices. It is typically not needed in algorithms.</p> PARAMETER  DESCRIPTION <code>indices</code> <p>Optional indices that will be used to select points from the training data. If <code>None</code>, the entire training data will be returned.</p> <p> TYPE: <code>Optional[Iterable[int]]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Tuple[NDArray, NDArray]</code> <p>If <code>indices</code> is not <code>None</code>, the selected x and y arrays from the training data. Otherwise, the entire dataset.</p> Source code in <code>src/pydvl/utils/dataset.py</code> <pre><code>def get_training_data(\nself, indices: Optional[Iterable[int]] = None\n) -&gt; Tuple[NDArray, NDArray]:\n\"\"\"Given a set of indices, returns the training data that refer to those\n    indices.\n    This is used mainly by [Utility][pydvl.utils.utility.Utility] to retrieve\n    subsets of the data from indices. It is typically **not needed in\n    algorithms**.\n    Args:\n        indices: Optional indices that will be used to select points from\n            the training data. If `None`, the entire training data will be\n            returned.\n    Returns:\n        If `indices` is not `None`, the selected x and y arrays from the\n            training data. Otherwise, the entire dataset.\n    \"\"\"\nif indices is None:\nreturn self.x_train, self.y_train\nx = self.x_train[indices]\ny = self.y_train[indices]\nreturn x, y\n</code></pre>"},{"location":"code-reference/pydvl/utils/dataset/#pydvl.utils.dataset.Dataset.get_test_data","title":"<code>get_test_data(indices=None)</code>","text":"<p>Returns the entire test set regardless of the passed indices.</p> <p>The passed indices will not be used because for data valuation we generally want to score the trained model on the entire test data.</p> <p>Additionally, the way this method is used in the Utility class, the passed indices will be those of the training data and would not work on the test data.</p> <p>There may be cases where it is desired to use parts of the test data. In those cases, it is recommended to inherit from Dataset and override get_test_data().</p> <p>For example, the following snippet shows how one could go about mapping the training data indices into test data indices inside get_test_data():</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pydvl.utils import Dataset\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; class DatasetWithTestDataIndices(Dataset):\n...    def get_test_data(self, indices=None):\n...        if indices is None:\n...            return self.x_test, self.y_test\n...        fraction = len(list(indices)) / len(self)\n...        mapped_indices = len(self.x_test) / len(self) * np.asarray(indices)\n...        mapped_indices = np.unique(mapped_indices.astype(int))\n...        return self.x_test[mapped_indices], self.y_test[mapped_indices]\n...\n&gt;&gt;&gt; X = np.random.rand(100, 10)\n&gt;&gt;&gt; y = np.random.randint(0, 2, 100)\n&gt;&gt;&gt; dataset = DatasetWithTestDataIndices.from_arrays(X, y)\n&gt;&gt;&gt; indices = np.random.choice(dataset.indices, 30, replace=False)\n&gt;&gt;&gt; _ = dataset.get_training_data(indices)\n&gt;&gt;&gt; _ = dataset.get_test_data(indices)\n</code></pre> PARAMETER  DESCRIPTION <code>indices</code> <p>Optional indices into the test data. This argument is unused left for compatibility with get_training_data().</p> <p> TYPE: <code>Optional[Iterable[int]]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Tuple[NDArray, NDArray]</code> <p>The entire test data.</p> Source code in <code>src/pydvl/utils/dataset.py</code> <pre><code>def get_test_data(\nself, indices: Optional[Iterable[int]] = None\n) -&gt; Tuple[NDArray, NDArray]:\n\"\"\"Returns the entire test set regardless of the passed indices.\n    The passed indices will not be used because for data valuation\n    we generally want to score the trained model on the entire test data.\n    Additionally, the way this method is used in the\n    [Utility][pydvl.utils.utility.Utility] class, the passed indices will\n    be those of the training data and would not work on the test data.\n    There may be cases where it is desired to use parts of the test data.\n    In those cases, it is recommended to inherit from\n    [Dataset][pydvl.utils.dataset.Dataset] and override\n    [get_test_data()][pydvl.utils.dataset.Dataset.get_test_data].\n    For example, the following snippet shows how one could go about\n    mapping the training data indices into test data indices\n    inside [get_test_data()][pydvl.utils.dataset.Dataset.get_test_data]:\n    Examples:\n        &gt;&gt;&gt; from pydvl.utils import Dataset\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; class DatasetWithTestDataIndices(Dataset):\n        ...    def get_test_data(self, indices=None):\n        ...        if indices is None:\n        ...            return self.x_test, self.y_test\n        ...        fraction = len(list(indices)) / len(self)\n        ...        mapped_indices = len(self.x_test) / len(self) * np.asarray(indices)\n        ...        mapped_indices = np.unique(mapped_indices.astype(int))\n        ...        return self.x_test[mapped_indices], self.y_test[mapped_indices]\n        ...\n        &gt;&gt;&gt; X = np.random.rand(100, 10)\n        &gt;&gt;&gt; y = np.random.randint(0, 2, 100)\n        &gt;&gt;&gt; dataset = DatasetWithTestDataIndices.from_arrays(X, y)\n        &gt;&gt;&gt; indices = np.random.choice(dataset.indices, 30, replace=False)\n        &gt;&gt;&gt; _ = dataset.get_training_data(indices)\n        &gt;&gt;&gt; _ = dataset.get_test_data(indices)\n    Args:\n        indices: Optional indices into the test data. This argument is\n            unused left for compatibility with\n            [get_training_data()][pydvl.utils.dataset.Dataset.get_training_data].\n    Returns:\n        The entire test data.\n    \"\"\"\nreturn self.x_test, self.y_test\n</code></pre>"},{"location":"code-reference/pydvl/utils/dataset/#pydvl.utils.dataset.Dataset.from_sklearn","title":"<code>from_sklearn(data, train_size=0.8, random_state=None, stratify_by_target=False, **kwargs)</code>  <code>classmethod</code>","text":"<p>Constructs a Dataset object from a Bunch, as returned by the <code>load_*</code> functions in sklearn toy datasets.</p> PARAMETER  DESCRIPTION <code>data</code> <p>sklearn dataset. The following attributes are supported - <code>data</code>: covariates [required] - <code>target</code>: target variables (labels) [required] - <code>feature_names</code>: the feature names - <code>target_names</code>: the target names - <code>DESCR</code>: a description</p> <p> TYPE: <code>Bunch</code> </p> <code>train_size</code> <p>size of the training dataset. Used in <code>train_test_split</code></p> <p> TYPE: <code>float</code> DEFAULT: <code>0.8</code> </p> <code>random_state</code> <p>seed for train / test split</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>stratify_by_target</code> <p>If <code>True</code>, data is split in a stratified fashion, using the target variable as labels. Read more in scikit-learn's user guide.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>kwargs</code> <p>Additional keyword arguments to pass to the Dataset constructor. Use this to pass e.g. <code>is_multi_output</code>.</p> <p> TYPE: <code>dict</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>Dataset</code> <p>Object with the sklearn dataset</p> <p>Changed in version 0.6.0</p> <p>Added kwargs to pass to the Dataset constructor.</p> Source code in <code>src/pydvl/utils/dataset.py</code> <pre><code>@classmethod\ndef from_sklearn(\ncls,\ndata: Bunch,\ntrain_size: float = 0.8,\nrandom_state: Optional[int] = None,\nstratify_by_target: bool = False,\n**kwargs: dict,\n) -&gt; \"Dataset\":\n\"\"\"Constructs a [Dataset][pydvl.utils.Dataset] object from a\n    [Bunch][sklearn.utils.Bunch], as returned by the `load_*` functions in\n    [sklearn toy datasets](https://scikit-learn.org/stable/datasets/toy_dataset.html).\n    Args:\n        data: sklearn dataset. The following attributes are supported\n            - `data`: covariates [required]\n            - `target`: target variables (labels) [required]\n            - `feature_names`: the feature names\n            - `target_names`: the target names\n            - `DESCR`: a description\n        train_size: size of the training dataset. Used in `train_test_split`\n        random_state: seed for train / test split\n        stratify_by_target: If `True`, data is split in a stratified\n            fashion, using the target variable as labels. Read more in\n            [scikit-learn's user guide](https://scikit-learn.org/stable/modules/cross_validation.html#stratification).\n        kwargs: Additional keyword arguments to pass to the\n            [Dataset][pydvl.utils.Dataset] constructor. Use this to pass e.g. `is_multi_output`.\n    Returns:\n        Object with the sklearn dataset\n    !!! tip \"Changed in version 0.6.0\"\n        Added kwargs to pass to the [Dataset][pydvl.utils.Dataset] constructor.\n    \"\"\"\nx_train, x_test, y_train, y_test = train_test_split(\ndata.data,\ndata.target,\ntrain_size=train_size,\nrandom_state=random_state,\nstratify=data.target if stratify_by_target else None,\n)\nreturn cls(\nx_train,\ny_train,\nx_test,\ny_test,\nfeature_names=data.get(\"feature_names\"),\ntarget_names=data.get(\"target_names\"),\ndescription=data.get(\"DESCR\"),\n**kwargs,\n)\n</code></pre>"},{"location":"code-reference/pydvl/utils/dataset/#pydvl.utils.dataset.Dataset.from_arrays","title":"<code>from_arrays(X, y, train_size=0.8, random_state=None, stratify_by_target=False, **kwargs)</code>  <code>classmethod</code>","text":"<p>Constructs a Dataset object from X and y numpy arrays  as returned by the <code>make_*</code> functions in sklearn generated datasets.</p> PARAMETER  DESCRIPTION <code>X</code> <p>numpy array of shape (n_samples, n_features)</p> <p> TYPE: <code>NDArray</code> </p> <code>y</code> <p>numpy array of shape (n_samples,)</p> <p> TYPE: <code>NDArray</code> </p> <code>train_size</code> <p>size of the training dataset. Used in <code>train_test_split</code></p> <p> TYPE: <code>float</code> DEFAULT: <code>0.8</code> </p> <code>random_state</code> <p>seed for train / test split</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>stratify_by_target</code> <p>If <code>True</code>, data is split in a stratified fashion, using the y variable as labels. Read more in sklearn's user guide.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>kwargs</code> <p>Additional keyword arguments to pass to the Dataset constructor. Use this to pass e.g. <code>feature_names</code> or <code>target_names</code>.</p> <p> TYPE: <code>dict</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>Dataset</code> <p>Object with the passed X and y arrays split across training and test sets.</p> <p>New in version 0.4.0</p> <p>Changed in version 0.6.0</p> <p>Added kwargs to pass to the Dataset constructor.</p> Source code in <code>src/pydvl/utils/dataset.py</code> <pre><code>@classmethod\ndef from_arrays(\ncls,\nX: NDArray,\ny: NDArray,\ntrain_size: float = 0.8,\nrandom_state: Optional[int] = None,\nstratify_by_target: bool = False,\n**kwargs: dict,\n) -&gt; \"Dataset\":\n\"\"\"Constructs a [Dataset][pydvl.utils.Dataset] object from X and y numpy arrays  as\n    returned by the `make_*` functions in [sklearn generated datasets](https://scikit-learn.org/stable/datasets/sample_generators.html).\n    Args:\n        X: numpy array of shape (n_samples, n_features)\n        y: numpy array of shape (n_samples,)\n        train_size: size of the training dataset. Used in `train_test_split`\n        random_state: seed for train / test split\n        stratify_by_target: If `True`, data is split in a stratified fashion,\n            using the y variable as labels. Read more in [sklearn's user\n            guide](https://scikit-learn.org/stable/modules/cross_validation.html#stratification).\n        kwargs: Additional keyword arguments to pass to the\n            [Dataset][pydvl.utils.Dataset] constructor. Use this to pass e.g. `feature_names`\n            or `target_names`.\n    Returns:\n        Object with the passed X and y arrays split across training and test sets.\n    !!! tip \"New in version 0.4.0\"\n    !!! tip \"Changed in version 0.6.0\"\n        Added kwargs to pass to the [Dataset][pydvl.utils.Dataset] constructor.\n    \"\"\"\nx_train, x_test, y_train, y_test = train_test_split(\nX,\ny,\ntrain_size=train_size,\nrandom_state=random_state,\nstratify=y if stratify_by_target else None,\n)\nreturn cls(x_train, y_train, x_test, y_test, **kwargs)\n</code></pre>"},{"location":"code-reference/pydvl/utils/dataset/#pydvl.utils.dataset.GroupedDataset","title":"<code>GroupedDataset(x_train, y_train, x_test, y_test, data_groups, feature_names=None, target_names=None, group_names=None, description=None, **kwargs)</code>","text":"<p>             Bases: <code>Dataset</code></p> <p>Used for calculating Shapley values of subsets of the data considered as logical units. For instance, one can group by value of a categorical feature, by bin into which a continuous feature falls, or by label.</p> PARAMETER  DESCRIPTION <code>x_train</code> <p>training data</p> <p> TYPE: <code>ndarray</code> </p> <code>y_train</code> <p>labels of training data</p> <p> TYPE: <code>ndarray</code> </p> <code>x_test</code> <p>test data</p> <p> TYPE: <code>ndarray</code> </p> <code>y_test</code> <p>labels of test data</p> <p> TYPE: <code>ndarray</code> </p> <code>data_groups</code> <p>Iterable of the same length as <code>x_train</code> containing a group label for each training data point. The label can be of any type, e.g. <code>str</code> or <code>int</code>. Data points with the same label will then be grouped by this object and considered as one for effects of valuation.</p> <p> TYPE: <code>Sequence</code> </p> <code>feature_names</code> <p>names of the covariates' features.</p> <p> TYPE: <code>Optional[Sequence[str]]</code> DEFAULT: <code>None</code> </p> <code>target_names</code> <p>names of the labels or targets y</p> <p> TYPE: <code>Optional[Sequence[str]]</code> DEFAULT: <code>None</code> </p> <code>group_names</code> <p>names of the groups. If not provided, the labels from <code>data_groups</code> will be used.</p> <p> TYPE: <code>Optional[Sequence[str]]</code> DEFAULT: <code>None</code> </p> <code>description</code> <p>A textual description of the dataset</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>kwargs</code> <p>Additional keyword arguments to pass to the Dataset constructor.</p> <p> TYPE: <code>dict</code> DEFAULT: <code>{}</code> </p> <p>Changed in version 0.6.0</p> <p>Added <code>group_names</code> and forwarding of <code>kwargs</code></p> Source code in <code>src/pydvl/utils/dataset.py</code> <pre><code>def __init__(\nself,\nx_train: np.ndarray,\ny_train: np.ndarray,\nx_test: np.ndarray,\ny_test: np.ndarray,\ndata_groups: Sequence,\nfeature_names: Optional[Sequence[str]] = None,\ntarget_names: Optional[Sequence[str]] = None,\ngroup_names: Optional[Sequence[str]] = None,\ndescription: Optional[str] = None,\n**kwargs: dict,\n):\n\"\"\"Class for grouping datasets.\n    Used for calculating Shapley values of subsets of the data considered\n    as logical units. For instance, one can group by value of a categorical\n    feature, by bin into which a continuous feature falls, or by label.\n    Args:\n        x_train: training data\n        y_train: labels of training data\n        x_test: test data\n        y_test: labels of test data\n        data_groups: Iterable of the same length as `x_train` containing\n            a group label for each training data point. The label can be of any\n            type, e.g. `str` or `int`. Data points with the same label will\n            then be grouped by this object and considered as one for effects of\n            valuation.\n        feature_names: names of the covariates' features.\n        target_names: names of the labels or targets y\n        group_names: names of the groups. If not provided, the labels\n            from `data_groups` will be used.\n        description: A textual description of the dataset\n        kwargs: Additional keyword arguments to pass to the\n            [Dataset][pydvl.utils.Dataset] constructor.\n    !!! tip \"Changed in version 0.6.0\"\n    Added `group_names` and forwarding of `kwargs`\n    \"\"\"\nsuper().__init__(\nx_train=x_train,\ny_train=y_train,\nx_test=x_test,\ny_test=y_test,\nfeature_names=feature_names,\ntarget_names=target_names,\ndescription=description,\n**kwargs,\n)\nif len(data_groups) != len(x_train):\nraise ValueError(\nf\"data_groups and x_train must have the same length.\"\nf\"Instead got {len(data_groups)=} and {len(x_train)=}\"\n)\nself.groups: OrderedDict[Any, List[int]] = OrderedDict(\n{k: [] for k in set(data_groups)}\n)\nfor idx, group in enumerate(data_groups):\nself.groups[group].append(idx)\nself.group_items = list(self.groups.items())\nself._indices = np.arange(len(self.groups.keys()))\nself._data_names = (\ngroup_names if group_names is not None else list(self.groups.keys())\n)\n</code></pre>"},{"location":"code-reference/pydvl/utils/dataset/#pydvl.utils.dataset.GroupedDataset.indices","title":"<code>indices</code>  <code>property</code>","text":"<p>Indices of the groups.</p>"},{"location":"code-reference/pydvl/utils/dataset/#pydvl.utils.dataset.GroupedDataset.data_names","title":"<code>data_names</code>  <code>property</code>","text":"<p>Names of the groups.</p>"},{"location":"code-reference/pydvl/utils/dataset/#pydvl.utils.dataset.GroupedDataset.get_training_data","title":"<code>get_training_data(indices=None)</code>","text":"<p>Returns the data and labels of all samples in the given groups.</p> PARAMETER  DESCRIPTION <code>indices</code> <p>group indices whose elements to return. If <code>None</code>, all data from all groups are returned.</p> <p> TYPE: <code>Optional[Iterable[int]]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Tuple[NDArray, NDArray]</code> <p>Tuple of training data x and labels y.</p> Source code in <code>src/pydvl/utils/dataset.py</code> <pre><code>def get_training_data(\nself, indices: Optional[Iterable[int]] = None\n) -&gt; Tuple[NDArray, NDArray]:\n\"\"\"Returns the data and labels of all samples in the given groups.\n    Args:\n        indices: group indices whose elements to return. If `None`,\n            all data from all groups are returned.\n    Returns:\n        Tuple of training data x and labels y.\n    \"\"\"\nif indices is None:\nindices = self.indices\ndata_indices = [\nidx for group_id in indices for idx in self.group_items[group_id][1]\n]\nreturn super().get_training_data(data_indices)\n</code></pre>"},{"location":"code-reference/pydvl/utils/dataset/#pydvl.utils.dataset.GroupedDataset.from_sklearn","title":"<code>from_sklearn(data, train_size=0.8, random_state=None, stratify_by_target=False, data_groups=None, **kwargs)</code>  <code>classmethod</code>","text":"<p>Constructs a GroupedDataset object from a scikit-learn bunch as returned by the <code>load_*</code> functions in <code>sklearn toy datasets &lt;https://scikit-learn.org/stable/datasets/toy_dataset.html&gt;</code>_ and groups it.</p> PARAMETER  DESCRIPTION <code>data</code> <p>sklearn dataset. The following attributes are supported - <code>data</code>: covariates [required] - <code>target</code>: target variables (labels) [required] - <code>feature_names</code>: the feature names - <code>target_names</code>: the target names - <code>DESCR</code>: a description</p> <p> TYPE: <code>Bunch</code> </p> <code>train_size</code> <p>size of the training dataset. Used in <code>train_test_split</code>.</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.8</code> </p> <code>random_state</code> <p>seed for train / test split.</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>stratify_by_target</code> <p>If <code>True</code>, data is split in a stratified fashion, using the target variable as labels. Read more in sklearn's user guide.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>data_groups</code> <p>an array holding the group index or name for each data point. The length of this array must be equal to the number of data points in the dataset.</p> <p> TYPE: <code>Optional[Sequence]</code> DEFAULT: <code>None</code> </p> <code>kwargs</code> <p>Additional keyword arguments to pass to the Dataset constructor.</p> <p> TYPE: <code>dict</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>GroupedDataset</code> <p>Dataset with the selected sklearn data</p> Source code in <code>src/pydvl/utils/dataset.py</code> <pre><code>@classmethod\ndef from_sklearn(\ncls,\ndata: Bunch,\ntrain_size: float = 0.8,\nrandom_state: Optional[int] = None,\nstratify_by_target: bool = False,\ndata_groups: Optional[Sequence] = None,\n**kwargs: dict,\n) -&gt; \"GroupedDataset\":\n\"\"\"Constructs a [GroupedDataset][pydvl.utils.GroupedDataset] object from a scikit-learn bunch\n    as returned by the `load_*` functions in `sklearn toy datasets\n    &lt;https://scikit-learn.org/stable/datasets/toy_dataset.html&gt;`_ and groups\n    it.\n    Args:\n        data: sklearn dataset. The following attributes are supported\n            - `data`: covariates [required]\n            - `target`: target variables (labels) [required]\n            - `feature_names`: the feature names\n            - `target_names`: the target names\n            - `DESCR`: a description\n        train_size: size of the training dataset. Used in `train_test_split`.\n        random_state: seed for train / test split.\n        stratify_by_target: If `True`, data is split in a stratified\n            fashion, using the target variable as labels. Read more in\n            [sklearn's user guide](https://scikit-learn.org/stable/modules/cross_validation.html#stratification).\n        data_groups: an array holding the group index or name for each\n            data point. The length of this array must be equal to the number of\n            data points in the dataset.\n        kwargs: Additional keyword arguments to pass to the\n            [Dataset][pydvl.utils.Dataset] constructor.\n    Returns:\n        Dataset with the selected sklearn data\n    \"\"\"\nif data_groups is None:\nraise ValueError(\n\"data_groups must be provided when constructing a GroupedDataset\"\n)\nx_train, x_test, y_train, y_test, data_groups_train, _ = train_test_split(\ndata.data,\ndata.target,\ndata_groups,\ntrain_size=train_size,\nrandom_state=random_state,\nstratify=data.target if stratify_by_target else None,\n)\ndataset = Dataset(\nx_train=x_train, y_train=y_train, x_test=x_test, y_test=y_test, **kwargs\n)\nreturn cls.from_dataset(dataset, data_groups_train)  # type: ignore\n</code></pre>"},{"location":"code-reference/pydvl/utils/dataset/#pydvl.utils.dataset.GroupedDataset.from_arrays","title":"<code>from_arrays(X, y, train_size=0.8, random_state=None, stratify_by_target=False, data_groups=None, **kwargs)</code>  <code>classmethod</code>","text":"<p>Constructs a GroupedDataset object from X and y numpy arrays as returned by the <code>make_*</code> functions in <code>sklearn generated datasets &lt;https://scikit-learn.org/stable/datasets/sample_generators.html&gt;</code>_.</p> PARAMETER  DESCRIPTION <code>X</code> <p>array of shape (n_samples, n_features)</p> <p> TYPE: <code>NDArray</code> </p> <code>y</code> <p>array of shape (n_samples,)</p> <p> TYPE: <code>NDArray</code> </p> <code>train_size</code> <p>size of the training dataset. Used in <code>train_test_split</code>.</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.8</code> </p> <code>random_state</code> <p>seed for train / test split.</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>stratify_by_target</code> <p>If <code>True</code>, data is split in a stratified fashion, using the y variable as labels. Read more in sklearn's user guide.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>data_groups</code> <p>an array holding the group index or name for each data point. The length of this array must be equal to the number of data points in the dataset.</p> <p> TYPE: <code>Optional[Sequence]</code> DEFAULT: <code>None</code> </p> <code>kwargs</code> <p>Additional keyword arguments that will be passed to the Dataset constructor.</p> <p> TYPE: <code>dict</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>Dataset</code> <p>Dataset with the passed X and y arrays split across training and test sets.</p> <p>New in version 0.4.0</p> <p>Changed in version 0.6.0</p> <p>Added kwargs to pass to the Dataset constructor.</p> Source code in <code>src/pydvl/utils/dataset.py</code> <pre><code>@classmethod\ndef from_arrays(\ncls,\nX: NDArray,\ny: NDArray,\ntrain_size: float = 0.8,\nrandom_state: Optional[int] = None,\nstratify_by_target: bool = False,\ndata_groups: Optional[Sequence] = None,\n**kwargs: dict,\n) -&gt; \"Dataset\":\n\"\"\"Constructs a [GroupedDataset][pydvl.utils.GroupedDataset] object from X and y numpy arrays\n    as returned by the `make_*` functions in `sklearn generated datasets\n    &lt;https://scikit-learn.org/stable/datasets/sample_generators.html&gt;`_.\n    Args:\n        X: array of shape (n_samples, n_features)\n        y: array of shape (n_samples,)\n        train_size: size of the training dataset. Used in `train_test_split`.\n        random_state: seed for train / test split.\n        stratify_by_target: If `True`, data is split in a stratified\n            fashion, using the y variable as labels. Read more in\n            [sklearn's user guide](https://scikit-learn.org/stable/modules/cross_validation.html#stratification).\n        data_groups: an array holding the group index or name for each data\n            point. The length of this array must be equal to the number of\n            data points in the dataset.\n        kwargs: Additional keyword arguments that will be passed to the\n            [Dataset][pydvl.utils.Dataset] constructor.\n    Returns:\n        Dataset with the passed X and y arrays split across training and\n            test sets.\n    !!! tip \"New in version 0.4.0\"\n    !!! tip \"Changed in version 0.6.0\"\n        Added kwargs to pass to the [Dataset][pydvl.utils.Dataset] constructor.\n    \"\"\"\nif data_groups is None:\nraise ValueError(\n\"data_groups must be provided when constructing a GroupedDataset\"\n)\nx_train, x_test, y_train, y_test, data_groups_train, _ = train_test_split(\nX,\ny,\ndata_groups,\ntrain_size=train_size,\nrandom_state=random_state,\nstratify=y if stratify_by_target else None,\n)\ndataset = Dataset(\nx_train=x_train, y_train=y_train, x_test=x_test, y_test=y_test, **kwargs\n)\nreturn cls.from_dataset(dataset, data_groups_train)\n</code></pre>"},{"location":"code-reference/pydvl/utils/dataset/#pydvl.utils.dataset.GroupedDataset.from_dataset","title":"<code>from_dataset(dataset, data_groups)</code>  <code>classmethod</code>","text":"<p>Creates a GroupedDataset object from the data a Dataset object and a mapping of data groups.</p> PARAMETER  DESCRIPTION <code>dataset</code> <p>The original data.</p> <p> TYPE: <code>Dataset</code> </p> <code>data_groups</code> <p>An array holding the group index or name for each data point. The length of this array must be equal to the number of data points in the dataset.</p> <p> TYPE: <code>Sequence[Any]</code> </p> RETURNS DESCRIPTION <code>GroupedDataset</code> <p>A GroupedDataset with the initial Dataset grouped by data_groups.</p> Source code in <code>src/pydvl/utils/dataset.py</code> <pre><code>@classmethod\ndef from_dataset(\ncls, dataset: Dataset, data_groups: Sequence[Any]\n) -&gt; \"GroupedDataset\":\n\"\"\"Creates a [GroupedDataset][pydvl.utils.GroupedDataset] object from the data a\n    [Dataset][pydvl.utils.Dataset] object and a mapping of data groups.\n    Args:\n        dataset: The original data.\n        data_groups: An array holding the group index or name for each data\n            point. The length of this array must be equal to the number of\n            data points in the dataset.\n    Returns:\n        A [GroupedDataset][pydvl.utils.GroupedDataset] with the initial\n            [Dataset][pydvl.utils.Dataset] grouped by data_groups.\n    \"\"\"\nreturn cls(\nx_train=dataset.x_train,\ny_train=dataset.y_train,\nx_test=dataset.x_test,\ny_test=dataset.y_test,\ndata_groups=data_groups,\nfeature_names=dataset.feature_names,\ntarget_names=dataset.target_names,\ndescription=dataset.description,\n)\n</code></pre>"},{"location":"code-reference/pydvl/utils/numeric/","title":"numeric","text":"<p>This module contains routines for numerical computations used across the library.</p>"},{"location":"code-reference/pydvl/utils/numeric/#pydvl.utils.numeric.powerset","title":"<code>powerset(s)</code>","text":"<p>Returns an iterator for the power set of the argument.</p> <p>Subsets are generated in sequence by growing size. See  random_powerset() for random  sampling.</p> <p>import numpy as np from pydvl.utils.numeric import powerset list(powerset(np.array((1,2)))) [(), (1,), (2,), (1, 2)]</p> PARAMETER  DESCRIPTION <code>s</code> <p>The set to use</p> <p> TYPE: <code>NDArray[T]</code> </p> RETURNS DESCRIPTION <code>Iterator[Collection[T]]</code> <p>An iterator over all subsets of the set of indices <code>s</code>.</p> Source code in <code>src/pydvl/utils/numeric.py</code> <pre><code>def powerset(s: NDArray[T]) -&gt; Iterator[Collection[T]]:\n\"\"\"Returns an iterator for the power set of the argument.\n     Subsets are generated in sequence by growing size. See\n     [random_powerset()][pydvl.utils.numeric.random_powerset] for random\n     sampling.\n    &gt;&gt;&gt; import numpy as np\n    &gt;&gt;&gt; from pydvl.utils.numeric import powerset\n    &gt;&gt;&gt; list(powerset(np.array((1,2))))\n    [(), (1,), (2,), (1, 2)]\n    Args:\n         s: The set to use\n    Returns:\n        An iterator over all subsets of the set of indices `s`.\n    \"\"\"\nreturn chain.from_iterable(combinations(s, r) for r in range(len(s) + 1))\n</code></pre>"},{"location":"code-reference/pydvl/utils/numeric/#pydvl.utils.numeric.num_samples_permutation_hoeffding","title":"<code>num_samples_permutation_hoeffding(eps, delta, u_range)</code>","text":"<p>Lower bound on the number of samples required for MonteCarlo Shapley to obtain an (\u03b5,\u03b4)-approximation.</p> <p>That is: with probability 1-\u03b4, the estimated value for one data point will be \u03b5-close to the true quantity, if at least this many permutations are sampled.</p> PARAMETER  DESCRIPTION <code>eps</code> <p>\u03b5 &gt; 0</p> <p> TYPE: <code>float</code> </p> <code>delta</code> <p>0 &lt; \u03b4 &lt;= 1</p> <p> TYPE: <code>float</code> </p> <code>u_range</code> <p>Range of the Utility function</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>int</code> <p>Number of permutations required to guarantee \u03b5-correct Shapley values with probability 1-\u03b4</p> Source code in <code>src/pydvl/utils/numeric.py</code> <pre><code>def num_samples_permutation_hoeffding(eps: float, delta: float, u_range: float) -&gt; int:\n\"\"\"Lower bound on the number of samples required for MonteCarlo Shapley to\n    obtain an (\u03b5,\u03b4)-approximation.\n    That is: with probability 1-\u03b4, the estimated value for one data point will\n    be \u03b5-close to the true quantity, if at least this many permutations are\n    sampled.\n    Args:\n        eps: \u03b5 &gt; 0\n        delta: 0 &lt; \u03b4 &lt;= 1\n        u_range: Range of the [Utility][pydvl.utils.utility.Utility] function\n    Returns:\n        Number of _permutations_ required to guarantee \u03b5-correct Shapley\n            values with probability 1-\u03b4\n    \"\"\"\nreturn int(np.ceil(np.log(2 / delta) * 2 * u_range**2 / eps**2))\n</code></pre>"},{"location":"code-reference/pydvl/utils/numeric/#pydvl.utils.numeric.random_subset","title":"<code>random_subset(s, q=0.5)</code>","text":"<p>Returns one subset at random from <code>s</code>.</p> PARAMETER  DESCRIPTION <code>s</code> <p>set to sample from</p> <p> TYPE: <code>NDArray[T]</code> </p> <code>q</code> <p>Sampling probability for elements. The default 0.5 yields a uniform distribution over the power set of s.</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.5</code> </p> RETURNS DESCRIPTION <code>NDArray[T]</code> <p>The subset</p> Source code in <code>src/pydvl/utils/numeric.py</code> <pre><code>def random_subset(s: NDArray[T], q: float = 0.5) -&gt; NDArray[T]:\n\"\"\"Returns one subset at random from `s`.\n    Args:\n        s: set to sample from\n        q: Sampling probability for elements. The default 0.5 yields a\n            uniform distribution over the power set of s.\n    Returns:\n        The subset\n    \"\"\"\nrng = np.random.default_rng()\nselection = rng.uniform(size=len(s)) &gt; q\nreturn s[selection]\n</code></pre>"},{"location":"code-reference/pydvl/utils/numeric/#pydvl.utils.numeric.random_powerset","title":"<code>random_powerset(s, n_samples=None, q=0.5)</code>","text":"<p>Samples subsets from the power set of the argument, without pre-generating all subsets and in no order.</p> <p>See <code>powerset()</code> if you wish to deterministically generate all subsets.</p> <p>To generate subsets, <code>len(s)</code> Bernoulli draws with probability <code>q</code> are drawn. The default value of <code>q = 0.5</code> provides a uniform distribution over the power set of <code>s</code>. Other choices can be used e.g. to implement :func:<code>Owen sampling &lt;pydvl.value.shapley.owen.owen_sampling_shapley&gt;</code>.</p> PARAMETER  DESCRIPTION <code>s</code> <p>set to sample from</p> <p> TYPE: <code>NDArray[T]</code> </p> <code>n_samples</code> <p>if set, stop the generator after this many steps. Defaults to <code>np.iinfo(np.int32).max</code></p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>q</code> <p>Sampling probability for elements. The default 0.5 yields a uniform distribution over the power set of s.</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.5</code> </p> RETURNS DESCRIPTION <code>Generator[NDArray[T], None, None]</code> <p>Samples from the power set of <code>s</code>.</p> <p>:raises: ValueError: if the element sampling probability is not in [0,1]</p> Source code in <code>src/pydvl/utils/numeric.py</code> <pre><code>def random_powerset(\ns: NDArray[T], n_samples: Optional[int] = None, q: float = 0.5\n) -&gt; Generator[NDArray[T], None, None]:\n\"\"\"Samples subsets from the power set of the argument, without\n    pre-generating all subsets and in no order.\n    See `powerset()` if you wish to deterministically generate all subsets.\n    To generate subsets, `len(s)` Bernoulli draws with probability `q` are\n    drawn. The default value of `q = 0.5` provides a uniform distribution over\n    the power set of `s`. Other choices can be used e.g. to implement\n    :func:`Owen sampling &lt;pydvl.value.shapley.owen.owen_sampling_shapley&gt;`.\n    Args:\n        s: set to sample from\n        n_samples: if set, stop the generator after this many steps.\n            Defaults to `np.iinfo(np.int32).max`\n        q: Sampling probability for elements. The default 0.5 yields a\n            uniform distribution over the power set of s.\n    Returns:\n        Samples from the power set of `s`.\n    :raises: ValueError: if the element sampling probability is not in [0,1]\n    \"\"\"\nif q &lt; 0 or q &gt; 1:\nraise ValueError(\"Element sampling probability must be in [0,1]\")\ntotal = 1\nif n_samples is None:\nn_samples = np.iinfo(np.int32).max\nwhile total &lt;= n_samples:\nyield random_subset(s, q)\ntotal += 1\n</code></pre>"},{"location":"code-reference/pydvl/utils/numeric/#pydvl.utils.numeric.random_subset_of_size","title":"<code>random_subset_of_size(s, size)</code>","text":"<p>Samples a random subset of given size uniformly from the powerset of <code>s</code>.</p> PARAMETER  DESCRIPTION <code>s</code> <p>Set to sample from</p> <p> TYPE: <code>NDArray[T]</code> </p> <code>size</code> <p>Size of the subset to generate</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>NDArray[T]</code> <p>The subset</p> <p>:raises ValueError: If size &gt; len(s)</p> Source code in <code>src/pydvl/utils/numeric.py</code> <pre><code>def random_subset_of_size(s: NDArray[T], size: int) -&gt; NDArray[T]:\n\"\"\"Samples a random subset of given size uniformly from the powerset\n    of `s`.\n    Args:\n        s: Set to sample from\n        size: Size of the subset to generate\n    Returns:\n        The subset\n    :raises ValueError: If size &gt; len(s)\n    \"\"\"\nif size &gt; len(s):\nraise ValueError(\"Cannot sample subset larger than set\")\nrng = np.random.default_rng()\nreturn rng.choice(s, size=size, replace=False)\n</code></pre>"},{"location":"code-reference/pydvl/utils/numeric/#pydvl.utils.numeric.random_matrix_with_condition_number","title":"<code>random_matrix_with_condition_number(n, condition_number)</code>","text":"<p>Constructs a square matrix with a given condition number.</p> <p>Taken from: https://gist.github.com/bstellato/23322fe5d87bb71da922fbc41d658079#file-random_mat_condition_number-py</p> <p>Also see: https://math.stackexchange.com/questions/1351616/condition-number-of-ata.</p> PARAMETER  DESCRIPTION <code>n</code> <p>size of the matrix</p> <p> TYPE: <code>int</code> </p> <code>condition_number</code> <p>duh</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>NDArray</code> <p>An (n,n) matrix with the requested condition number.</p> Source code in <code>src/pydvl/utils/numeric.py</code> <pre><code>def random_matrix_with_condition_number(n: int, condition_number: float) -&gt; NDArray:\n\"\"\"Constructs a square matrix with a given condition number.\n    Taken from:\n    https://gist.github.com/bstellato/23322fe5d87bb71da922fbc41d658079#file-random_mat_condition_number-py\n    Also see:\n    https://math.stackexchange.com/questions/1351616/condition-number-of-ata.\n    Args:\n        n: size of the matrix\n        condition_number: duh\n    Returns:\n        An (n,n) matrix with the requested condition number.\n    \"\"\"\nif n &lt; 2:\nraise ValueError(\"Matrix size must be at least 2\")\nif condition_number &lt;= 1:\nraise ValueError(\"Condition number must be greater than 1\")\nlog_condition_number = np.log(condition_number)\nexp_vec = np.arange(\n-log_condition_number / 4.0,\nlog_condition_number * (n + 1) / (4 * (n - 1)),\nlog_condition_number / (2.0 * (n - 1)),\n)\nexp_vec = exp_vec[:n]\ns: np.ndarray = np.exp(exp_vec)\nS = np.diag(s)\nU, _ = np.linalg.qr((np.random.rand(n, n) - 5.0) * 200)\nV, _ = np.linalg.qr((np.random.rand(n, n) - 5.0) * 200)\nP: np.ndarray = U.dot(S).dot(V.T)\nP = P.dot(P.T)\nreturn P\n</code></pre>"},{"location":"code-reference/pydvl/utils/numeric/#pydvl.utils.numeric.running_moments","title":"<code>running_moments(previous_avg, previous_variance, count, new_value)</code>","text":"<p>Uses Welford's algorithm to calculate the running average and variance of  a set of numbers.</p> <p>See Welford's algorithm in wikipedia</p> <p>Warning</p> <p>This is not really using Welford's correction for numerical stability    for the variance. (FIXME)</p> <p>Todo</p> <p>This could be generalised to arbitrary moments. See this paper</p> PARAMETER  DESCRIPTION <code>previous_avg</code> <p>average value at previous step</p> <p> TYPE: <code>float | NDArray[numpy.float_]</code> </p> <code>previous_variance</code> <p>variance at previous step</p> <p> TYPE: <code>float | NDArray[numpy.float_]</code> </p> <code>count</code> <p>number of points seen so far</p> <p> TYPE: <code>int</code> </p> <code>new_value</code> <p>new value in the series of numbers</p> <p> TYPE: <code>float | NDArray[numpy.float_]</code> </p> RETURNS DESCRIPTION <code>Tuple[float | NDArray[numpy.float_], float | NDArray[numpy.float_]]</code> <p>new_average, new_variance, calculated with the new count</p> Source code in <code>src/pydvl/utils/numeric.py</code> <pre><code>def running_moments(\nprevious_avg: float | NDArray[np.float_],\nprevious_variance: float | NDArray[np.float_],\ncount: int,\nnew_value: float | NDArray[np.float_],\n) -&gt; Tuple[float | NDArray[np.float_], float | NDArray[np.float_]]:\n\"\"\"Uses Welford's algorithm to calculate the running average and variance of\n     a set of numbers.\n    See [Welford's algorithm in wikipedia](https://en.wikipedia.org/wiki/Algorithms_for_calculating_variance#Welford's_online_algorithm)\n    !!! Warning\n       This is not really using Welford's correction for numerical stability\n       for the variance. (FIXME)\n    !!! Todo\n       This could be generalised to arbitrary moments. See [this paper](https://www.osti.gov/biblio/1028931)\n    Args:\n        previous_avg: average value at previous step\n        previous_variance: variance at previous step\n        count: number of points seen so far\n        new_value: new value in the series of numbers\n    Returns:\n        new_average, new_variance, calculated with the new count\n    \"\"\"\n# broadcasted operations seem not to be supported by mypy, so we ignore the type\nnew_average = (new_value + count * previous_avg) / (count + 1)  # type: ignore\nnew_variance = previous_variance + (\n(new_value - previous_avg) * (new_value - new_average) - previous_variance\n) / (count + 1)\nreturn new_average, new_variance\n</code></pre>"},{"location":"code-reference/pydvl/utils/numeric/#pydvl.utils.numeric.top_k_value_accuracy","title":"<code>top_k_value_accuracy(y_true, y_pred, k=3)</code>","text":"<p>Computes the top-k accuracy for the estimated values by comparing indices of the highest k values.</p> PARAMETER  DESCRIPTION <code>y_true</code> <p>Exact/true value</p> <p> TYPE: <code>NDArray[numpy.float_]</code> </p> <code>y_pred</code> <p>Predicted/estimated value</p> <p> TYPE: <code>NDArray[numpy.float_]</code> </p> <code>k</code> <p>Number of the highest values taken into account</p> <p> TYPE: <code>int</code> DEFAULT: <code>3</code> </p> RETURNS DESCRIPTION <code>float</code> <p>Accuracy</p> Source code in <code>src/pydvl/utils/numeric.py</code> <pre><code>def top_k_value_accuracy(\ny_true: NDArray[np.float_], y_pred: NDArray[np.float_], k: int = 3\n) -&gt; float:\n\"\"\"Computes the top-k accuracy for the estimated values by comparing indices\n    of the highest k values.\n    Args:\n        y_true: Exact/true value\n        y_pred: Predicted/estimated value\n        k: Number of the highest values taken into account\n    Returns:\n        Accuracy\n    \"\"\"\ntop_k_exact_values = np.argsort(y_true)[-k:]\ntop_k_pred_values = np.argsort(y_pred)[-k:]\ntop_k_accuracy = len(np.intersect1d(top_k_exact_values, top_k_pred_values)) / k\nreturn top_k_accuracy\n</code></pre>"},{"location":"code-reference/pydvl/utils/progress/","title":"progress","text":""},{"location":"code-reference/pydvl/utils/progress/#pydvl.utils.progress.MockProgress","title":"<code>MockProgress(iterator)</code>","text":"<p>             Bases: <code>Iterator</code></p> <p>A Naive mock class to use with maybe_progress and tqdm. Mocked methods don't support return values. Mocked properties don't do anything</p> Source code in <code>src/pydvl/utils/progress.py</code> <pre><code>def __init__(self, iterator: Union[Iterator, Iterable]):\n# Since there is no _it in __dict__ at this point, doing here\n# self._it = iterator\n# results in a call to __getattr__() and the assignment fails, so we\n# use __dict__ instead\nself.__dict__[\"_it\"] = iterator\n</code></pre>"},{"location":"code-reference/pydvl/utils/progress/#pydvl.utils.progress.maybe_progress","title":"<code>maybe_progress(it, display=False, **kwargs)</code>","text":"<p>Returns either a tqdm progress bar or a mock object which wraps the iterator as well, but ignores any accesses to methods or properties.</p> PARAMETER  DESCRIPTION <code>it</code> <p>the iterator to wrap</p> <p> TYPE: <code>Union[int, Iterable, Iterator]</code> </p> <code>display</code> <p>set to True to return a tqdm bar</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>kwargs</code> <p>Keyword arguments that will be forwarded to tqdm</p> <p> TYPE: <code>dict</code> DEFAULT: <code>{}</code> </p> Source code in <code>src/pydvl/utils/progress.py</code> <pre><code>def maybe_progress(\nit: Union[int, Iterable, Iterator], display: bool = False, **kwargs: dict\n) -&gt; Union[tqdm, MockProgress]:\n\"\"\"Returns either a tqdm progress bar or a mock object which wraps the\n    iterator as well, but ignores any accesses to methods or properties.\n    Args:\n        it: the iterator to wrap\n        display: set to True to return a tqdm bar\n        kwargs: Keyword arguments that will be forwarded to tqdm\n    \"\"\"\nif isinstance(it, int):\nit = range(it)  # type: ignore\nreturn tqdm(it, **kwargs) if display else MockProgress(it)\n</code></pre>"},{"location":"code-reference/pydvl/utils/score/","title":"score","text":"<p>This module provides a Scorer class that wraps scoring functions with additional information.</p> <p>Scorers can be constructed in the same way as in scikit-learn: either from  known strings or from a callable. Greater values must be better. If they are not, a negated version can be used, see scikit-learn's make_scorer().</p> <p>Scorer provides additional information about the scoring function, like its range and default values, which can be used by some data valuation methods (like group_testing_shapley()) to estimate the number of samples required for a certain quality of approximation.</p>"},{"location":"code-reference/pydvl/utils/score/#pydvl.utils.score.squashed_r2","title":"<code>squashed_r2 = compose_score(Scorer('r2'), _sigmoid, (0, 1), 'squashed r2')</code>  <code>module-attribute</code>","text":"<p>A scorer that squashes the R\u00b2 score into the range [0, 1] using a sigmoid.</p>"},{"location":"code-reference/pydvl/utils/score/#pydvl.utils.score.squashed_variance","title":"<code>squashed_variance = compose_score(Scorer('explained_variance'), _sigmoid, (0, 1), 'squashed explained variance')</code>  <code>module-attribute</code>","text":"<p>A scorer that squashes the explained variance score into the range [0, 1] using a sigmoid.</p>"},{"location":"code-reference/pydvl/utils/score/#pydvl.utils.score.ScorerCallable","title":"<code>ScorerCallable</code>","text":"<p>             Bases: <code>Protocol</code></p> <p>Signature for a scorer</p>"},{"location":"code-reference/pydvl/utils/score/#pydvl.utils.score.Scorer","title":"<code>Scorer(scoring, default=np.nan, range=(-np.inf, np.inf), name=None)</code>","text":"<p>A scoring callable that takes a model, data, and labels and returns a scalar.</p> PARAMETER  DESCRIPTION <code>scoring</code> <p>Either a string or callable that can be passed to get_scorer.</p> <p> TYPE: <code>Union[str, ScorerCallable]</code> </p> <code>default</code> <p>score to be used when a model cannot be fit, e.g. when too little data is passed, or errors arise.</p> <p> TYPE: <code>float</code> DEFAULT: <code>nan</code> </p> <code>range</code> <p>numerical range of the score function. Some Monte Carlo methods can use this to estimate the number of samples required for a certain quality of approximation. If not provided, it can be read from the <code>scoring</code> object if it provides it, for instance if it was constructed with compose_score().</p> <p> TYPE: <code>Tuple</code> DEFAULT: <code>(-inf, inf)</code> </p> <code>name</code> <p>The name of the scorer. If not provided, the name of the function passed will be used.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <p>New in version 0.5.0</p> Source code in <code>src/pydvl/utils/score.py</code> <pre><code>def __init__(\nself,\nscoring: Union[str, ScorerCallable],\ndefault: float = np.nan,\nrange: Tuple = (-np.inf, np.inf),\nname: Optional[str] = None,\n):\nif name is None and isinstance(scoring, str):\nname = scoring\nself._scorer = get_scorer(scoring)\nself.default = default\n# TODO: auto-fill from known scorers ?\nself.range = np.array(range)\nself._name = getattr(self._scorer, \"__name__\", name or \"scorer\")\n</code></pre>"},{"location":"code-reference/pydvl/utils/score/#pydvl.utils.score.compose_score","title":"<code>compose_score(scorer, transformation, range, name)</code>","text":"<p>Composes a scoring function with an arbitrary scalar transformation.</p> <p>Useful to squash unbounded scores into ranges manageable by data valuation methods.</p> <p>Example:</p> <pre><code>sigmoid = lambda x: 1/(1+np.exp(-x))\ncompose_score(Scorer(\"r2\"), sigmoid, range=(0,1), name=\"squashed r2\")\n</code></pre> PARAMETER  DESCRIPTION <code>scorer</code> <p>The object to be composed.</p> <p> TYPE: <code>Scorer</code> </p> <code>transformation</code> <p>A scalar transformation</p> <p> TYPE: <code>Callable[[float], float]</code> </p> <code>range</code> <p>The range of the transformation. This will be used e.g. by Utility for the range of the composed.</p> <p> TYPE: <code>Tuple[float, float]</code> </p> <code>name</code> <p>A string representation for the composition, for <code>str()</code>.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Scorer</code> <p>The composite Scorer.</p> Source code in <code>src/pydvl/utils/score.py</code> <pre><code>def compose_score(\nscorer: Scorer,\ntransformation: Callable[[float], float],\nrange: Tuple[float, float],\nname: str,\n) -&gt; Scorer:\n\"\"\"Composes a scoring function with an arbitrary scalar transformation.\n    Useful to squash unbounded scores into ranges manageable by data valuation\n    methods.\n    Example:\n    ```python\n    sigmoid = lambda x: 1/(1+np.exp(-x))\n    compose_score(Scorer(\"r2\"), sigmoid, range=(0,1), name=\"squashed r2\")\n    ```\n    Args:\n        scorer: The object to be composed.\n        transformation: A scalar transformation\n        range: The range of the transformation. This will be used e.g. by\n            [Utility][pydvl.utils.utility.Utility] for the range of the composed.\n        name: A string representation for the composition, for `str()`.\n    Returns:\n        The composite [Scorer][pydvl.utils.score.Scorer].\n    \"\"\"\nclass CompositeScorer(Scorer):\ndef __call__(self, model: SupervisedModel, X: NDArray, y: NDArray) -&gt; float:\nscore = self._scorer(model=model, X=X, y=y)\nreturn transformation(score)\nreturn CompositeScorer(scorer, range=range, name=name)\n</code></pre>"},{"location":"code-reference/pydvl/utils/status/","title":"status","text":""},{"location":"code-reference/pydvl/utils/status/#pydvl.utils.status.Status","title":"<code>Status</code>","text":"<p>             Bases: <code>Enum</code></p> <p>Status of a computation.</p> <p>Statuses can be combined using bitwise or (<code>|</code>) and bitwise and (<code>&amp;</code>) to get the status of a combined computation. For example, if we have two computations, one that has converged and one that has failed, then the combined status is <code>Status.Converged | Status.Failed == Status.Converged</code>, but <code>Status.Converged &amp; Status.Failed == Status.Failed</code>.</p> <p>:OR:</p> <p>The result of bitwise or-ing two valuation statuses with <code>|</code> is given by the following table:</p> <p>+---+---+---+---+ |   | P | C | F | +===+===+===+===+ | P | P | C | P | +---+---+---+---+ | C | C | C | C | +---+---+---+---+ | F | P | C | F | +---+---+---+---+</p> <p>where P = Pending, C = Converged, F = Failed.</p> <p>:AND:</p> <p>The result of bitwise and-ing two valuation statuses with <code>&amp;</code> is given by the following table:</p> <p>+---+---+---+---+ |   | P | C | F | +===+===+===+===+ | P | P | P | F | +---+---+---+---+ | C | P | C | F | +---+---+---+---+ | F | F | F | F | +---+---+---+---+</p> <p>where P = Pending, C = Converged, F = Failed.</p> <p>:NOT:</p> <p>The result of bitwise negation of a Status with <code>~</code> is <code>Failed</code> if the status is <code>Converged</code>, or <code>Converged</code> otherwise:</p> <pre><code>~P == C, ~C == F, ~F == C\n</code></pre> <p>:Boolean casting:</p> <p>A Status evaluates to <code>True</code> iff it's <code>Converged</code> or <code>Failed</code>:</p> <pre><code>bool(Status.Pending) == False\nbool(Status.Converged) == True\nbool(Status.Failed) == True\n</code></pre> <p>Warning</p> <p>These truth values are inconsistent with the usual boolean operations. In particular the XOR of two instances of <code>Status</code> is not the same as the XOR of their boolean values.</p>"},{"location":"code-reference/pydvl/utils/types/","title":"types","text":"<p>This module contains types, protocols, decorators and generic function transformations. Some of it probably belongs elsewhere.</p>"},{"location":"code-reference/pydvl/utils/types/#pydvl.utils.types.SupervisedModel","title":"<code>SupervisedModel</code>","text":"<p>             Bases: <code>Protocol</code></p> <p>This is the minimal Protocol that valuation methods require from models in order to work.</p> <p>All that is needed are the standard sklearn methods <code>fit()</code>, <code>predict()</code> and <code>score()</code>.</p>"},{"location":"code-reference/pydvl/utils/types/#pydvl.utils.types.maybe_add_argument","title":"<code>maybe_add_argument(fun, new_arg)</code>","text":"<p>Wraps a function to accept the given keyword parameter if it doesn't already.</p> <p>If <code>fun</code> already takes a keyword parameter of name <code>new_arg</code>, then it is returned as is. Otherwise, a wrapper is returned which merely ignores the argument.</p> <pre><code>fun: The function to wrap\nnew_arg: The name of the argument that the new function will accept\n    (and ignore).\n</code></pre> RETURNS DESCRIPTION <code>Callable</code> <p>A new function accepting one more keyword argument.</p> Source code in <code>src/pydvl/utils/types.py</code> <pre><code>def maybe_add_argument(fun: Callable, new_arg: str) -&gt; Callable:\n\"\"\"Wraps a function to accept the given keyword parameter if it doesn't\n    already.\n    If `fun` already takes a keyword parameter of name `new_arg`, then it is\n    returned as is. Otherwise, a wrapper is returned which merely ignores the\n    argument.\n        fun: The function to wrap\n        new_arg: The name of the argument that the new function will accept\n            (and ignore).\n    Returns:\n        A new function accepting one more keyword argument.\n    \"\"\"\nparams = inspect.signature(fun).parameters\nif new_arg in params.keys():\nreturn fun\ndef wrapper(*args, **kwargs):\ntry:\ndel kwargs[new_arg]\nexcept KeyError:\npass\nreturn fun(*args, **kwargs)\nreturn wrapper\n</code></pre>"},{"location":"code-reference/pydvl/utils/utility/","title":"utility","text":"<p>This module contains classes to manage and learn utility functions for the computation of values. Please see the documentation on Computing Data Values for more information.</p> <p>Utility holds information about model, data and scoring function (the latter being what one usually understands under utility in the general definition of Shapley value). It is automatically cached across machines.</p> <p>DataUtilityLearning adds support for learning the scoring function to avoid repeated re-training of the model to compute the score.</p> <p>This module also contains Utility classes for toy games that are used for testing and for demonstration purposes.</p>"},{"location":"code-reference/pydvl/utils/utility/#pydvl.utils.utility.Utility","title":"<code>Utility(model, data, scorer=None, *, default_score=0.0, score_range=(-np.inf, np.inf), catch_errors=True, show_warnings=False, enable_cache=False, cache_options=None, clone_before_fit=True)</code>","text":"<p>Convenience wrapper with configurable memoization of the scoring function.</p> <p>An instance of <code>Utility</code> holds the triple of model, dataset and scoring function which determines the value of data points. This is mosly used for the computation of Shapley Values and Core Values.</p> <p>The Utility expect the model to fulfill the SupervisedModel interface i.e. to have <code>fit()</code>, <code>predict()</code>, and <code>score()</code> methods.</p> <p>When calling the utility, the model will be cloned if it is a Sci-Kit Learn model, otherwise a copy is created using <code>deepcopy()</code> from the builtin copy module.</p> <p>Since evaluating the scoring function requires retraining the model and that can be time-consuming, this class wraps it and caches the results of each execution. Caching is available both locally and across nodes, but must always be enabled for your project first, see Setting up the cache.</p> PARAMETER  DESCRIPTION <code>model</code> <p>Any supervised model. Typical choices can be found at     https://scikit-learn.org/stable/supervised_learning.html</p> <p> TYPE: <code>SupervisedModel</code> </p> <code>data</code> <p>Dataset or GroupedDataset instance.</p> <p> TYPE: <code>Dataset</code> </p> <code>scorer</code> <p>A scoring object. If None, the <code>score()</code> method of the model will be used. See score for ways to create and compose scorers, in particular how to set default values and ranges. For convenience, a string can be passed, which will be used to construct a Scorer.</p> <p> TYPE: <code>Optional[Union[str, Scorer]]</code> DEFAULT: <code>None</code> </p> <code>default_score</code> <p>As a convenience when no <code>scorer</code> object is passed (where a default value can be provided), this argument also allows to set the default score for models that have not been fit, e.g. when too little data is passed, or errors arise.</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.0</code> </p> <code>score_range</code> <p>As with <code>default_score</code>, this is a convenience argument for when no <code>scorer</code> argument is provided, to set the numerical range of the score function. Some Monte Carlo methods can use this to estimate the number of samples required for a certain quality of approximation.</p> <p> TYPE: <code>Tuple[float, float]</code> DEFAULT: <code>(-inf, inf)</code> </p> <code>catch_errors</code> <p>set to <code>True</code> to catch the errors when <code>fit()</code> fails. This could happen in several steps of the pipeline, e.g. when too little training data is passed, which happens often during Shapley value calculations. When this happens, the <code>default_score</code> is returned as a score and computation continues.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>show_warnings</code> <p>Set to <code>False</code> to suppress warnings thrown by <code>fit()</code>.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>enable_cache</code> <p>If <code>True</code>, use memcached for memoization.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>cache_options</code> <p>Optional configuration object for memcached.</p> <p> TYPE: <code>Optional[MemcachedConfig]</code> DEFAULT: <code>None</code> </p> <code>clone_before_fit</code> <p>If <code>True</code>, the model will be cloned before calling <code>fit()</code>.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pydvl.utils import Utility, DataUtilityLearning, Dataset\n&gt;&gt;&gt; from sklearn.linear_model import LinearRegression, LogisticRegression\n&gt;&gt;&gt; from sklearn.datasets import load_iris\n&gt;&gt;&gt; dataset = Dataset.from_sklearn(load_iris(), random_state=16)\n&gt;&gt;&gt; u = Utility(LogisticRegression(random_state=16), dataset)\n&gt;&gt;&gt; u(dataset.indices)\n0.9\n</code></pre> Source code in <code>src/pydvl/utils/utility.py</code> <pre><code>def __init__(\nself,\nmodel: SupervisedModel,\ndata: Dataset,\nscorer: Optional[Union[str, Scorer]] = None,\n*,\ndefault_score: float = 0.0,\nscore_range: Tuple[float, float] = (-np.inf, np.inf),\ncatch_errors: bool = True,\nshow_warnings: bool = False,\nenable_cache: bool = False,\ncache_options: Optional[MemcachedConfig] = None,\nclone_before_fit: bool = True,\n):\nself.model = self._clone_model(model)\nself.data = data\nif isinstance(scorer, str):\nscorer = Scorer(scorer, default=default_score, range=score_range)\nself.scorer = check_scoring(self.model, scorer)\nself.default_score = scorer.default if scorer is not None else default_score\n# TODO: auto-fill from known scorers ?\nself.score_range = scorer.range if scorer is not None else np.array(score_range)\nself.catch_errors = catch_errors\nself.show_warnings = show_warnings\nself.enable_cache = enable_cache\nself.cache_options: MemcachedConfig = cache_options or MemcachedConfig()\nself.clone_before_fit = clone_before_fit\nself._signature = serialize((hash(self.model), hash(data), hash(scorer)))\nself._initialize_utility_wrapper()\n</code></pre>"},{"location":"code-reference/pydvl/utils/utility/#pydvl.utils.utility.Utility.signature","title":"<code>signature</code>  <code>property</code>","text":"<p>Signature used for caching model results.</p>"},{"location":"code-reference/pydvl/utils/utility/#pydvl.utils.utility.Utility.cache_stats","title":"<code>cache_stats: Optional[CacheStats]</code>  <code>property</code>","text":"<p>Cache statistics are gathered when cache is enabled. See CacheStats for all fields returned.</p>"},{"location":"code-reference/pydvl/utils/utility/#pydvl.utils.utility.Utility.__call__","title":"<code>__call__(indices)</code>","text":"PARAMETER  DESCRIPTION <code>indices</code> <p>a subset of valid indices for the <code>x_train</code> attribute of Dataset.</p> <p> TYPE: <code>Iterable[int]</code> </p> Source code in <code>src/pydvl/utils/utility.py</code> <pre><code>def __call__(self, indices: Iterable[int]) -&gt; float:\n\"\"\"\n    Args:\n        indices: a subset of valid indices for the\n            `x_train` attribute of [Dataset][pydvl.utils.dataset.Dataset].\n    \"\"\"\nutility: float = self._utility_wrapper(frozenset(indices))\nreturn utility\n</code></pre>"},{"location":"code-reference/pydvl/utils/utility/#pydvl.utils.utility.DataUtilityLearning","title":"<code>DataUtilityLearning(u, training_budget, model)</code>","text":"<p>Implementation of Data Utility Learning [@wang_improving_2022].</p> <p>This object wraps a Utility and delegates calls to it, up until a given budget (number of iterations). Every tuple of input and output (a so-called utility sample) is stored. Once the budget is exhausted, <code>DataUtilityLearning</code> fits the given model to the utility samples. Subsequent calls will use the learned model to predict the utility instead of delegating.</p> PARAMETER  DESCRIPTION <code>u</code> <p>The Utility to learn.</p> <p> TYPE: <code>Utility</code> </p> <code>training_budget</code> <p>Number of utility samples to collect before fitting the given model.</p> <p> TYPE: <code>int</code> </p> <code>model</code> <p>A supervised regression model</p> <p> TYPE: <code>SupervisedModel</code> </p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pydvl.utils import Utility, DataUtilityLearning, Dataset\n&gt;&gt;&gt; from sklearn.linear_model import LinearRegression, LogisticRegression\n&gt;&gt;&gt; from sklearn.datasets import load_iris\n&gt;&gt;&gt; dataset = Dataset.from_sklearn(load_iris())\n&gt;&gt;&gt; u = Utility(LogisticRegression(), dataset)\n&gt;&gt;&gt; wrapped_u = DataUtilityLearning(u, 3, LinearRegression())\n... # First 3 calls will be computed normally\n&gt;&gt;&gt; for i in range(3):\n...     _ = wrapped_u((i,))\n&gt;&gt;&gt; wrapped_u((1, 2, 3)) # Subsequent calls will be computed using the fit model for DUL\n0.0\n</code></pre> Source code in <code>src/pydvl/utils/utility.py</code> <pre><code>def __init__(\nself, u: Utility, training_budget: int, model: SupervisedModel\n) -&gt; None:\nself.utility = u\nself.training_budget = training_budget\nself.model = model\nself._current_iteration = 0\nself._is_model_fit = False\nself._utility_samples: Dict[FrozenSet, Tuple[NDArray[np.bool_], float]] = {}\n</code></pre>"},{"location":"code-reference/pydvl/utils/utility/#pydvl.utils.utility.DataUtilityLearning.data","title":"<code>data: Dataset</code>  <code>property</code>","text":"<p>Returns the wrapped utility's Dataset.</p>"},{"location":"code-reference/pydvl/utils/utility/#pydvl.utils.utility.MinerGameUtility","title":"<code>MinerGameUtility(n_miners, **kwargs)</code>","text":"<p>             Bases: <code>Utility</code></p> <p>Toy game utility that is used for testing and demonstration purposes.</p> <p>Consider a group of n miners, who have discovered large bars of gold.</p> <p>If two miners can carry one piece of gold, then the payoff of a coalition \\(S\\) is:</p> \\[{ v(S) = \\left\\{\\begin{array}{lll} \\mid S \\mid / 2 &amp; \\text{, if} &amp; \\mid S \\mid \\text{ is even} \\\\ ( \\mid S \\mid - 1)/2 &amp; \\text{, if} &amp; \\mid S \\mid \\text{ is odd} \\end{array}\\right. }\\] <p>If there are more than two miners and there is an even number of miners, then the core consists of the single payoff where each miner gets 1/2.</p> <p>If there is an odd number of miners, then the core is empty.</p> <p>Taken from Wikipedia</p> PARAMETER  DESCRIPTION <code>n_miners</code> <p>Number of miners that participate in the game.</p> <p> TYPE: <code>int</code> </p> Source code in <code>src/pydvl/utils/utility.py</code> <pre><code>def __init__(self, n_miners: int, **kwargs):\nif n_miners &lt;= 2:\nraise ValueError(f\"n_miners, {n_miners} should be &gt; 2\")\nself.n_miners = n_miners\nx = np.arange(n_miners)[..., np.newaxis]\n# The y values don't matter here\ny = np.zeros_like(x)\nself.data = Dataset(x_train=x, y_train=y, x_test=x, y_test=y)\n</code></pre>"},{"location":"code-reference/pydvl/utils/utility/#pydvl.utils.utility.GlovesGameUtility","title":"<code>GlovesGameUtility(left, right, **kwargs)</code>","text":"<p>             Bases: <code>Utility</code></p> <p>Toy game utility that is used for testing and demonstration purposes.</p> <p>In this game, some players have a left glove and others a right glove. Single gloves have a worth of zero while pairs have a worth of 1.</p> <p>The payoff of a coalition \\(S\\) is:</p> \\[{ v(S) = \\min( \\mid S \\cap L \\mid, \\mid S \\cap R \\mid ) }\\] <p>Where \\(L\\), respectively \\(R\\), is the set of players with left gloves, respectively right gloves.</p> PARAMETER  DESCRIPTION <code>left</code> <p>Number of players with a left glove.</p> <p> TYPE: <code>int</code> </p> <code>right</code> <p>Number of player with a right glove.</p> <p> TYPE: <code>int</code> </p> Source code in <code>src/pydvl/utils/utility.py</code> <pre><code>def __init__(self, left: int, right: int, **kwargs):\nself.left = left\nself.right = right\nx = np.empty(left + right)[..., np.newaxis]\n# The y values don't matter here\ny = np.zeros_like(x)\nself.data = Dataset(x_train=x, y_train=y, x_test=x, y_test=y)\n</code></pre>"},{"location":"code-reference/pydvl/utils/parallel/","title":"parallel","text":""},{"location":"code-reference/pydvl/utils/parallel/backend/","title":"backend","text":""},{"location":"code-reference/pydvl/utils/parallel/backend/#pydvl.utils.parallel.backend.NoPublicConstructor","title":"<code>NoPublicConstructor</code>","text":"<p>             Bases: <code>ABCMeta</code></p> <p>Metaclass that ensures a private constructor</p> If a class uses this metaclass like this <p>class SomeClass(metaclass=NoPublicConstructor):     pass</p> <p>If you try to instantiate your class (<code>SomeClass()</code>), a <code>TypeError</code> will be thrown.</p> <p>Taken almost verbatim from: https://stackoverflow.com/a/64682734</p>"},{"location":"code-reference/pydvl/utils/parallel/backend/#pydvl.utils.parallel.backend.BaseParallelBackend","title":"<code>BaseParallelBackend</code>","text":"<p>Abstract base class for all parallel backends</p>"},{"location":"code-reference/pydvl/utils/parallel/backend/#pydvl.utils.parallel.backend.JoblibParallelBackend","title":"<code>JoblibParallelBackend(config)</code>","text":"<p>             Bases: <code>BaseParallelBackend</code></p> <p>Class used to wrap joblib to make it transparent to algorithms.</p> <p>It shouldn't be initialized directly. You should instead call init_parallel_backend().</p> PARAMETER  DESCRIPTION <code>config</code> <p>instance of ParallelConfig with cluster address, number of cpus, etc.</p> <p> TYPE: <code>ParallelConfig</code> </p> Source code in <code>src/pydvl/utils/parallel/backend.py</code> <pre><code>def __init__(self, config: ParallelConfig):\nself.config = {\n\"logging_level\": config.logging_level,\n\"n_jobs\": config.n_cpus_local,\n}\n</code></pre>"},{"location":"code-reference/pydvl/utils/parallel/backend/#pydvl.utils.parallel.backend.JoblibParallelBackend.wrap","title":"<code>wrap(fun, **kwargs)</code>","text":"<p>Wraps a function as a joblib delayed.</p> PARAMETER  DESCRIPTION <code>fun</code> <p>the function to wrap</p> <p> TYPE: <code>Callable</code> </p> RETURNS DESCRIPTION <code>Callable</code> <p>The delayed function.</p> Source code in <code>src/pydvl/utils/parallel/backend.py</code> <pre><code>def wrap(self, fun: Callable, **kwargs) -&gt; Callable:\n\"\"\"Wraps a function as a joblib delayed.\n    Args:\n        fun: the function to wrap\n    Returns:\n        The delayed function.\n    \"\"\"\nreturn delayed(fun)  # type: ignore\n</code></pre>"},{"location":"code-reference/pydvl/utils/parallel/backend/#pydvl.utils.parallel.backend.RayParallelBackend","title":"<code>RayParallelBackend(config)</code>","text":"<p>             Bases: <code>BaseParallelBackend</code></p> <p>Class used to wrap ray to make it transparent to algorithms.</p> <p>It shouldn't be initialized directly. You should instead call init_parallel_backend().</p> PARAMETER  DESCRIPTION <code>config</code> <p>instance of ParallelConfig with cluster address, number of cpus, etc.</p> <p> TYPE: <code>ParallelConfig</code> </p> Source code in <code>src/pydvl/utils/parallel/backend.py</code> <pre><code>def __init__(self, config: ParallelConfig):\nself.config = {\"address\": config.address, \"logging_level\": config.logging_level}\nif self.config[\"address\"] is None:\nself.config[\"num_cpus\"] = config.n_cpus_local\nif not ray.is_initialized():\nray.init(**self.config)\n# Register ray joblib backend\nregister_ray()\n</code></pre>"},{"location":"code-reference/pydvl/utils/parallel/backend/#pydvl.utils.parallel.backend.RayParallelBackend.wrap","title":"<code>wrap(fun, **kwargs)</code>","text":"<p>Wraps a function as a ray remote.</p> PARAMETER  DESCRIPTION <code>fun</code> <p>the function to wrap</p> <p> TYPE: <code>Callable</code> </p> <code>kwargs</code> <p>keyword arguments to pass to @ray.remote</p> <p> TYPE: <code>dict</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>Callable</code> <p>The <code>.remote</code> method of the ray <code>RemoteFunction</code>.</p> Source code in <code>src/pydvl/utils/parallel/backend.py</code> <pre><code>def wrap(self, fun: Callable, **kwargs: dict) -&gt; Callable:\n\"\"\"Wraps a function as a ray remote.\n    Args:\n        fun: the function to wrap\n        kwargs: keyword arguments to pass to @ray.remote\n    Returns:\n        The `.remote` method of the ray `RemoteFunction`.\n    \"\"\"\nif len(kwargs) &gt; 0:\nreturn ray.remote(**kwargs)(fun).remote  # type: ignore\nreturn ray.remote(fun).remote  # type: ignore\n</code></pre>"},{"location":"code-reference/pydvl/utils/parallel/backend/#pydvl.utils.parallel.backend.init_parallel_backend","title":"<code>init_parallel_backend(config)</code>","text":"<p>Initializes the parallel backend and returns an instance of it.</p> PARAMETER  DESCRIPTION <code>config</code> <p>instance of ParallelConfig with cluster address, number of cpus, etc.</p> <p> TYPE: <code>ParallelConfig</code> </p> Example <p>from pydvl.utils.parallel.backend import init_parallel_backend from pydvl.utils.config import ParallelConfig config = ParallelConfig() parallel_backend = init_parallel_backend(config) parallel_backend  <p>from pydvl.utils.parallel.backend import init_parallel_backend from pydvl.utils.config import ParallelConfig config = ParallelConfig(backend=\"ray\") parallel_backend = init_parallel_backend(config) parallel_backend  Source code in <code>src/pydvl/utils/parallel/backend.py</code> <pre><code>def init_parallel_backend(\nconfig: ParallelConfig,\n) -&gt; BaseParallelBackend:\n\"\"\"Initializes the parallel backend and returns an instance of it.\n    Args:\n        config: instance of [ParallelConfig][pydvl.utils.config.ParallelConfig]\n            with cluster address, number of cpus, etc.\n    Example:\n        &gt;&gt;&gt; from pydvl.utils.parallel.backend import init_parallel_backend\n        &gt;&gt;&gt; from pydvl.utils.config import ParallelConfig\n        &gt;&gt;&gt; config = ParallelConfig()\n        &gt;&gt;&gt; parallel_backend = init_parallel_backend(config)\n        &gt;&gt;&gt; parallel_backend\n        &lt;JoblibParallelBackend: {'logging_level': 30, 'n_jobs': None}&gt;\n        &gt;&gt;&gt; from pydvl.utils.parallel.backend import init_parallel_backend\n        &gt;&gt;&gt; from pydvl.utils.config import ParallelConfig\n        &gt;&gt;&gt; config = ParallelConfig(backend=\"ray\")\n        &gt;&gt;&gt; parallel_backend = init_parallel_backend(config)\n        &gt;&gt;&gt; parallel_backend\n        &lt;RayParallelBackend: {'address': None, 'logging_level': 30, 'num_cpus': None}&gt;\n    \"\"\"\ntry:\nparallel_backend_cls = _PARALLEL_BACKENDS[config.backend]\nexcept KeyError:\nraise NotImplementedError(f\"Unexpected parallel backend {config.backend}\")\nparallel_backend = parallel_backend_cls._create(config)\nreturn parallel_backend  # type: ignore\n</code></pre>"},{"location":"code-reference/pydvl/utils/parallel/backend/#pydvl.utils.parallel.backend.available_cpus","title":"<code>available_cpus()</code>","text":"<p>Platform-independent count of available cores.</p> <p>FIXME: do we really need this or is <code>os.cpu_count</code> enough? Is this portable?</p> RETURNS DESCRIPTION <code>int</code> <p>Number of cores, or 1 if it is not possible to determine.</p> Source code in <code>src/pydvl/utils/parallel/backend.py</code> <pre><code>def available_cpus() -&gt; int:\n\"\"\"Platform-independent count of available cores.\n    FIXME: do we really need this or is `os.cpu_count` enough? Is this portable?\n    Returns:\n        Number of cores, or 1 if it is not possible to determine.\n    \"\"\"\nfrom platform import system\nif system() != \"Linux\":\nreturn os.cpu_count() or 1\nreturn len(os.sched_getaffinity(0))  # type: ignore\n</code></pre>"},{"location":"code-reference/pydvl/utils/parallel/backend/#pydvl.utils.parallel.backend.effective_n_jobs","title":"<code>effective_n_jobs(n_jobs, config=ParallelConfig())</code>","text":"<p>Returns the effective number of jobs.</p> <p>This number may vary depending on the parallel backend and the resources available.</p> PARAMETER  DESCRIPTION <code>n_jobs</code> <p>the number of jobs requested. If -1, the number of available CPUs is returned.</p> <p> TYPE: <code>int</code> </p> <code>config</code> <p>instance of ParallelConfig with cluster address, number of cpus, etc.</p> <p> TYPE: <code>ParallelConfig</code> DEFAULT: <code>ParallelConfig()</code> </p> RETURNS DESCRIPTION <code>int</code> <p>The effective number of jobs, guaranteed to be &gt;= 1.</p> Source code in <code>src/pydvl/utils/parallel/backend.py</code> <pre><code>def effective_n_jobs(n_jobs: int, config: ParallelConfig = ParallelConfig()) -&gt; int:\n\"\"\"Returns the effective number of jobs.\n    This number may vary depending on the parallel backend and the resources\n    available.\n    Args:\n        n_jobs: the number of jobs requested. If -1, the number of available\n            CPUs is returned.\n        config: instance of [ParallelConfig][pydvl.utils.config.ParallelConfig] with\n            cluster address, number of cpus, etc.\n    Returns:\n        The effective number of jobs, guaranteed to be &gt;= 1.\n    Raises:\n        RuntimeError if the effective number of jobs returned by the backend\n        is &lt; 1.\n    \"\"\"\nparallel_backend = init_parallel_backend(config)\nif (eff_n_jobs := parallel_backend.effective_n_jobs(n_jobs)) &lt; 1:\nraise RuntimeError(\nf\"Invalid number of jobs {eff_n_jobs} obtained from parallel backend {config.backend}\"\n)\nreturn eff_n_jobs\n</code></pre>"},{"location":"code-reference/pydvl/utils/parallel/map_reduce/","title":"map_reduce","text":""},{"location":"code-reference/pydvl/utils/parallel/map_reduce/#pydvl.utils.parallel.map_reduce.MapReduceJob","title":"<code>MapReduceJob(inputs, map_func, reduce_func=identity, map_kwargs=None, reduce_kwargs=None, config=ParallelConfig(), *, n_jobs=-1, timeout=None)</code>","text":"<p>             Bases: <code>Generic[T, R]</code></p> <p>Takes an embarrassingly parallel fun and runs it in <code>n_jobs</code> parallel jobs, splitting the data evenly into a number of chunks equal to the number of jobs.</p> <p>Typing information for objects of this class requires the type of the inputs that are split for <code>map_func</code> and the type of its output.</p> PARAMETER  DESCRIPTION <code>inputs</code> <p>The input that will be split and passed to <code>map_func</code>. if it's not a sequence object. It will be repeat <code>n_jobs</code> number of times.</p> <p> TYPE: <code>Union[Collection[T], T]</code> </p> <code>map_func</code> <p>Function that will be applied to the input chunks in each job.</p> <p> TYPE: <code>MapFunction[R]</code> </p> <code>reduce_func</code> <p>Function that will be applied to the results of <code>map_func</code> to reduce them.</p> <p> TYPE: <code>ReduceFunction[R]</code> DEFAULT: <code>identity</code> </p> <code>map_kwargs</code> <p>Keyword arguments that will be passed to <code>map_func</code> in each job. Alternatively, one can use itertools.partial.</p> <p> TYPE: <code>Optional[Dict]</code> DEFAULT: <code>None</code> </p> <code>reduce_kwargs</code> <p>Keyword arguments that will be passed to <code>reduce_func</code> in each job. Alternatively, one can use itertools.partial.</p> <p> TYPE: <code>Optional[Dict]</code> DEFAULT: <code>None</code> </p> <code>config</code> <p>Instance of ParallelConfig with cluster address, number of cpus, etc.</p> <p> TYPE: <code>ParallelConfig</code> DEFAULT: <code>ParallelConfig()</code> </p> <code>n_jobs</code> <p>Number of parallel jobs to run. Does not accept 0</p> <p> TYPE: <code>int</code> DEFAULT: <code>-1</code> </p> <p>Examples:</p> <p>A simple usage example with 2 jobs:</p> <pre><code>&gt;&gt;&gt; from pydvl.utils.parallel import MapReduceJob\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; map_reduce_job: MapReduceJob[np.ndarray, np.ndarray] = MapReduceJob(\n...     np.arange(5),\n...     map_func=np.sum,\n...     reduce_func=np.sum,\n...     n_jobs=2,\n... )\n&gt;&gt;&gt; map_reduce_job()\n10\n</code></pre> <p>When passed a single object as input, it will be repeated for each job:</p> <pre><code>&gt;&gt;&gt; from pydvl.utils.parallel import MapReduceJob\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; map_reduce_job: MapReduceJob[int, np.ndarray] = MapReduceJob(\n...     5,\n...     map_func=lambda x: np.array([x]),\n...     reduce_func=np.sum,\n...     n_jobs=2,\n... )\n&gt;&gt;&gt; map_reduce_job()\n10\n</code></pre> Source code in <code>src/pydvl/utils/parallel/map_reduce.py</code> <pre><code>def __init__(\nself,\ninputs: Union[Collection[T], T],\nmap_func: MapFunction[R],\nreduce_func: ReduceFunction[R] = identity,\nmap_kwargs: Optional[Dict] = None,\nreduce_kwargs: Optional[Dict] = None,\nconfig: ParallelConfig = ParallelConfig(),\n*,\nn_jobs: int = -1,\ntimeout: Optional[float] = None,\n):\nself.config = config\nparallel_backend = init_parallel_backend(self.config)\nself.parallel_backend = parallel_backend\nself.timeout = timeout\n# This uses the setter defined below\nself.n_jobs = n_jobs\nself.inputs_ = inputs\nself.map_kwargs = map_kwargs if map_kwargs is not None else dict()\nself.reduce_kwargs = reduce_kwargs if reduce_kwargs is not None else dict()\nself._map_func = maybe_add_argument(map_func, \"job_id\")\nself._reduce_func = reduce_func\n</code></pre>"},{"location":"code-reference/pydvl/utils/parallel/map_reduce/#pydvl.utils.parallel.map_reduce.MapReduceJob.n_jobs","title":"<code>n_jobs: int</code>  <code>property</code> <code>writable</code>","text":"<p>Effective number of jobs according to the used ParallelBackend instance.</p>"},{"location":"code-reference/pydvl/utils/parallel/futures/","title":"futures","text":""},{"location":"code-reference/pydvl/utils/parallel/futures/#pydvl.utils.parallel.futures.init_executor","title":"<code>init_executor(max_workers=None, config=ParallelConfig(), **kwargs)</code>","text":"<p>Initializes a futures executor based on the passed parallel configuration object.</p> PARAMETER  DESCRIPTION <code>max_workers</code> <p>Maximum number of concurrent tasks.</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>config</code> <p>instance of ParallelConfig with cluster address, number of cpus, etc.</p> <p> TYPE: <code>ParallelConfig</code> DEFAULT: <code>ParallelConfig()</code> </p> <code>kwargs</code> <p>Other optional parameter that will be passed to the executor.</p> <p> TYPE: <code>dict</code> DEFAULT: <code>{}</code> </p> <p>Examples:</p> <p>from pydvl.utils.parallel.futures import init_executor from pydvl.utils.config import ParallelConfig config = ParallelConfig(backend=\"ray\") with init_executor(max_workers=3, config=config) as executor: ...     pass</p> <p>from pydvl.utils.parallel.futures import init_executor with init_executor() as executor: ...     future = executor.submit(lambda x: x + 1, 1) ...     result = future.result() ... print(result) 2</p> <p>from pydvl.utils.parallel.futures import init_executor with init_executor() as executor: ...     results = list(executor.map(lambda x: x + 1, range(5))) ... print(results) [1, 2, 3, 4, 5]</p> Source code in <code>src/pydvl/utils/parallel/futures/__init__.py</code> <pre><code>@contextmanager\ndef init_executor(\nmax_workers: Optional[int] = None,\nconfig: ParallelConfig = ParallelConfig(),\n**kwargs: dict,\n) -&gt; Generator[Executor, None, None]:\n\"\"\"Initializes a futures executor based on the passed parallel configuration object.\n    Args:\n        max_workers: Maximum number of concurrent tasks.\n        config: instance of [ParallelConfig][pydvl.utils.config.ParallelConfig]\n            with cluster address, number of cpus, etc.\n        kwargs: Other optional parameter that will be passed to the executor.\n    Examples:\n    &gt;&gt;&gt; from pydvl.utils.parallel.futures import init_executor\n    &gt;&gt;&gt; from pydvl.utils.config import ParallelConfig\n    &gt;&gt;&gt; config = ParallelConfig(backend=\"ray\")\n    &gt;&gt;&gt; with init_executor(max_workers=3, config=config) as executor:\n    ...     pass\n    &gt;&gt;&gt; from pydvl.utils.parallel.futures import init_executor\n    &gt;&gt;&gt; with init_executor() as executor:\n    ...     future = executor.submit(lambda x: x + 1, 1)\n    ...     result = future.result()\n    ...\n    &gt;&gt;&gt; print(result)\n    2\n    &gt;&gt;&gt; from pydvl.utils.parallel.futures import init_executor\n    &gt;&gt;&gt; with init_executor() as executor:\n    ...     results = list(executor.map(lambda x: x + 1, range(5)))\n    ...\n    &gt;&gt;&gt; print(results)\n    [1, 2, 3, 4, 5]\n    \"\"\"\nif config.backend == \"ray\":\nwith RayExecutor(max_workers, config=config, **kwargs) as executor:\nyield executor\nelif config.backend == \"joblib\":\nwith get_reusable_executor(max_workers=max_workers, **kwargs) as executor:\nyield executor\nelse:\nraise NotImplementedError(f\"Unexpected parallel type {config.backend}\")\n</code></pre>"},{"location":"code-reference/pydvl/utils/parallel/futures/ray/","title":"ray","text":""},{"location":"code-reference/pydvl/utils/parallel/futures/ray/#pydvl.utils.parallel.futures.ray.RayExecutor","title":"<code>RayExecutor(max_workers=None, *, config=ParallelConfig(), cancel_futures_on_exit=True)</code>","text":"<p>             Bases: <code>Executor</code></p> <p>Asynchronous executor using Ray that implements the concurrent.futures API.</p> <p>It shouldn't be initialized directly. You should instead call init_executor().</p> <pre><code>max_workers: Maximum number of concurrent tasks. Each task can request\n    itself any number of vCPUs. You must ensure the product of this\n    value and the n_cpus_per_job parameter passed to submit() does not\n    exceed available cluster resources. If set to `None`, it will\n    default to the total number of vCPUs in the ray cluster.\nconfig: instance of [ParallelConfig][pydvl.utils.config.ParallelConfig]\n    with cluster address, number of cpus, etc.\ncancel_futures_on_exit: If `True`, all futures will be cancelled\n    when exiting the context created by using this class instance as a\n    context manager. It will be ignored when calling\n    [shutdown()][pydvl.utils.parallel.futures.ray.RayExecutor.shutdown]\n    directly.\n</code></pre> Source code in <code>src/pydvl/utils/parallel/futures/ray.py</code> <pre><code>def __init__(\nself,\nmax_workers: Optional[int] = None,\n*,\nconfig: ParallelConfig = ParallelConfig(),\ncancel_futures_on_exit: bool = True,\n):\nif config.backend != \"ray\":\nraise ValueError(\nf\"Parallel backend must be set to 'ray' and not {config.backend}\"\n)\nif max_workers is not None:\nif max_workers &lt;= 0:\nraise ValueError(\"max_workers must be greater than 0\")\nmax_workers = max_workers\nself.cancel_futures_on_exit = cancel_futures_on_exit\nconfig_dict = asdict(config)\nconfig_dict.pop(\"backend\")\nn_cpus_local = config_dict.pop(\"n_cpus_local\")\nif config_dict.get(\"address\", None) is None:\nconfig_dict[\"num_cpus\"] = n_cpus_local\nself.config = config_dict\nif not ray.is_initialized():\nray.init(**self.config)\nself._max_workers = max_workers\nif self._max_workers is None:\nself._max_workers = int(ray._private.state.cluster_resources()[\"CPU\"])\nself._shutdown = False\nself._cancel_pending_futures = False\nself._shutdown_lock = threading.Lock()\nself._queue_lock = threading.Lock()\nself._work_queue: \"queue.Queue[Optional[_WorkItem]]\" = queue.Queue(\nmaxsize=self._max_workers\n)\nself._pending_queue: \"queue.SimpleQueue[Optional[_WorkItem]]\" = (\nqueue.SimpleQueue()\n)\n# Work Item Manager Thread\nself._work_item_manager_thread: Optional[_WorkItemManagerThread] = None\n</code></pre>"},{"location":"code-reference/pydvl/utils/parallel/futures/ray/#pydvl.utils.parallel.futures.ray.RayExecutor.submit","title":"<code>submit(fn, *args, **kwargs)</code>","text":"<p>Submits a callable to be executed with the given arguments.</p> <p>Schedules the callable to be executed as fn(*args, **kwargs) and returns a Future instance representing the execution of the callable.</p> PARAMETER  DESCRIPTION <code>fn</code> <p>Callable.</p> <p> TYPE: <code>Callable[..., T]</code> </p> <code>args</code> <p>Positional arguments that will be passed to <code>fn</code>.</p> <p> TYPE: <code>list</code> DEFAULT: <code>()</code> </p> <code>kwargs</code> <p>Keyword arguments that will be passed to <code>fn</code>. It can also optionally contain options for the ray remote function as a dictionary as the keyword argument <code>remote_function_options</code>.</p> <p> TYPE: <code>dict</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>Future[T]</code> <p>A Future representing the given call.</p> <p>:raises RuntimeError: If a task is submitted after the executor has been shut down.</p> Source code in <code>src/pydvl/utils/parallel/futures/ray.py</code> <pre><code>def submit(self, fn: Callable[..., T], *args: list, **kwargs: dict) -&gt; \"Future[T]\":\nr\"\"\"Submits a callable to be executed with the given arguments.\n    Schedules the callable to be executed as fn(\\*args, \\**kwargs)\n    and returns a Future instance representing the execution of the callable.\n    Args:\n        fn: Callable.\n        args: Positional arguments that will be passed to `fn`.\n        kwargs: Keyword arguments that will be passed to `fn`.\n            It can also optionally contain options for the ray remote function\n            as a dictionary as the keyword argument `remote_function_options`.\n    Returns:\n        A Future representing the given call.\n    :raises RuntimeError: If a task is submitted after the executor has been shut down.\n    \"\"\"\nwith self._shutdown_lock:\nlogger.debug(\"executor acquired shutdown lock\")\nif self._shutdown:\nraise RuntimeError(\"cannot schedule new futures after shutdown\")\nlogging.debug(\"Creating future and putting work item in work queue\")\nfuture: \"Future[T]\" = Future()\nremote_function_options = kwargs.pop(\"remote_function_options\", None)\nw = _WorkItem(\nfuture,\nfn,\nargs,\nkwargs,\nremote_function_options=remote_function_options,\n)\nself._put_work_item_in_queue(w)\n# We delay starting the thread until the first call to submit\nself._start_work_item_manager_thread()\nreturn future\n</code></pre>"},{"location":"code-reference/pydvl/utils/parallel/futures/ray/#pydvl.utils.parallel.futures.ray.RayExecutor.__exit__","title":"<code>__exit__(exc_type, exc_val, exc_tb)</code>","text":"<p>Exit the runtime context related to the RayExecutor object.</p> <p>This explicitly sets cancel_futures to be equal to cancel_futures_on_exit attribute set at instantiation time in the call to the <code>shutdown()</code> method which is different from the base Executor class' exit method.</p> Source code in <code>src/pydvl/utils/parallel/futures/ray.py</code> <pre><code>def __exit__(self, exc_type, exc_val, exc_tb):\n\"\"\"Exit the runtime context related to the RayExecutor object.\n    This explicitly sets cancel_futures to be equal to cancel_futures_on_exit\n    attribute set at instantiation time in the call to the `shutdown()` method\n    which is different from the base Executor class' __exit__ method.\n    \"\"\"\nself.shutdown(cancel_futures=self.cancel_futures_on_exit)\nreturn False\n</code></pre>"},{"location":"code-reference/pydvl/value/","title":"value","text":"<p>This module implements algorithms for the exact and approximate computation of values and semi-values.</p> <p>See Data valuation for an introduction to the concepts and methods implemented here.</p>"},{"location":"code-reference/pydvl/value/result/","title":"result","text":"<p>This module collects types and methods for the inspection of the results of valuation algorithms.</p> <p>The most important class is ValuationResult, which provides access to raw values, as well as convenient behaviour as a <code>Sequence</code> with extended indexing and updating abilities, and conversion to <code>pandas DataFrames &lt;https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.html&gt;</code>_.</p>"},{"location":"code-reference/pydvl/value/result/#pydvl.value.result--operating-on-results","title":"Operating on results","text":"<p>Results can be added together with the standard <code>+</code> operator. Because values are typically running averages of iterative algorithms, addition behaves like a weighted average of the two results, with the weights being the number of updates in each result: adding two results is the same as generating one result with the mean of the values of the two results as values. The variances are updated accordingly. See ValuationResult for details.</p> <p>Results can also be sorted by value, variance or number of updates, see sort(). The arrays of ValuationResult.values, ValuationResult.variances, ValuationResult.counts, ValuationResult.indices, ValuationResult.names are sorted in the same way.</p> <p>Indexing and slicing of results is supported and ValueItem objects are returned. These objects can be compared with the usual operators, which take only the ValueItem.value into account.</p>"},{"location":"code-reference/pydvl/value/result/#pydvl.value.result--creating-result-objects","title":"Creating result objects","text":"<p>The most commonly used factory method is ValuationResult.zeros(), which creates a result object with all values, variances and counts set to zero. ValuationResult.empty() creates an empty result object, which can be used as a starting point for adding results together. Empty results are discarded when added to other results. Finally, ValuationResult.from_random() samples random values uniformly.</p>"},{"location":"code-reference/pydvl/value/result/#pydvl.value.result.ValueItem","title":"<code>ValueItem</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Generic[IndexT, NameT]</code></p> <p>The result of a value computation for one datum.</p> <p><code>ValueItems</code> can be compared with the usual operators, forming a total order. Comparisons take only the <code>value</code> into account.</p> <p>Todo</p> <p>Maybe have a mode of comparing similar to <code>np.isclose</code>, or taking the <code>variance</code> into account.</p> ATTRIBUTE DESCRIPTION <code>index</code> <p>Index of the sample with this value in the original Dataset</p> <p> TYPE: <code>IndexT</code> </p> <code>name</code> <p>Name of the sample if it was provided. Otherwise, <code>str(index)</code></p> <p> TYPE: <code>NameT</code> </p> <code>value</code> <p>The value</p> <p> TYPE: <code>float</code> </p> <code>variance</code> <p>Variance of the value if it was computed with an approximate method</p> <p> TYPE: <code>Optional[float]</code> </p> <code>count</code> <p>Number of updates for this value</p> <p> TYPE: <code>Optional[int]</code> </p>"},{"location":"code-reference/pydvl/value/result/#pydvl.value.result.ValueItem.stderr","title":"<code>stderr: Optional[float]</code>  <code>property</code>","text":"<p>Standard error of the value.</p>"},{"location":"code-reference/pydvl/value/result/#pydvl.value.result.ValuationResult","title":"<code>ValuationResult(*, values, variances=None, counts=None, indices=None, data_names=None, algorithm='', status=Status.Pending, sort=False, **extra_values)</code>","text":"<p>             Bases: <code>Sequence</code>, <code>Iterable[ValueItem[IndexT, NameT]]</code>, <code>Generic[IndexT, NameT]</code></p> <p>Objects of this class hold the results of valuation algorithms.</p> <p>These include indices in the original Dataset, any data names (e.g. group names in GroupedDataset), the values themselves, and variance of the computation in the case of Monte Carlo methods. <code>ValuationResults</code> can be iterated over like any <code>Sequence</code>: <code>iter(valuation_result)</code> returns a generator of ValueItem in the order in which the object is sorted.</p>"},{"location":"code-reference/pydvl/value/result/#pydvl.value.result.ValuationResult--indexing","title":"Indexing","text":"<p>Indexing can be position-based, when accessing any of the attributes values, variances, counts and indices, as well as when iterating over the object, or using the item access operator, both getter and setter. The \"position\" is either the original sequence in which the data was passed to the constructor, or the sequence in which the object is sorted, see below.</p> <p>Alternatively, indexing can be data-based, i.e. using the indices in the original dataset. This is the case for the methods get() and update().</p>"},{"location":"code-reference/pydvl/value/result/#pydvl.value.result.ValuationResult--sorting","title":"Sorting","text":"<p>Results can be sorted in-place with sort(), or alternatively using python's standard <code>sorted()</code> and <code>reversed()</code> Note that sorting values affects how iterators and the object itself as <code>Sequence</code> behave: <code>values[0]</code> returns a ValueItem with the highest or lowest ranking point if this object is sorted by descending or ascending value, respectively. If unsorted, <code>values[0]</code> returns the <code>ValueItem</code> at position 0, which has data index <code>indices[0]</code> in the Dataset.</p> <p>The same applies to direct indexing of the <code>ValuationResult</code>: the index is positional, according to the sorting. It does not refer to the \"data index\". To sort according to data index, use sort() with <code>key=\"index\"</code>.</p> <p>In order to access ValueItem objects by their data index, use get().</p>"},{"location":"code-reference/pydvl/value/result/#pydvl.value.result.ValuationResult--operating-on-results","title":"Operating on results","text":"<p>Results can be added to each other with the <code>+</code> operator. Means and variances are correctly updated, using the <code>counts</code> attribute.</p> <p>Results can also be updated with new values using update(). Means and variances are updated accordingly using the Welford algorithm.</p> <p>Empty objects behave in a special way, see empty().</p> PARAMETER  DESCRIPTION <code>values</code> <p>An array of values. If omitted, defaults to an empty array or to an array of zeros if <code>indices</code> are given.</p> <p> TYPE: <code>NDArray[numpy.float_]</code> </p> <code>indices</code> <p>An optional array of indices in the original dataset. If omitted, defaults to <code>np.arange(len(values))</code>. Warning: It is common to pass the indices of a Dataset here. Attention must be paid in a parallel context to copy them to the local process. Just do <code>indices=np.copy(data.indices)</code>.</p> <p> TYPE: <code>Optional[NDArray[IndexT]]</code> DEFAULT: <code>None</code> </p> <code>variances</code> <p>An optional array of variances in the computation of each value.</p> <p> TYPE: <code>Optional[NDArray[numpy.float_]]</code> DEFAULT: <code>None</code> </p> <code>counts</code> <p>An optional array with the number of updates for each value. Defaults to an array of ones.</p> <p> TYPE: <code>Optional[NDArray[numpy.int_]]</code> DEFAULT: <code>None</code> </p> <code>data_names</code> <p>Names for the data points. Defaults to index numbers if not set.</p> <p> TYPE: <code>Optional[Sequence[NameT] | NDArray[NameT]]</code> DEFAULT: <code>None</code> </p> <code>algorithm</code> <p>The method used.</p> <p> TYPE: <code>str</code> DEFAULT: <code>''</code> </p> <code>status</code> <p>The end status of the algorithm.</p> <p> TYPE: <code>Status</code> DEFAULT: <code>Pending</code> </p> <code>sort</code> <p>Whether to sort the indices by ascending value. See above how this affects usage as an iterable or sequence.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>extra_values</code> <p>Additional values that can be passed as keyword arguments. This can contain, for example, the least core value.</p> <p> TYPE: <code>dict</code> DEFAULT: <code>{}</code> </p> <p>:raise ValueError: If input arrays have mismatching lengths.</p> Source code in <code>src/pydvl/value/result.py</code> <pre><code>def __init__(\nself,\n*,\nvalues: NDArray[np.float_],\nvariances: Optional[NDArray[np.float_]] = None,\ncounts: Optional[NDArray[np.int_]] = None,\nindices: Optional[NDArray[IndexT]] = None,\ndata_names: Optional[Sequence[NameT] | NDArray[NameT]] = None,\nalgorithm: str = \"\",\nstatus: Status = Status.Pending,\nsort: bool = False,\n**extra_values: dict,\n):\nif variances is not None and len(variances) != len(values):\nraise ValueError(\"Lengths of values and variances do not match\")\nif data_names is not None and len(data_names) != len(values):\nraise ValueError(\"Lengths of values and data_names do not match\")\nif indices is not None and len(indices) != len(values):\nraise ValueError(\"Lengths of values and indices do not match\")\nself._algorithm = algorithm\nself._status = Status(status)  # Just in case we are given a string\nself._values = values\nself._variances = np.zeros_like(values) if variances is None else variances\nself._counts = np.ones_like(values) if counts is None else counts\nself._sort_order = None\nself._extra_values = extra_values or {}\n# Yuk...\nif data_names is None:\nif indices is not None:\nself._names = np.copy(indices)\nelse:\nself._names = np.arange(len(self._values), dtype=np.int_)\nelif not isinstance(data_names, np.ndarray):\nself._names = np.array(data_names)\nelse:\nself._names = data_names.copy()\nif len(np.unique(self._names)) != len(self._names):\nraise ValueError(\"Data names must be unique\")\nif indices is None:\nindices = np.arange(len(self._values), dtype=np.int_)\nself._indices = indices\nself._positions = {idx: pos for pos, idx in enumerate(indices)}\nself._sort_positions: NDArray[np.int_] = np.arange(\nlen(self._values), dtype=np.int_\n)\nif sort:\nself.sort()\n</code></pre>"},{"location":"code-reference/pydvl/value/result/#pydvl.value.result.ValuationResult.values","title":"<code>values: NDArray[np.float_]</code>  <code>property</code>","text":"<p>The values, possibly sorted.</p>"},{"location":"code-reference/pydvl/value/result/#pydvl.value.result.ValuationResult.variances","title":"<code>variances: NDArray[np.float_]</code>  <code>property</code>","text":"<p>The variances, possibly sorted.</p>"},{"location":"code-reference/pydvl/value/result/#pydvl.value.result.ValuationResult.stderr","title":"<code>stderr: NDArray[np.float_]</code>  <code>property</code>","text":"<p>The raw standard errors, possibly sorted.</p>"},{"location":"code-reference/pydvl/value/result/#pydvl.value.result.ValuationResult.counts","title":"<code>counts: NDArray[np.int_]</code>  <code>property</code>","text":"<p>The raw counts, possibly sorted.</p>"},{"location":"code-reference/pydvl/value/result/#pydvl.value.result.ValuationResult.indices","title":"<code>indices: NDArray[IndexT]</code>  <code>property</code>","text":"<p>The indices for the values, possibly sorted.</p> <p>If the object is unsorted, then these are the same as declared at construction or <code>np.arange(len(values))</code> if none were passed.</p>"},{"location":"code-reference/pydvl/value/result/#pydvl.value.result.ValuationResult.names","title":"<code>names: NDArray[NameT]</code>  <code>property</code>","text":"<p>The names for the values, possibly sorted. If the object is unsorted, then these are the same as declared at construction or <code>np.arange(len(values))</code> if none were passed.</p>"},{"location":"code-reference/pydvl/value/result/#pydvl.value.result.ValuationResult.sort","title":"<code>sort(reverse=False, key='value')</code>","text":"<p>Sorts the indices in place by <code>key</code>.</p> <p>Once sorted, iteration over the results, and indexing of all the properties ValuationResult.values, ValuationResult.variances, ValuationResult.counts, ValuationResult.indices and ValuationResult.names will follow the same order.</p> PARAMETER  DESCRIPTION <code>reverse</code> <p>Whether to sort in descending order by value.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>key</code> <p>The key to sort by. Defaults to ValueItem.value.</p> <p> TYPE: <code>Literal['value', 'variance', 'index', 'name']</code> DEFAULT: <code>'value'</code> </p> Source code in <code>src/pydvl/value/result.py</code> <pre><code>def sort(\nself,\nreverse: bool = False,\n# Need a \"Comparable\" type here\nkey: Literal[\"value\", \"variance\", \"index\", \"name\"] = \"value\",\n) -&gt; None:\n\"\"\"Sorts the indices in place by `key`.\n    Once sorted, iteration over the results, and indexing of all the\n    properties\n    [ValuationResult.values][pydvl.value.result.ValuationResult.values],\n    [ValuationResult.variances][pydvl.value.result.ValuationResult.variances],\n    [ValuationResult.counts][pydvl.value.result.ValuationResult.counts],\n    [ValuationResult.indices][pydvl.value.result.ValuationResult.indices]\n    and [ValuationResult.names][pydvl.value.result.ValuationResult.names]\n    will follow the same order.\n    Args:\n        reverse: Whether to sort in descending order by value.\n        key: The key to sort by. Defaults to\n            [ValueItem.value][pydvl.value.result.ValueItem.value].\n    \"\"\"\nkeymap = {\n\"index\": \"_indices\",\n\"value\": \"_values\",\n\"variance\": \"_variances\",\n\"name\": \"_names\",\n}\nself._sort_positions = np.argsort(getattr(self, keymap[key]))\nif reverse:\nself._sort_positions = self._sort_positions[::-1]\nself._sort_order = reverse\n</code></pre>"},{"location":"code-reference/pydvl/value/result/#pydvl.value.result.ValuationResult.__getattr__","title":"<code>__getattr__(attr)</code>","text":"<p>Allows access to extra values as if they were properties of the instance.</p> Source code in <code>src/pydvl/value/result.py</code> <pre><code>def __getattr__(self, attr: str) -&gt; Any:\n\"\"\"Allows access to extra values as if they were properties of the instance.\"\"\"\n# This is here to avoid a RecursionError when copying or pickling the object\nif attr == \"_extra_values\":\nraise AttributeError()\ntry:\nreturn self._extra_values[attr]\nexcept KeyError as e:\nraise AttributeError(\nf\"{self.__class__.__name__} object has no attribute {attr}\"\n) from e\n</code></pre>"},{"location":"code-reference/pydvl/value/result/#pydvl.value.result.ValuationResult.__iter__","title":"<code>__iter__()</code>","text":"<p>Iterate over the results returning ValueItem objects. To sort in place before iteration, use sort().</p> Source code in <code>src/pydvl/value/result.py</code> <pre><code>def __iter__(self) -&gt; Iterator[ValueItem[IndexT, NameT]]:\n\"\"\"Iterate over the results returning [ValueItem][pydvl.value.result.ValueItem] objects.\n    To sort in place before iteration, use [sort()][pydvl.value.result.ValuationResult.sort].\n    \"\"\"\nfor pos in self._sort_positions:\nyield ValueItem(\nself._indices[pos],\nself._names[pos],\nself._values[pos],\nself._variances[pos],\nself._counts[pos],\n)\n</code></pre>"},{"location":"code-reference/pydvl/value/result/#pydvl.value.result.ValuationResult.__add__","title":"<code>__add__(other)</code>","text":"<p>Adds two ValuationResults.</p> <p>The values must have been computed with the same algorithm. An exception to this is if one argument has empty values, in which case the other argument is returned.</p> <p>Warning</p> <p>Abusing this will introduce numerical errors.</p> <p>Means and standard errors are correctly handled. Statuses are added with bit-wise <code>&amp;</code>, see Status. <code>data_names</code> are taken from the left summand, or if unavailable from the right one. The <code>algorithm</code> string is carried over if both terms have the same one or concatenated.</p> <p>It is possible to add ValuationResults of different lengths, and with different or overlapping indices. The result will have the union of indices, and the values.</p> <p>Warning</p> <p>FIXME: Arbitrary <code>extra_values</code> aren't handled.</p> Source code in <code>src/pydvl/value/result.py</code> <pre><code>def __add__(self, other: \"ValuationResult\") -&gt; \"ValuationResult\":\n\"\"\"Adds two ValuationResults.\n    The values must have been computed with the same algorithm. An exception\n    to this is if one argument has empty values, in which case the other\n    argument is returned.\n    !!! Warning\n        Abusing this will introduce numerical errors.\n    Means and standard errors are correctly handled. Statuses are added with\n    bit-wise `&amp;`, see [Status][pydvl.value.result.Status].\n    `data_names` are taken from the left summand, or if unavailable from\n    the right one. The `algorithm` string is carried over if both terms\n    have the same one or concatenated.\n    It is possible to add ValuationResults of different lengths, and with\n    different or overlapping indices. The result will have the union of\n    indices, and the values.\n    !!! Warning\n        FIXME: Arbitrary `extra_values` aren't handled.\n    \"\"\"\n# empty results\nif len(self.values) == 0:\nreturn other\nif len(other.values) == 0:\nreturn self\nself._check_compatible(other)\nindices = np.union1d(self._indices, other._indices).astype(self._indices.dtype)\nthis_pos = np.searchsorted(indices, self._indices)\nother_pos = np.searchsorted(indices, other._indices)\nn: NDArray[np.int_] = np.zeros_like(indices, dtype=int)\nm: NDArray[np.int_] = np.zeros_like(indices, dtype=int)\nxn: NDArray[np.int_] = np.zeros_like(indices, dtype=float)\nxm: NDArray[np.int_] = np.zeros_like(indices, dtype=float)\nvn: NDArray[np.int_] = np.zeros_like(indices, dtype=float)\nvm: NDArray[np.int_] = np.zeros_like(indices, dtype=float)\nn[this_pos] = self._counts\nxn[this_pos] = self._values\nvn[this_pos] = self._variances\nm[other_pos] = other._counts\nxm[other_pos] = other._values\nvm[other_pos] = other._variances\n# Sample mean of n+m samples from two means of n and m samples\nxnm = (n * xn + m * xm) / (n + m)\n# Sample variance of n+m samples from two sample variances of n and m samples\nvnm = (n * (vn + xn**2) + m * (vm + xm**2)) / (n + m) - xnm**2\nif np.any(vnm &lt; 0):\nif np.any(vnm &lt; -1e-6):\nlogger.warning(\n\"Numerical error in variance computation. \"\nf\"Negative sample variances clipped to 0 in {vnm}\"\n)\nvnm[np.where(vnm &lt; 0)] = 0\n# Merging of names:\n# If an index has the same name in both results, it must be the same.\n# If an index has a name in one result but not the other, the name is\n# taken from the result with the name.\nif self._names.dtype != other._names.dtype:\nif np.can_cast(other._names.dtype, self._names.dtype, casting=\"safe\"):\nother._names = other._names.astype(self._names.dtype)\nlogger.warning(\nf\"Casting ValuationResult.names from {other._names.dtype} to {self._names.dtype}\"\n)\nelse:\nraise TypeError(\nf\"Cannot cast ValuationResult.names from \"\nf\"{other._names.dtype} to {self._names.dtype}\"\n)\nboth_pos = np.intersect1d(this_pos, other_pos)\nif len(both_pos) &gt; 0:\nthis_names: NDArray = np.empty_like(indices, dtype=object)\nother_names: NDArray = np.empty_like(indices, dtype=object)\nthis_names[this_pos] = self._names\nother_names[other_pos] = other._names\nthis_shared_names = np.take(this_names, both_pos)\nother_shared_names = np.take(other_names, both_pos)\nif np.any(this_shared_names != other_shared_names):\nraise ValueError(f\"Mismatching names in ValuationResults\")\nnames = np.empty_like(indices, dtype=self._names.dtype)\nnames[this_pos] = self._names\nnames[other_pos] = other._names\nreturn ValuationResult(\nalgorithm=self.algorithm or other.algorithm or \"\",\nstatus=self.status &amp; other.status,\nindices=indices,\nvalues=xnm,\nvariances=vnm,\ncounts=n + m,\ndata_names=names,\n# FIXME: What to do with extra_values? This is not commutative:\n# extra_values=self._extra_values.update(other._extra_values),\n)\n</code></pre>"},{"location":"code-reference/pydvl/value/result/#pydvl.value.result.ValuationResult.update","title":"<code>update(idx, new_value)</code>","text":"<p>Updates the result in place with a new value, using running mean and variance.</p> PARAMETER  DESCRIPTION <code>idx</code> <p>Data index of the value to update.</p> <p> TYPE: <code>int</code> </p> <code>new_value</code> <p>New value to add to the result.</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>'ValuationResult'</code> <p>A reference to the same, modified result.</p> <p>:raises IndexError: If the index is not found.</p> Source code in <code>src/pydvl/value/result.py</code> <pre><code>def update(self, idx: int, new_value: float) -&gt; \"ValuationResult\":\n\"\"\"Updates the result in place with a new value, using running mean\n    and variance.\n    Args:\n        idx: Data index of the value to update.\n        new_value: New value to add to the result.\n    Returns:\n        A reference to the same, modified result.\n    :raises IndexError: If the index is not found.\n    \"\"\"\ntry:\npos = self._positions[idx]\nexcept KeyError:\nraise IndexError(f\"Index {idx} not found in ValuationResult\")\nval, var = running_moments(\nself._values[pos], self._variances[pos], self._counts[pos], new_value\n)\nself[pos] = ValueItem(\nindex=cast(IndexT, idx),\nname=self._names[pos],\nvalue=val,\nvariance=var,\ncount=self._counts[pos] + 1,\n)\nreturn self\n</code></pre>"},{"location":"code-reference/pydvl/value/result/#pydvl.value.result.ValuationResult.get","title":"<code>get(idx)</code>","text":"<p>Retrieves a ValueItem by data index, as opposed to sort index, like the indexing operator. :raises IndexError: If the index is not found.</p> Source code in <code>src/pydvl/value/result.py</code> <pre><code>def get(self, idx: Integral) -&gt; ValueItem:\n\"\"\"Retrieves a ValueItem by data index, as opposed to sort index, like\n    the indexing operator.\n    :raises IndexError: If the index is not found.\n    \"\"\"\ntry:\npos = self._positions[idx]\nexcept KeyError:\nraise IndexError(f\"Index {idx} not found in ValuationResult\")\nreturn ValueItem(\nself._indices[pos],\nself._names[pos],\nself._values[pos],\nself._variances[pos],\nself._counts[pos],\n)\n</code></pre>"},{"location":"code-reference/pydvl/value/result/#pydvl.value.result.ValuationResult.to_dataframe","title":"<code>to_dataframe(column=None, use_names=False)</code>","text":"<p>Returns values as a dataframe.</p> PARAMETER  DESCRIPTION <code>column</code> <p>Name for the column holding the data value. Defaults to the name of the algorithm used.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>use_names</code> <p>Whether to use data names instead of indices for the DataFrame's index.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>DataFrame</code> <p>A dataframe with two columns, one for the values, with name given as explained in <code>column</code>, and another with standard errors for approximate algorithms. The latter will be named <code>column+'_stderr'</code>.</p> <p>:raise ImportError: If pandas is not installed</p> Source code in <code>src/pydvl/value/result.py</code> <pre><code>def to_dataframe(\nself, column: Optional[str] = None, use_names: bool = False\n) -&gt; pandas.DataFrame:\n\"\"\"Returns values as a dataframe.\n    Args:\n        column: Name for the column holding the data value. Defaults to\n            the name of the algorithm used.\n        use_names: Whether to use data names instead of indices for the\n            DataFrame's index.\n    Returns:\n        A dataframe with two columns, one for the values, with name\n            given as explained in `column`, and another with standard errors for\n            approximate algorithms. The latter will be named `column+'_stderr'`.\n    :raise ImportError: If pandas is not installed\n    \"\"\"\nif not pandas:\nraise ImportError(\"Pandas required for DataFrame export\")\ncolumn = column or self._algorithm\ndf = pandas.DataFrame(\nself._values[self._sort_positions],\nindex=self._names[self._sort_positions]\nif use_names\nelse self._indices[self._sort_positions],\ncolumns=[column],\n)\ndf[column + \"_stderr\"] = self.stderr[self._sort_positions]\nreturn df\n</code></pre>"},{"location":"code-reference/pydvl/value/result/#pydvl.value.result.ValuationResult.from_random","title":"<code>from_random(size, total=None, **kwargs)</code>  <code>classmethod</code>","text":"<p>Creates a ValuationResult object and fills it with an array of random values from a uniform distribution in [-1,1]. The values can be made to sum up to a given total number (doing so will change their range).</p> PARAMETER  DESCRIPTION <code>size</code> <p>Number of values to generate</p> <p> TYPE: <code>int</code> </p> <code>total</code> <p>If set, the values are normalized to sum to this number (\"efficiency\" property of Shapley values).</p> <p> TYPE: <code>Optional[float]</code> DEFAULT: <code>None</code> </p> <code>kwargs</code> <p>Additional options to pass to the constructor of ValuationResult. Use to override status, names, etc.</p> <p> TYPE: <code>dict</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>'ValuationResult'</code> <p>A valuation result with its status set to Status.Converged by default.</p> <p>:raises ValueError: If <code>size</code> is less than 1.</p> <p>Changed in version 0.6.0</p> <p>Added parameter <code>total</code>. Check for zero size</p> Source code in <code>src/pydvl/value/result.py</code> <pre><code>@classmethod\ndef from_random(\ncls, size: int, total: Optional[float] = None, **kwargs: dict\n) -&gt; \"ValuationResult\":\n\"\"\"Creates a [ValuationResult][pydvl.value.result.ValuationResult] object and fills it with an array\n    of random values from a uniform distribution in [-1,1]. The values can\n    be made to sum up to a given total number (doing so will change their range).\n    Args:\n        size: Number of values to generate\n        total: If set, the values are normalized to sum to this number\n            (\"efficiency\" property of Shapley values).\n        kwargs: Additional options to pass to the constructor of\n            [ValuationResult][pydvl.value.result.ValuationResult]. Use to override status, names, etc.\n    Returns:\n        A valuation result with its status set to\n            [Status.Converged][Status.Converged] by default.\n    :raises ValueError: If `size` is less than 1.\n    !!! tip \"Changed in version 0.6.0\"\n        Added parameter `total`. Check for zero size\n    \"\"\"\nif size &lt; 1:\nraise ValueError(\"Size must be a positive integer\")\nvalues = np.random.uniform(low=-1, high=1, size=size)\nif total is not None:\nvalues *= total / np.sum(values)\noptions = dict(values=values, status=Status.Converged, algorithm=\"random\")\noptions.update(kwargs)\nreturn cls(**options)  # type: ignore\n</code></pre>"},{"location":"code-reference/pydvl/value/result/#pydvl.value.result.ValuationResult.empty","title":"<code>empty(algorithm='', indices=None, data_names=None, n_samples=0)</code>  <code>classmethod</code>","text":"<p>Creates an empty ValuationResult object.</p> <p>Empty results are characterised by having an empty array of values. When another result is added to an empty one, the empty one is discarded.</p> PARAMETER  DESCRIPTION <code>algorithm</code> <p>Name of the algorithm used to compute the values</p> <p> TYPE: <code>str</code> DEFAULT: <code>''</code> </p> RETURNS DESCRIPTION <code>'ValuationResult'</code> <p>Object with the results.</p> Source code in <code>src/pydvl/value/result.py</code> <pre><code>@classmethod\n@deprecated(\ntarget=True,\ndeprecated_in=\"0.6.0\",\nremove_in=\"0.8.0\",\nargs_mapping=dict(indices=None, data_names=None, n_samples=None),\ntemplate_mgs=\"`%(source_name)s` is deprecated for generating zero-filled \"\n\"results, use `ValuationResult.zeros()` instead.\",\n)\ndef empty(\ncls,\nalgorithm: str = \"\",\nindices: Optional[Sequence[IndexT] | NDArray[IndexT]] = None,\ndata_names: Optional[Sequence[NameT] | NDArray[NameT]] = None,\nn_samples: int = 0,\n) -&gt; \"ValuationResult\":\n\"\"\"Creates an empty [ValuationResult][pydvl.value.result.ValuationResult] object.\n    Empty results are characterised by having an empty array of values. When\n    another result is added to an empty one, the empty one is discarded.\n    Args:\n        algorithm: Name of the algorithm used to compute the values\n    Returns:\n        Object with the results.\n    \"\"\"\nif indices is not None or data_names is not None or n_samples != 0:\nreturn cls.zeros(\nalgorithm=algorithm,\nindices=indices,\ndata_names=data_names,\nn_samples=n_samples,\n)\nreturn cls(algorithm=algorithm, status=Status.Pending, values=np.array([]))\n</code></pre>"},{"location":"code-reference/pydvl/value/result/#pydvl.value.result.ValuationResult.zeros","title":"<code>zeros(algorithm='', indices=None, data_names=None, n_samples=0)</code>  <code>classmethod</code>","text":"<p>Creates an empty ValuationResult object.</p> <p>Empty results are characterised by having an empty array of values. When another result is added to an empty one, the empty one is ignored.</p> PARAMETER  DESCRIPTION <code>algorithm</code> <p>Name of the algorithm used to compute the values</p> <p> TYPE: <code>str</code> DEFAULT: <code>''</code> </p> <code>indices</code> <p>Data indices to use. A copy will be made. If not given, the indices will be set to the range <code>[0, n_samples)</code>.</p> <p> TYPE: <code>Optional[Sequence[IndexT] | NDArray[IndexT]]</code> DEFAULT: <code>None</code> </p> <code>data_names</code> <p>Data names to use. A copy will be made. If not given, the names will be set to the string representation of the indices.</p> <p> TYPE: <code>Optional[Sequence[NameT] | NDArray[NameT]]</code> DEFAULT: <code>None</code> </p> <code>n_samples</code> <p>Number of data points whose values are computed. If not given, the length of <code>indices</code> will be used.</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> RETURNS DESCRIPTION <code>'ValuationResult'</code> <p>Object with the results.</p> Source code in <code>src/pydvl/value/result.py</code> <pre><code>@classmethod\ndef zeros(\ncls,\nalgorithm: str = \"\",\nindices: Optional[Sequence[IndexT] | NDArray[IndexT]] = None,\ndata_names: Optional[Sequence[NameT] | NDArray[NameT]] = None,\nn_samples: int = 0,\n) -&gt; \"ValuationResult\":\n\"\"\"Creates an empty [ValuationResult][pydvl.value.result.ValuationResult] object.\n    Empty results are characterised by having an empty array of values. When\n    another result is added to an empty one, the empty one is ignored.\n    Args:\n        algorithm: Name of the algorithm used to compute the values\n        indices: Data indices to use. A copy will be made. If not given,\n            the indices will be set to the range `[0, n_samples)`.\n        data_names: Data names to use. A copy will be made. If not given,\n            the names will be set to the string representation of the indices.\n        n_samples: Number of data points whose values are computed. If\n            not given, the length of `indices` will be used.\n    Returns:\n        Object with the results.\n    \"\"\"\nif indices is None:\nindices = np.arange(n_samples, dtype=np.int_)\nelse:\nindices = np.array(indices)\nreturn cls(\nalgorithm=algorithm,\nstatus=Status.Pending,\nindices=indices,\ndata_names=data_names\nif data_names is not None\nelse np.empty_like(indices, dtype=object),\nvalues=np.zeros(len(indices)),\nvariances=np.zeros(len(indices)),\ncounts=np.zeros(len(indices), dtype=np.int_),\n)\n</code></pre>"},{"location":"code-reference/pydvl/value/sampler/","title":"sampler","text":"<p>Samplers iterate over subsets of indices.</p> <p>The classes in this module are used to iterate over indices and subsets of their complement in the whole set, as required for the computation of marginal utility for semi-values. The elements returned when iterating over any subclass of PowersetSampler are tuples of the form <code>(idx, subset)</code>, where <code>idx</code> is the index of the element being added to the subset, and <code>subset</code> is the subset of the complement of <code>idx</code>.</p> <p>Note</p> <p>This is the natural mode of iteration for the combinatorial definition of semi-values, in particular Shapley value. For the computation using permutations, adhering to this interface is not ideal, but we stick to it for consistency.</p> <p>The samplers are used in the semivalues module to compute any semi-value, in particular Shapley and Beta values, and Banzhaf indices.</p>"},{"location":"code-reference/pydvl/value/sampler/#pydvl.value.sampler--slicing-of-samplers","title":"Slicing of samplers","text":"<p>The samplers can be sliced for parallel computation. For those which are embarrassingly parallel, this is done by slicing the set of \"outer\" indices and returning new samplers over those slices. This includes all truly powerset-based samplers, such as DeterministicCombinatorialSampler and UniformSampler. In contrast, slicing a PermutationSampler creates a new sampler which iterates over the same indices.</p>"},{"location":"code-reference/pydvl/value/sampler/#pydvl.value.sampler.PowersetSampler","title":"<code>PowersetSampler(indices, index_iteration=IndexIteration.Sequential, outer_indices=None)</code>","text":"<p>             Bases: <code>ABC</code>, <code>Iterable[SampleType]</code>, <code>Generic[T]</code></p> <p>Samplers iterate over subsets of indices.</p> <p>This is done in nested loops, where the outer loop iterates over the set of indices, and the inner loop iterates over subsets of the complement of the current index. The outer iteration can be either sequential or at random.</p> <p>:Example:</p> <p>for idx, s in DeterministicCombinatorialSampler([1,2]):    print(s, end=\"\") ()(2,)()(1,)</p>"},{"location":"code-reference/pydvl/value/sampler/#pydvl.value.sampler.PowersetSampler--methods-required-in-subclasses","title":"Methods required in subclasses","text":"<p>Samplers must implement a weight() function to be used as a multiplier in Monte Carlo sums, so that the limit expectation coincides with the semi-value.</p>"},{"location":"code-reference/pydvl/value/sampler/#pydvl.value.sampler.PowersetSampler--slicing-of-samplers","title":"Slicing of samplers","text":"<p>The samplers can be sliced for parallel computation. For those which are embarrassingly parallel, this is done by slicing the set of \"outer\" indices and returning new samplers over those slices.</p> <pre><code>index_iteration: the order in which indices are iterated over\nouter_indices: The set of items (indices) over which to iterate\n    when sampling. Subsets are taken from the complement of each index\n    in succession. For embarrassingly parallel computations, this set\n    is sliced and the samplers are used to iterate over the slices.\n</code></pre> Source code in <code>src/pydvl/value/sampler.py</code> <pre><code>def __init__(\nself,\nindices: NDArray[T],\nindex_iteration: IndexIteration = IndexIteration.Sequential,\nouter_indices: NDArray[T] = None,\n):\n\"\"\"\n    Args:\n        indices: The set of items (indices) to sample from.\n        index_iteration: the order in which indices are iterated over\n        outer_indices: The set of items (indices) over which to iterate\n            when sampling. Subsets are taken from the complement of each index\n            in succession. For embarrassingly parallel computations, this set\n            is sliced and the samplers are used to iterate over the slices.\n    \"\"\"\nself._indices = indices\nself._index_iteration = index_iteration\nself._outer_indices = outer_indices if outer_indices is not None else indices\nself._n = len(indices)\nself._n_samples = 0\n</code></pre>"},{"location":"code-reference/pydvl/value/sampler/#pydvl.value.sampler.PowersetSampler.iterindices","title":"<code>iterindices()</code>","text":"<p>Iterates over indices in the order specified at construction.</p> this is probably not very useful, but I couldn't decide <p>which method is better</p> Source code in <code>src/pydvl/value/sampler.py</code> <pre><code>def iterindices(self) -&gt; Iterator[T]:\n\"\"\"Iterates over indices in the order specified at construction.\n    FIXME: this is probably not very useful, but I couldn't decide\n      which method is better\n    \"\"\"\nif self._index_iteration is PowersetSampler.IndexIteration.Sequential:\nfor idx in self._outer_indices:\nyield idx\nelif self._index_iteration is PowersetSampler.IndexIteration.Random:\nwhile True:\nyield np.random.choice(self._outer_indices, size=1).item()\n</code></pre>"},{"location":"code-reference/pydvl/value/sampler/#pydvl.value.sampler.PowersetSampler.__len__","title":"<code>__len__()</code>","text":"<p>Returns the number of outer indices over which the sampler iterates.</p> Source code in <code>src/pydvl/value/sampler.py</code> <pre><code>def __len__(self) -&gt; int:\n\"\"\"Returns the number of outer indices over which the sampler iterates.\"\"\"\nreturn len(self._outer_indices)\n</code></pre>"},{"location":"code-reference/pydvl/value/sampler/#pydvl.value.sampler.PowersetSampler.weight","title":"<code>weight(subset)</code>  <code>abstractmethod</code>","text":"<p>Factor by which to multiply Monte Carlo samples, so that the mean converges to the desired expression.</p> <p>By the Law of Large Numbers, the sample mean of \\(\\delta_i(S_j)\\) converges to the expectation under the distribution from which \\(S_j\\) is sampled.</p> \\[ \\frac{1}{m}  \\sum_{j = 1}^m \\delta_i (S_j) c (S_j) \\longrightarrow    \\underset{S \\sim \\mathcal{D}_{- i}}{\\mathbb{E}} [\\delta_i (S) c (    S)]\\] <p>We add a factor \\(c(S_j)\\) in order to have this expectation coincide with the desired expression.</p> Source code in <code>src/pydvl/value/sampler.py</code> <pre><code>@abc.abstractmethod\ndef weight(self, subset: NDArray[T]) -&gt; float:\nr\"\"\"Factor by which to multiply Monte Carlo samples, so that the\n    mean converges to the desired expression.\n    By the Law of Large Numbers, the sample mean of $\\delta_i(S_j)$\n    converges\n    to the expectation under the distribution from which $S_j$ is sampled.\n    $$ \\frac{1}{m}  \\sum_{j = 1}^m \\delta_i (S_j) c (S_j) \\longrightarrow\n       \\underset{S \\sim \\mathcal{D}_{- i}}{\\mathbb{E}} [\\delta_i (S) c (\n       S)]$$\n    We add a factor $c(S_j)$ in order to have this expectation coincide with\n    the desired expression.\n    \"\"\"\n...\n</code></pre>"},{"location":"code-reference/pydvl/value/sampler/#pydvl.value.sampler.DeterministicCombinatorialSampler","title":"<code>DeterministicCombinatorialSampler(indices, *args, **kwargs)</code>","text":"<p>             Bases: <code>PowersetSampler[T]</code></p> <p>For every index \\(i\\), each subset of <code>indices - {i}</code> has equal probability \\(2^{n-1}\\).</p> PARAMETER  DESCRIPTION <code>indices</code> <p>The set of items (indices) to sample from.</p> <p> TYPE: <code>NDArray[T]</code> </p> Source code in <code>src/pydvl/value/sampler.py</code> <pre><code>def __init__(self, indices: NDArray[T], *args, **kwargs):\n\"\"\"Uniform deterministic sampling of subsets.\n    For every index $i$, each subset of `indices - {i}` has equal\n    probability $2^{n-1}$.\n    Args:\n        indices: The set of items (indices) to sample from.\n    \"\"\"\n# Force sequential iteration\nkwargs.update({\"index_iteration\": PowersetSampler.IndexIteration.Sequential})\nsuper().__init__(indices, *args, **kwargs)\n</code></pre>"},{"location":"code-reference/pydvl/value/sampler/#pydvl.value.sampler.UniformSampler","title":"<code>UniformSampler</code>","text":"<p>             Bases: <code>PowersetSampler[T]</code></p>"},{"location":"code-reference/pydvl/value/sampler/#pydvl.value.sampler.UniformSampler.weight","title":"<code>weight(subset)</code>","text":"<p>Correction coming from Monte Carlo integration so that the mean of the marginals converges to the value: the uniform distribution over the powerset of a set with n-1 elements has mass 2^{n-1} over each subset. The factor 1 / n corresponds to the one in the Shapley definition.</p> Source code in <code>src/pydvl/value/sampler.py</code> <pre><code>def weight(self, subset: NDArray[T]) -&gt; float:\n\"\"\"Correction coming from Monte Carlo integration so that the mean of\n    the marginals converges to the value: the uniform distribution over the\n    powerset of a set with n-1 elements has mass 2^{n-1} over each subset.\n    The factor 1 / n corresponds to the one in the Shapley definition.\"\"\"\nreturn float(2 ** (self._n - 1)) if self._n &gt; 0 else 1.0\n</code></pre>"},{"location":"code-reference/pydvl/value/sampler/#pydvl.value.sampler.PermutationSampler","title":"<code>PermutationSampler</code>","text":"<p>             Bases: <code>PowersetSampler[T]</code></p> <p>Sample permutations of indices and iterate through each returning sets, as required for the permutation definition of semi-values.</p> <p>Warning</p> <p>This sampler requires caching to be enabled or computation will be doubled wrt. a \"direct\" implementation of permutation MC</p>"},{"location":"code-reference/pydvl/value/sampler/#pydvl.value.sampler.PermutationSampler.__getitem__","title":"<code>__getitem__(key)</code>","text":"<p>Permutation samplers cannot be split across indices, so we return a copy of the full sampler.</p> Source code in <code>src/pydvl/value/sampler.py</code> <pre><code>def __getitem__(self, key: slice | list[int]) -&gt; \"PowersetSampler[T]\":\n\"\"\"Permutation samplers cannot be split across indices, so we return\n    a copy of the full sampler.\"\"\"\nreturn super().__getitem__(slice(None))\n</code></pre>"},{"location":"code-reference/pydvl/value/sampler/#pydvl.value.sampler.DeterministicPermutationSampler","title":"<code>DeterministicPermutationSampler</code>","text":"<p>             Bases: <code>PermutationSampler[T]</code></p> <p>Samples all n! permutations of the indices deterministically, and iterates through them, returning sets as required for the permutation-based definition of semi-values.</p> <p>Warning</p> <p>This sampler requires caching to be enabled or computation will be doubled wrt. a \"direct\" implementation of permutation MC</p>"},{"location":"code-reference/pydvl/value/sampler/#pydvl.value.sampler.RandomHierarchicalSampler","title":"<code>RandomHierarchicalSampler</code>","text":"<p>             Bases: <code>PowersetSampler[T]</code></p> <p>For every index, sample a set size, then a set of that size.</p> <p>Todo</p> <p>This is unnecessary, but a step towards proper stratified sampling.</p>"},{"location":"code-reference/pydvl/value/semivalues/","title":"semivalues","text":"<p>Computes semi-values for a given utility function and subset sampler.</p> PARAMETER  DESCRIPTION <code>sampler</code> <p>The subset sampler to use for utility computations.</p> <p> TYPE: <code>PowersetSampler</code> </p> <code>u</code> <p>Utility object with model, data, and scoring function.</p> <p> TYPE: <code>Utility</code> </p> <code>coefficient</code> <p>The semi-value coefficient</p> <p> TYPE: <code>SVCoefficient</code> </p> <code>done</code> <p>Stopping criterion.</p> <p> TYPE: <code>StoppingCriterion</code> </p> <code>n_jobs</code> <p>Number of parallel jobs to use.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>config</code> <p>Object configuring parallel computation, with cluster address, number of cpus, etc.</p> <p> TYPE: <code>ParallelConfig</code> DEFAULT: <code>ParallelConfig()</code> </p> <code>progress</code> <p>Whether to display progress bars for each job.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>ValuationResult</code> <p>Object with the results.</p> Source code in <code>src/pydvl/value/semivalues.py</code> <pre><code>def semivalues(\nsampler: PowersetSampler,\nu: Utility,\ncoefficient: SVCoefficient,\ndone: StoppingCriterion,\n*,\nn_jobs: int = 1,\nconfig: ParallelConfig = ParallelConfig(),\nprogress: bool = False,\n) -&gt; ValuationResult:\n\"\"\"\n    Computes semi-values for a given utility function and subset sampler.\n    Args:\n        sampler: The subset sampler to use for utility computations.\n        u: Utility object with model, data, and scoring function.\n        coefficient: The semi-value coefficient\n        done: Stopping criterion.\n        n_jobs: Number of parallel jobs to use.\n        config: Object configuring parallel computation, with cluster\n            address, number of cpus, etc.\n        progress: Whether to display progress bars for each job.\n    Returns:\n        Object with the results.\n    \"\"\"\nmap_reduce_job: MapReduceJob[PowersetSampler, ValuationResult] = MapReduceJob(\nsampler,\nmap_func=_semivalues,\nreduce_func=lambda results: reduce(operator.add, results),\nmap_kwargs=dict(u=u, coefficient=coefficient, done=done, progress=progress),\nconfig=config,\nn_jobs=n_jobs,\n)\nreturn map_reduce_job()\n</code></pre>"},{"location":"code-reference/pydvl/value/stopping/","title":"stopping","text":"<p>Stopping criteria for value computations.</p> <p>This module provides a basic set of stopping criteria, like MaxUpdates, MaxTime, or HistoryDeviation among others. These can behave in different ways depending on the context. For example, MaxUpdates limits the number of updates to values, which depending on the algorithm may mean a different number of utility evaluations or imply other computations like solving a linear or quadratic program.</p>"},{"location":"code-reference/pydvl/value/stopping/#pydvl.value.stopping--creating-stopping-criteria","title":"Creating stopping criteria","text":"<p>The easiest way is to declare a function implementing the interface StoppingCriterionCallable and wrap it with make_criterion(). This creates a StoppingCriterion object that can be composed with other stopping criteria.</p> <p>Alternatively, and in particular if reporting of completion is required, one can inherit from this class and implement the abstract methods _check() and completion().</p>"},{"location":"code-reference/pydvl/value/stopping/#pydvl.value.stopping--composing-stopping-criteria","title":"Composing stopping criteria","text":"<p>Objects of type StoppingCriterion can be composed with the binary operators <code>&amp;</code> (and), and <code>|</code> (or), following the truth tables of Status. The unary operator <code>~</code> (not) is also supported. See StoppingCriterion for details on how these operations affect the behavior of the stopping criteria.</p>"},{"location":"code-reference/pydvl/value/stopping/#pydvl.value.stopping.StoppingCriterion","title":"<code>StoppingCriterion(modify_result=True)</code>","text":"<p>             Bases: <code>ABC</code></p> <p>A composable callable object to determine whether a computation must stop.</p> <p>A <code>StoppingCriterion</code> is a callable taking a ValuationResult and returning a Status. It also keeps track of individual convergence of values with converged(), and reports the overall completion of the computation with completion().</p> <p>Instances of <code>StoppingCriterion</code> can be composed with the binary operators <code>&amp;</code> (and), and <code>|</code> (or), following the truth tables of Status. The unary operator <code>~</code> (not) is also supported. These boolean operations act according to the following rules:</p> <ul> <li>The results of _check() are combined with the operator. See   Status for the truth tables.</li> <li>The results of converged() are combined with the operator (returning   another boolean array).</li> <li>The completion() method returns the min, max, or the complement to 1   of the completions of the operands, for AND, OR and NOT respectively. This   is required for cases where one of the criteria does not keep track of the   convergence of single values, e.g. MaxUpdates, because   completion() by default returns the mean of the boolean convergence   array.</li> </ul>"},{"location":"code-reference/pydvl/value/stopping/#pydvl.value.stopping.StoppingCriterion--subclassing","title":"Subclassing","text":"<p>Subclassing this class requires implementing a _check() method that returns a Status object based on a given ValuationResult. This method should update the attribute _converged, which is a boolean array indicating whether the value for each index has converged. When this does not make sense for a particular stopping criterion, completion() should be overridden to provide an overall completion value, since its default implementation attempts to compute the mean of _converged.</p> PARAMETER  DESCRIPTION <code>modify_result</code> <p>If <code>True</code> the status of the input ValuationResult is modified in place after the call.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/pydvl/value/stopping.py</code> <pre><code>def __init__(self, modify_result: bool = True):\nself.modify_result = modify_result\nself._converged = np.full(0, False)\n</code></pre>"},{"location":"code-reference/pydvl/value/stopping/#pydvl.value.stopping.StoppingCriterion.converged","title":"<code>converged: NDArray[np.bool_]</code>  <code>property</code>","text":"<p>Returns a boolean array indicating whether the values have converged for each data point.</p> <p>Inheriting classes must set the <code>_converged</code> attribute in their _check().</p> RETURNS DESCRIPTION <code>NDArray[numpy.bool_]</code> <p>A boolean array indicating whether the values have converged for</p> <code>NDArray[numpy.bool_]</code> <p>each data point.</p>"},{"location":"code-reference/pydvl/value/stopping/#pydvl.value.stopping.StoppingCriterion.completion","title":"<code>completion()</code>","text":"<p>Returns a value between 0 and 1 indicating the completion of the computation.</p> Source code in <code>src/pydvl/value/stopping.py</code> <pre><code>def completion(self) -&gt; float:\n\"\"\"Returns a value between 0 and 1 indicating the completion of the\n    computation.\n    \"\"\"\nif self.converged.size == 0:\nreturn 0.0\nreturn np.mean(self.converged).item()\n</code></pre>"},{"location":"code-reference/pydvl/value/stopping/#pydvl.value.stopping.StoppingCriterion.__call__","title":"<code>__call__(result)</code>","text":"<p>Calls _check(), maybe updating the result.</p> Source code in <code>src/pydvl/value/stopping.py</code> <pre><code>def __call__(self, result: ValuationResult) -&gt; Status:\n\"\"\"Calls [_check()][pydvl.value.stopping.StoppingCriterion._check], maybe updating the result.\"\"\"\nif len(result) == 0:\nlogger.warning(\n\"At least one iteration finished but no results where generated. \"\n\"Please check that your scorer and utility return valid numbers.\"\n)\nstatus = self._check(result)\nif self.modify_result:  # FIXME: this is not nice\nresult._status = status\nreturn status\n</code></pre>"},{"location":"code-reference/pydvl/value/stopping/#pydvl.value.stopping.AbsoluteStandardError","title":"<code>AbsoluteStandardError(threshold, fraction=1.0, burn_in=4, modify_result=True)</code>","text":"<p>             Bases: <code>StoppingCriterion</code></p> <p>Determine convergence based on the standard error of the values.</p> <p>If \\(s_i\\) is the standard error for datum \\(i\\) and \\(v_i\\) its value, then this criterion returns Converged if \\(s_i &lt; \\epsilon\\) for all \\(i\\) and a threshold value \\(\\epsilon \\gt 0\\).</p> PARAMETER  DESCRIPTION <code>threshold</code> <p>A value is considered to have converged if the standard error is below this value. A way of choosing it is to pick some percentage of the range of the values. For Shapley values this is the difference between the maximum and minimum of the utility function (to see this substitute the maximum and minimum values of the utility into the marginal contribution formula).</p> <p> TYPE: <code>float</code> </p> <code>fraction</code> <p>The fraction of values that must have converged for the criterion to return Converged.</p> <p> TYPE: <code>float</code> DEFAULT: <code>1.0</code> </p> <code>burn_in</code> <p>The number of iterations to ignore before checking for convergence. This is required because computations typically start with zero variance, as a result of using empty(). The default is set to an arbitrary minimum which is usually enough but may need to be increased.</p> <p> TYPE: <code>int</code> DEFAULT: <code>4</code> </p> Source code in <code>src/pydvl/value/stopping.py</code> <pre><code>def __init__(\nself,\nthreshold: float,\nfraction: float = 1.0,\nburn_in: int = 4,\nmodify_result: bool = True,\n):\nsuper().__init__(modify_result=modify_result)\nself.threshold = threshold\nself.fraction = fraction\nself.burn_in = burn_in\n</code></pre>"},{"location":"code-reference/pydvl/value/stopping/#pydvl.value.stopping.MaxChecks","title":"<code>MaxChecks(n_checks, modify_result=True)</code>","text":"<p>             Bases: <code>StoppingCriterion</code></p> <p>Terminate as soon as the number of checks exceeds the threshold.</p> <p>A \"check\" is one call to the criterion.</p> PARAMETER  DESCRIPTION <code>n_checks</code> <p>Threshold: if <code>None</code>, no _check is performed, effectively creating a (never) stopping criterion that always returns <code>Pending</code>.</p> <p> TYPE: <code>Optional[int]</code> </p> Source code in <code>src/pydvl/value/stopping.py</code> <pre><code>def __init__(self, n_checks: Optional[int], modify_result: bool = True):\nsuper().__init__(modify_result=modify_result)\nif n_checks is not None and n_checks &lt; 1:\nraise ValueError(\"n_iterations must be at least 1 or None\")\nself.n_checks = n_checks\nself._count = 0\n</code></pre>"},{"location":"code-reference/pydvl/value/stopping/#pydvl.value.stopping.MaxUpdates","title":"<code>MaxUpdates(n_updates, modify_result=True)</code>","text":"<p>             Bases: <code>StoppingCriterion</code></p> <p>Terminate if any number of value updates exceeds or equals the given threshold.</p> <p>This checks the <code>counts</code> field of a ValuationResult, i.e. the number of times that each index has been updated. For powerset samplers, the maximum of this number coincides with the maximum number of subsets sampled. For permutation samplers, it coincides with the number of permutations sampled.</p> PARAMETER  DESCRIPTION <code>n_updates</code> <p>Threshold: if <code>None</code>, no _check is performed, effectively creating a (never) stopping criterion that always returns <code>Pending</code>.</p> <p> TYPE: <code>Optional[int]</code> </p> Source code in <code>src/pydvl/value/stopping.py</code> <pre><code>def __init__(self, n_updates: Optional[int], modify_result: bool = True):\nsuper().__init__(modify_result=modify_result)\nif n_updates is not None and n_updates &lt; 1:\nraise ValueError(\"n_updates must be at least 1 or None\")\nself.n_updates = n_updates\nself.last_max = 0\n</code></pre>"},{"location":"code-reference/pydvl/value/stopping/#pydvl.value.stopping.MinUpdates","title":"<code>MinUpdates(n_updates, modify_result=True)</code>","text":"<p>             Bases: <code>StoppingCriterion</code></p> <p>Terminate as soon as all value updates exceed or equal the given threshold.</p> <p>This checks the <code>counts</code> field of a ValuationResult, i.e. the number of times that each index has been updated. For powerset samplers, the minimum of this number is a lower bound for the number of subsets sampled. For permutation samplers, it lower-bounds the amount of permutations sampled.</p> PARAMETER  DESCRIPTION <code>n_updates</code> <p>Threshold: if <code>None</code>, no _check is performed, effectively creating a (never) stopping criterion that always returns <code>Pending</code>.</p> <p> TYPE: <code>Optional[int]</code> </p> Source code in <code>src/pydvl/value/stopping.py</code> <pre><code>def __init__(self, n_updates: Optional[int], modify_result: bool = True):\nsuper().__init__(modify_result=modify_result)\nself.n_updates = n_updates\nself.last_min = 0\n</code></pre>"},{"location":"code-reference/pydvl/value/stopping/#pydvl.value.stopping.MaxTime","title":"<code>MaxTime(seconds, modify_result=True)</code>","text":"<p>             Bases: <code>StoppingCriterion</code></p> <p>Terminate if the computation time exceeds the given number of seconds.</p> <p>Checks the elapsed time since construction</p> PARAMETER  DESCRIPTION <code>seconds</code> <p>Threshold: The computation is terminated if the elapsed time between object construction and a _check exceeds this value. If <code>None</code>, no _check is performed, effectively creating a (never) stopping criterion that always returns <code>Pending</code>.</p> <p> TYPE: <code>Optional[float]</code> </p> Source code in <code>src/pydvl/value/stopping.py</code> <pre><code>def __init__(self, seconds: Optional[float], modify_result: bool = True):\nsuper().__init__(modify_result=modify_result)\nself.max_seconds = seconds or np.inf\nif self.max_seconds &lt;= 0:\nraise ValueError(\"Number of seconds for MaxTime must be positive or None\")\nself.start = time()\n</code></pre>"},{"location":"code-reference/pydvl/value/stopping/#pydvl.value.stopping.HistoryDeviation","title":"<code>HistoryDeviation(n_steps, rtol, pin_converged=True, modify_result=True)</code>","text":"<p>             Bases: <code>StoppingCriterion</code></p> <p>A simple check for relative distance to a previous step in the computation.</p> <p>The method used by [@ghorbani_data_2019] computes the relative distances between the current values \\(v_i^t\\) and the values at the previous checkpoint \\(v_i^{t-\\tau}\\). If the sum is below a given threshold, the computation is terminated.</p> \\[\\sum_{i=1}^n \\frac{\\left| v_i^t - v_i^{t-\\tau} \\right|}{v_i^t} &lt; \\epsilon.\\] <p>When the denominator is zero, the summand is set to the value of \\(v_i^{ t-\\tau}\\).</p> <p>This implementation is slightly generalised to allow for different number of updates to individual indices, as happens with powerset samplers instead of permutations. Every subset of indices that is found to converge can be pinned to that state. Once all indices have converged the method has converged.</p> <p>Warning</p> <p>This criterion is meant for the reproduction of the results in the paper, but we do not recommend using it in practice.</p> PARAMETER  DESCRIPTION <code>n_steps</code> <p>Checkpoint values every so many updates and use these saved values to compare.</p> <p> TYPE: <code>int</code> </p> <code>rtol</code> <p>Relative tolerance for convergence (\\(\\epsilon\\) in the formula).</p> <p> TYPE: <code>float</code> </p> <code>pin_converged</code> <p>If <code>True</code>, once an index has converged, it is pinned</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/pydvl/value/stopping.py</code> <pre><code>def __init__(\nself,\nn_steps: int,\nrtol: float,\npin_converged: bool = True,\nmodify_result: bool = True,\n):\nsuper().__init__(modify_result=modify_result)\nif n_steps &lt; 1:\nraise ValueError(\"n_steps must be at least 1\")\nif rtol &lt;= 0 or rtol &gt;= 1:\nraise ValueError(\"rtol must be in (0, 1)\")\nself.n_steps = n_steps\nself.rtol = rtol\nself.update_op = np.logical_or if pin_converged else np.logical_and\nself._memory = None  # type: ignore\n</code></pre>"},{"location":"code-reference/pydvl/value/stopping/#pydvl.value.stopping.make_criterion","title":"<code>make_criterion(fun, converged=None, completion=None, name=None)</code>","text":"<p>Create a new StoppingCriterion from a function. Use this to enable simpler functions to be composed with bitwise operators</p> PARAMETER  DESCRIPTION <code>fun</code> <p>The callable to wrap.</p> <p> TYPE: <code>StoppingCriterionCallable</code> </p> <code>converged</code> <p>A callable that returns a boolean array indicating what values have converged.</p> <p> TYPE: <code>Callable[[], NDArray[numpy.bool_]]</code> DEFAULT: <code>None</code> </p> <code>completion</code> <p>A callable that returns a value between 0 and 1 indicating the rate of completion of the computation. If not provided, the fraction of converged values is used.</p> <p> TYPE: <code>Callable[[], float]</code> DEFAULT: <code>None</code> </p> <code>name</code> <p>The name of the new criterion. If <code>None</code>, the <code>__name__</code> of the function is used.</p> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Type[StoppingCriterion]</code> <p>A new subclass of StoppingCriterion.</p> Source code in <code>src/pydvl/value/stopping.py</code> <pre><code>def make_criterion(\nfun: StoppingCriterionCallable,\nconverged: Callable[[], NDArray[np.bool_]] = None,\ncompletion: Callable[[], float] = None,\nname: str = None,\n) -&gt; Type[StoppingCriterion]:\n\"\"\"Create a new [StoppingCriterion][pydvl.value.stopping.StoppingCriterion] from a function.\n    Use this to enable simpler functions to be composed with bitwise operators\n    Args:\n        fun: The callable to wrap.\n        converged: A callable that returns a boolean array indicating what\n            values have converged.\n        completion: A callable that returns a value between 0 and 1 indicating\n            the rate of completion of the computation. If not provided, the fraction\n            of converged values is used.\n        name: The name of the new criterion. If `None`, the `__name__` of\n            the function is used.\n    Returns:\n        A new subclass of [StoppingCriterion][pydvl.value.stopping.StoppingCriterion].\n    \"\"\"\nclass WrappedCriterion(StoppingCriterion):\ndef __init__(self, modify_result: bool = True):\nsuper().__init__(modify_result=modify_result)\nself._name = name or fun.__name__\ndef _check(self, result: ValuationResult) -&gt; Status:\nreturn fun(result)\n@property\ndef converged(self) -&gt; NDArray[np.bool_]:\nif converged is None:\nreturn super().converged\nreturn converged()\n@property\ndef name(self):\nreturn self._name\ndef completion(self) -&gt; float:\nif completion is None:\nreturn super().completion()\nreturn completion()\nreturn WrappedCriterion\n</code></pre>"},{"location":"code-reference/pydvl/value/least_core/","title":"least_core","text":"<p>New in version 0.4.0</p> <p>This package holds all routines for the computation of Least Core data values.</p> <p>Please refer to Data valuation for an overview.</p> <p>In addition to the standard interface via compute_least_core_values(), because computing the Least Core values requires the solution of a linear and a quadratic problem after computing all the utility values, there is the possibility of performing each step separately. This is useful when running multiple experiments: use lc_prepare_problem() or mclc_prepare_problem() to prepare a list of problems to solve, then solve them in parallel with lc_solve_problems().</p> <p>Note that mclc_prepare_problem() is parallelized itself, so preparing the problems should be done in sequence in this case. The solution of the linear systems can then be done in parallel.</p>"},{"location":"code-reference/pydvl/value/least_core/#pydvl.value.least_core.LeastCoreMode","title":"<code>LeastCoreMode</code>","text":"<p>             Bases: <code>Enum</code></p> <p>Available Least Core algorithms.</p>"},{"location":"code-reference/pydvl/value/least_core/#pydvl.value.least_core.compute_least_core_values","title":"<code>compute_least_core_values(u, *, n_jobs=1, n_iterations=None, mode=LeastCoreMode.MonteCarlo, non_negative_subsidy=False, solver_options=None, **kwargs)</code>","text":"<p>Umbrella method to compute Least Core values with any of the available algorithms.</p> <p>See Data valuation for an overview.</p> <p>The following algorithms are available. Note that the exact method can only work with very small datasets and is thus intended only for testing.</p> <ul> <li><code>exact</code>: uses the complete powerset of the training set for the constraints   combinatorial_exact_shapley().</li> <li><code>montecarlo</code>:  uses the approximate Monte Carlo Least Core algorithm.   Implemented in montecarlo_least_core().</li> </ul> PARAMETER  DESCRIPTION <code>u</code> <p>Utility object with model, data, and scoring function</p> <p> TYPE: <code>Utility</code> </p> <code>n_jobs</code> <p>Number of jobs to run in parallel. Only used for Monte Carlo Least Core.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>n_iterations</code> <p>Number of subsets to sample and evaluate the utility on. Only used for Monte Carlo Least Core.</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>mode</code> <p>Algorithm to use. See LeastCoreMode for available options.</p> <p> TYPE: <code>LeastCoreMode</code> DEFAULT: <code>MonteCarlo</code> </p> <code>non_negative_subsidy</code> <p>If True, the least core subsidy \\(e\\) is constrained to be non-negative.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>solver_options</code> <p>Optional dictionary of options passed to the solvers.</p> <p> TYPE: <code>Optional[dict]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>ValuationResult</code> <p>Object with the computed values.</p> <p>New in version 0.5.0</p> Source code in <code>src/pydvl/value/least_core/__init__.py</code> <pre><code>def compute_least_core_values(\nu: Utility,\n*,\nn_jobs: int = 1,\nn_iterations: Optional[int] = None,\nmode: LeastCoreMode = LeastCoreMode.MonteCarlo,\nnon_negative_subsidy: bool = False,\nsolver_options: Optional[dict] = None,\n**kwargs: dict,\n) -&gt; ValuationResult:\n\"\"\"Umbrella method to compute Least Core values with any of the available\n    algorithms.\n    See [Data valuation][computing-data-values] for an overview.\n    The following algorithms are available. Note that the exact method can only\n    work with very small datasets and is thus intended only for testing.\n    - `exact`: uses the complete powerset of the training set for the constraints\n      [combinatorial_exact_shapley()][pydvl.value.shapley.naive.combinatorial_exact_shapley].\n    - `montecarlo`:  uses the approximate Monte Carlo Least Core algorithm.\n      Implemented in [montecarlo_least_core()][pydvl.value.least_core.montecarlo.montecarlo_least_core].\n    Args:\n        u: Utility object with model, data, and scoring function\n        n_jobs: Number of jobs to run in parallel. Only used for Monte Carlo\n            Least Core.\n        n_iterations: Number of subsets to sample and evaluate the utility on.\n            Only used for Monte Carlo Least Core.\n        mode: Algorithm to use. See\n            [LeastCoreMode][pydvl.value.least_core.LeastCoreMode] for available\n            options.\n        non_negative_subsidy: If True, the least core subsidy $e$ is constrained\n            to be non-negative.\n        solver_options: Optional dictionary of options passed to the solvers.\n    Returns:\n        Object with the computed values.\n    !!! tip \"New in version 0.5.0\"\n    \"\"\"\nprogress: bool = kwargs.pop(\"progress\", False)\n# TODO: remove this before releasing version 0.7.0\nif kwargs:\nwarnings.warn(\nDeprecationWarning(\n\"Passing solver options as kwargs was deprecated in 0.6.0, will \"\n\"be removed in 0.7.0. `Use solver_options` instead.\"\n)\n)\nif solver_options is None:\nsolver_options = kwargs\nelse:\nsolver_options.update(kwargs)\nif mode == LeastCoreMode.MonteCarlo:\n# TODO fix progress showing and maybe_progress in remote case\nprogress = False\nif n_iterations is None:\nraise ValueError(\"n_iterations cannot be None for Monte Carlo Least Core\")\nreturn montecarlo_least_core(\nu=u,\nn_iterations=n_iterations,\nn_jobs=n_jobs,\nprogress=progress,\nnon_negative_subsidy=non_negative_subsidy,\nsolver_options=solver_options,\n**kwargs,\n)\nelif mode == LeastCoreMode.Exact:\nreturn exact_least_core(\nu=u,\nprogress=progress,\nnon_negative_subsidy=non_negative_subsidy,\nsolver_options=solver_options,\n)\nraise ValueError(f\"Invalid value encountered in {mode=}\")\n</code></pre>"},{"location":"code-reference/pydvl/value/least_core/common/","title":"common","text":""},{"location":"code-reference/pydvl/value/least_core/common/#pydvl.value.least_core.common.lc_solve_problem","title":"<code>lc_solve_problem(problem, *, u, algorithm, non_negative_subsidy=False, solver_options=None, **options)</code>","text":"<p>Solves a linear problem as prepared by mclc_prepare_problem(). Useful for parallel execution of multiple experiments by running this as a remote task.</p> <p>See exact_least_core() or montecarlo_least_core() for argument descriptions.</p> Source code in <code>src/pydvl/value/least_core/common.py</code> <pre><code>def lc_solve_problem(\nproblem: LeastCoreProblem,\n*,\nu: Utility,\nalgorithm: str,\nnon_negative_subsidy: bool = False,\nsolver_options: Optional[dict] = None,\n**options,\n) -&gt; ValuationResult:\n\"\"\"Solves a linear problem as prepared by\n    [mclc_prepare_problem()][pydvl.value.least_core.montecarlo.mclc_prepare_problem].\n    Useful for parallel execution of multiple experiments by running this as a\n    remote task.\n    See [exact_least_core()][pydvl.value.least_core.naive.exact_least_core] or\n    [montecarlo_least_core()][pydvl.value.least_core.montecarlo.montecarlo_least_core] for\n    argument descriptions.\n    \"\"\"\nn = len(u.data)\nif np.any(np.isnan(problem.utility_values)):\nwarnings.warn(\nf\"Calculation returned \"\nf\"{np.sum(np.isnan(problem.utility_values))} NaN \"\nf\"values out of {problem.utility_values.size}\",\nRuntimeWarning,\n)\n# TODO: remove this before releasing version 0.7.0\nif options:\nwarnings.warn(\nDeprecationWarning(\n\"Passing solver options as kwargs was deprecated in \"\n\"0.6.0, will be removed in 0.7.0. `Use solver_options` \"\n\"instead.\"\n)\n)\nif solver_options is None:\nsolver_options = options\nelse:\nsolver_options.update(options)\nif solver_options is None:\nsolver_options = {}\nif \"solver\" not in solver_options:\nsolver_options[\"solver\"] = cp.SCS\nif \"max_iters\" not in solver_options and solver_options[\"solver\"] == cp.SCS:\nsolver_options[\"max_iters\"] = 10000\nlogger.debug(\"Removing possible duplicate values in lower bound array\")\nb_lb = problem.utility_values\nA_lb, unique_indices = np.unique(problem.A_lb, return_index=True, axis=0)\nb_lb = b_lb[unique_indices]\nlogger.debug(\"Building equality constraint\")\nA_eq = np.ones((1, n))\n# We might have already computed the total utility one or more times.\n# This is the index of the row(s) in A_lb with all ones.\ntotal_utility_indices = np.where(A_lb.sum(axis=1) == n)[0]\nif len(total_utility_indices) == 0:\nb_eq = np.array([u(u.data.indices)])\nelse:\nb_eq = b_lb[total_utility_indices]\n# Remove the row(s) corresponding to the total utility\n# from the lower bound constraints\n# because given the equality constraint\n# it is the same as using the constraint e &gt;= 0\n# (i.e. setting non_negative_subsidy = True).\nmask: NDArray[np.bool_] = np.ones_like(b_lb, dtype=bool)\nmask[total_utility_indices] = False\nb_lb = b_lb[mask]\nA_lb = A_lb[mask]\n# Remove the row(s) corresponding to the empty subset\n# because, given u(\u2205) = (which is almost always the case,\n# it is the same as using the constraint e &gt;= 0\n# (i.e. setting non_negative_subsidy = True).\nemptyset_utility_indices = np.where(A_lb.sum(axis=1) == 0)[0]\nif len(emptyset_utility_indices) &gt; 0:\nmask = np.ones_like(b_lb, dtype=bool)\nmask[emptyset_utility_indices] = False\nb_lb = b_lb[mask]\nA_lb = A_lb[mask]\n_, subsidy = _solve_least_core_linear_program(\nA_eq=A_eq,\nb_eq=b_eq,\nA_lb=A_lb,\nb_lb=b_lb,\nnon_negative_subsidy=non_negative_subsidy,\nsolver_options=solver_options,\n)\nvalues: Optional[NDArray[np.float_]]\nif subsidy is None:\nlogger.debug(\"No values were found\")\nstatus = Status.Failed\nvalues = np.empty(n)\nvalues[:] = np.nan\nsubsidy = np.nan\nelse:\nvalues = _solve_egalitarian_least_core_quadratic_program(\nsubsidy,\nA_eq=A_eq,\nb_eq=b_eq,\nA_lb=A_lb,\nb_lb=b_lb,\nsolver_options=solver_options,\n)\nif values is None:\nlogger.debug(\"No values were found\")\nstatus = Status.Failed\nvalues = np.empty(n)\nvalues[:] = np.nan\nsubsidy = np.nan\nelse:\nstatus = Status.Converged\nreturn ValuationResult(\nalgorithm=algorithm,\nstatus=status,\nvalues=values,\nsubsidy=subsidy,\nstderr=None,\ndata_names=u.data.data_names,\n)\n</code></pre>"},{"location":"code-reference/pydvl/value/least_core/common/#pydvl.value.least_core.common.lc_solve_problems","title":"<code>lc_solve_problems(problems, u, algorithm, config=ParallelConfig(), n_jobs=1, non_negative_subsidy=True, solver_options=None, **options)</code>","text":"<p>Solves a list of linear problems in parallel.</p> PARAMETER  DESCRIPTION <code>u</code> <p>Utility.</p> <p> TYPE: <code>Utility</code> </p> <code>problems</code> <p>Least Core problems to solve, as returned by mclc_prepare_problem().</p> <p> TYPE: <code>Sequence[LeastCoreProblem]</code> </p> <code>algorithm</code> <p>Name of the valuation algorithm.</p> <p> TYPE: <code>str</code> </p> <code>config</code> <p>Object configuring parallel computation, with cluster address, number of cpus, etc.</p> <p> TYPE: <code>ParallelConfig</code> DEFAULT: <code>ParallelConfig()</code> </p> <code>n_jobs</code> <p>Number of parallel jobs to run.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>non_negative_subsidy</code> <p>If True, the least core subsidy \\(e\\) is constrained to be non-negative.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>solver_options</code> <p>Additional options to pass to the solver.</p> <p> TYPE: <code>Optional[dict]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>List[ValuationResult]</code> <p>List of solutions.</p> Source code in <code>src/pydvl/value/least_core/common.py</code> <pre><code>def lc_solve_problems(\nproblems: Sequence[LeastCoreProblem],\nu: Utility,\nalgorithm: str,\nconfig: ParallelConfig = ParallelConfig(),\nn_jobs: int = 1,\nnon_negative_subsidy: bool = True,\nsolver_options: Optional[dict] = None,\n**options,\n) -&gt; List[ValuationResult]:\n\"\"\"Solves a list of linear problems in parallel.\n    Args:\n        u: Utility.\n        problems: Least Core problems to solve, as returned by\n            [mclc_prepare_problem()][pydvl.value.least_core.montecarlo.mclc_prepare_problem].\n        algorithm: Name of the valuation algorithm.\n        config: Object configuring parallel computation, with cluster address,\n            number of cpus, etc.\n        n_jobs: Number of parallel jobs to run.\n        non_negative_subsidy: If True, the least core subsidy $e$ is constrained\n            to be non-negative.\n        solver_options: Additional options to pass to the solver.\n    Returns:\n        List of solutions.\n    \"\"\"\ndef _map_func(\nproblems: List[LeastCoreProblem], *args, **kwargs\n) -&gt; List[ValuationResult]:\nreturn [lc_solve_problem(p, *args, **kwargs) for p in problems]\nmap_reduce_job: MapReduceJob[\n\"LeastCoreProblem\", \"List[ValuationResult]\"\n] = MapReduceJob(\ninputs=problems,\nmap_func=_map_func,\nmap_kwargs=dict(\nu=u,\nalgorithm=algorithm,\nnon_negative_subsidy=non_negative_subsidy,\nsolver_options=solver_options,\n**options,\n),\nreduce_func=lambda x: list(itertools.chain(*x)),\nconfig=config,\nn_jobs=n_jobs,\n)\nsolutions = map_reduce_job()\nreturn solutions\n</code></pre>"},{"location":"code-reference/pydvl/value/least_core/montecarlo/","title":"montecarlo","text":""},{"location":"code-reference/pydvl/value/least_core/montecarlo/#pydvl.value.least_core.montecarlo.montecarlo_least_core","title":"<code>montecarlo_least_core(u, n_iterations, *, n_jobs=1, config=ParallelConfig(), non_negative_subsidy=False, solver_options=None, options=None, progress=False)</code>","text":"<p>Computes approximate Least Core values using a Monte Carlo approach.</p> \\[ \\begin{array}{lll} \\text{minimize} &amp; \\displaystyle{e} &amp; \\\\ \\text{subject to} &amp; \\displaystyle\\sum_{i\\in N} x_{i} = v(N) &amp; \\\\ &amp; \\displaystyle\\sum_{i\\in S} x_{i} + e \\geq v(S) &amp; , \\forall S \\in \\{S_1, S_2, \\dots, S_m \\overset{\\mathrm{iid}}{\\sim} U(2^N) \\} \\end{array} \\] <p>Where:</p> <ul> <li>\\(U(2^N)\\) is the uniform distribution over the powerset of \\(N\\).</li> <li>\\(m\\) is the number of subsets that will be sampled and whose utility will   be computed and used to compute the data values.</li> </ul> PARAMETER  DESCRIPTION <code>u</code> <p>Utility object with model, data, and scoring function</p> <p> TYPE: <code>Utility</code> </p> <code>n_iterations</code> <p>total number of iterations to use</p> <p> TYPE: <code>int</code> </p> <code>n_jobs</code> <p>number of jobs across which to distribute the computation</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>config</code> <p>Object configuring parallel computation, with cluster address, number of cpus, etc.</p> <p> TYPE: <code>ParallelConfig</code> DEFAULT: <code>ParallelConfig()</code> </p> <code>non_negative_subsidy</code> <p>If True, the least core subsidy \\(e\\) is constrained to be non-negative.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>solver_options</code> <p>Dictionary of options that will be used to select a solver and to configure it. Refer to cvxpy's documentation for all possible options.</p> <p> TYPE: <code>Optional[dict]</code> DEFAULT: <code>None</code> </p> <code>options</code> <p>(Deprecated) Dictionary of solver options. Use solver_options instead.</p> <p> TYPE: <code>Optional[dict]</code> DEFAULT: <code>None</code> </p> <code>progress</code> <p>If True, shows a tqdm progress bar</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>ValuationResult</code> <p>Object with the data values and the least core value.</p> Source code in <code>src/pydvl/value/least_core/montecarlo.py</code> <pre><code>def montecarlo_least_core(\nu: Utility,\nn_iterations: int,\n*,\nn_jobs: int = 1,\nconfig: ParallelConfig = ParallelConfig(),\nnon_negative_subsidy: bool = False,\nsolver_options: Optional[dict] = None,\noptions: Optional[dict] = None,\nprogress: bool = False,\n) -&gt; ValuationResult:\nr\"\"\"Computes approximate Least Core values using a Monte Carlo approach.\n    $$\n    \\begin{array}{lll}\n    \\text{minimize} &amp; \\displaystyle{e} &amp; \\\\\n    \\text{subject to} &amp; \\displaystyle\\sum_{i\\in N} x_{i} = v(N) &amp; \\\\\n    &amp; \\displaystyle\\sum_{i\\in S} x_{i} + e \\geq v(S) &amp; ,\n    \\forall S \\in \\{S_1, S_2, \\dots, S_m \\overset{\\mathrm{iid}}{\\sim} U(2^N) \\}\n    \\end{array}\n    $$\n    Where:\n    * $U(2^N)$ is the uniform distribution over the powerset of $N$.\n    * $m$ is the number of subsets that will be sampled and whose utility will\n      be computed and used to compute the data values.\n    Args:\n        u: Utility object with model, data, and scoring function\n        n_iterations: total number of iterations to use\n        n_jobs: number of jobs across which to distribute the computation\n        config: Object configuring parallel computation, with cluster\n            address, number of cpus, etc.\n        non_negative_subsidy: If True, the least core subsidy $e$ is constrained\n            to be non-negative.\n        solver_options: Dictionary of options that will be used to select a solver\n            and to configure it. Refer to [cvxpy's\n            documentation](https://www.cvxpy.org/tutorial/advanced/index.html#setting-solver-options)\n            for all possible options.\n        options: (Deprecated) Dictionary of solver options. Use solver_options\n            instead.\n        progress: If True, shows a tqdm progress bar\n    Returns:\n        Object with the data values and the least core value.\n    \"\"\"\n# TODO: remove this before releasing version 0.7.0\nif options:\nwarnings.warn(\nDeprecationWarning(\n\"Passing solver options as kwargs was deprecated in \"\n\"0.6.0, will be removed in 0.7.0. `Use solver_options` \"\n\"instead.\"\n)\n)\nif solver_options is None:\nsolver_options = options\nelse:\nsolver_options.update(options)\nproblem = mclc_prepare_problem(\nu, n_iterations, n_jobs=n_jobs, config=config, progress=progress\n)\nreturn lc_solve_problem(\nproblem,\nu=u,\nalgorithm=\"montecarlo_least_core\",\nnon_negative_subsidy=non_negative_subsidy,\nsolver_options=solver_options,\n)\n</code></pre>"},{"location":"code-reference/pydvl/value/least_core/montecarlo/#pydvl.value.least_core.montecarlo.mclc_prepare_problem","title":"<code>mclc_prepare_problem(u, n_iterations, *, n_jobs=1, config=ParallelConfig(), progress=False)</code>","text":"<p>Prepares a linear problem by sampling subsets of the data. Use this to separate the problem preparation from the solving with lc_solve_problem(). Useful for parallel execution of multiple experiments.</p> <p>See montecarlo_least_core for argument descriptions.</p> Source code in <code>src/pydvl/value/least_core/montecarlo.py</code> <pre><code>def mclc_prepare_problem(\nu: Utility,\nn_iterations: int,\n*,\nn_jobs: int = 1,\nconfig: ParallelConfig = ParallelConfig(),\nprogress: bool = False,\n) -&gt; LeastCoreProblem:\n\"\"\"Prepares a linear problem by sampling subsets of the data. Use this to\n    separate the problem preparation from the solving with\n    [lc_solve_problem()][pydvl.value.least_core.common.lc_solve_problem]. Useful\n    for parallel execution of multiple experiments.\n    See\n    [montecarlo_least_core][pydvl.value.least_core.montecarlo.montecarlo_least_core]\n    for argument descriptions.\n    \"\"\"\nn = len(u.data)\nif n_iterations &lt; n:\nwarnings.warn(\nf\"Number of iterations '{n_iterations}' is smaller the size of the dataset '{n}'. \"\nf\"This is not optimal because in the worst case we need at least '{n}' constraints \"\n\"to satisfy the individual rationality condition.\"\n)\nif n_iterations &gt; 2**n:\nwarnings.warn(\nf\"Passed n_iterations is greater than the number subsets! \"\nf\"Setting it to 2^{n}\",\nRuntimeWarning,\n)\nn_iterations = 2**n\niterations_per_job = max(1, n_iterations // effective_n_jobs(n_jobs, config))\nmap_reduce_job: MapReduceJob[\"Utility\", \"LeastCoreProblem\"] = MapReduceJob(\ninputs=u,\nmap_func=_montecarlo_least_core,\nreduce_func=_reduce_func,\nmap_kwargs=dict(n_iterations=iterations_per_job, progress=progress),\nn_jobs=n_jobs,\nconfig=config,\n)\nreturn map_reduce_job()\n</code></pre>"},{"location":"code-reference/pydvl/value/least_core/naive/","title":"naive","text":""},{"location":"code-reference/pydvl/value/least_core/naive/#pydvl.value.least_core.naive.exact_least_core","title":"<code>exact_least_core(u, *, non_negative_subsidy=False, solver_options=None, options=None, progress=True)</code>","text":"<p>Computes the exact Least Core values.</p> <p>Note</p> <p>If the training set contains more than 20 instances a warning is printed because the computation is very expensive. This method is mostly used for internal testing and simple use cases. Please refer to the Monte Carlo method for practical applications.</p> <p>The least core is the solution to the following Linear Programming problem:</p> \\[ \\begin{array}{lll} \\text{minimize} &amp; \\displaystyle{e} &amp; \\\\ \\text{subject to} &amp; \\displaystyle\\sum_{i\\in N} x_{i} = v(N) &amp; \\\\ &amp; \\displaystyle\\sum_{i\\in S} x_{i} + e \\geq v(S) &amp;, \\forall S \\subseteq N \\\\ \\end{array} \\] <p>Where \\(N = \\{1, 2, \\dots, n\\}\\) are the training set's indices.</p> PARAMETER  DESCRIPTION <code>u</code> <p>Utility object with model, data, and scoring function non_negative_subsidy: If True, the least core subsidy \\(e\\) is constrained to be non-negative.</p> <p> TYPE: <code>Utility</code> </p> <code>solver_options</code> <p>Dictionary of options that will be used to select a solver and to configure it. Refer to the cvxpy's documentation for all possible options.</p> <p> TYPE: <code>Optional[dict]</code> DEFAULT: <code>None</code> </p> <code>options</code> <p>(Deprecated) Dictionary of solver options. Use <code>solver_options</code> instead.</p> <p> TYPE: <code>Optional[dict]</code> DEFAULT: <code>None</code> </p> <code>progress</code> <p>If True, shows a tqdm progress bar</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>ValuationResult</code> <p>Object with the data values and the least core value.</p> Source code in <code>src/pydvl/value/least_core/naive.py</code> <pre><code>def exact_least_core(\nu: Utility,\n*,\nnon_negative_subsidy: bool = False,\nsolver_options: Optional[dict] = None,\noptions: Optional[dict] = None,\nprogress: bool = True,\n) -&gt; ValuationResult:\nr\"\"\"Computes the exact Least Core values.\n    !!! Note\n        If the training set contains more than 20 instances a warning is printed\n        because the computation is very expensive. This method is mostly used for\n        internal testing and simple use cases. Please refer to the\n        [Monte Carlo method][pydvl.value.least_core.montecarlo.montecarlo_least_core]\n        for practical applications.\n    The least core is the solution to the following Linear Programming problem:\n    $$\n    \\begin{array}{lll}\n    \\text{minimize} &amp; \\displaystyle{e} &amp; \\\\\n    \\text{subject to} &amp; \\displaystyle\\sum_{i\\in N} x_{i} = v(N) &amp; \\\\\n    &amp; \\displaystyle\\sum_{i\\in S} x_{i} + e \\geq v(S) &amp;, \\forall S \\subseteq N \\\\\n    \\end{array}\n    $$\n    Where $N = \\{1, 2, \\dots, n\\}$ are the training set's indices.\n    Args:\n        u: Utility object with model, data, and scoring function\n            non_negative_subsidy: If True, the least core subsidy $e$ is constrained\n            to be non-negative.\n        solver_options: Dictionary of options that will be used to select a solver\n            and to configure it. Refer to the [cvxpy's\n            documentation](https://www.cvxpy.org/tutorial/advanced/index.html#setting-solver-options)\n            for all possible options.\n        options: (Deprecated) Dictionary of solver options. Use `solver_options`\n            instead.\n        progress: If True, shows a tqdm progress bar\n    Returns:\n        Object with the data values and the least core value.\n    \"\"\"\nn = len(u.data)\nif n &gt; 20:  # Arbitrary choice, will depend on time required, caching, etc.\nwarnings.warn(f\"Large dataset! Computation requires 2^{n} calls to model.fit()\")\n# TODO: remove this before releasing version 0.7.0\nif options:\nwarnings.warn(\nDeprecationWarning(\n\"Passing solver options as kwargs was deprecated in \"\n\"0.6.0, will \"\n\"be removed in 0.7.0. `Use solver_options` instead.\"\n)\n)\nif solver_options is None:\nsolver_options = options\nelse:\nsolver_options.update(options)\nproblem = lc_prepare_problem(u, progress=progress)\nreturn lc_solve_problem(\nproblem=problem,\nu=u,\nalgorithm=\"exact_least_core\",\nnon_negative_subsidy=non_negative_subsidy,\nsolver_options=solver_options,\n)\n</code></pre>"},{"location":"code-reference/pydvl/value/least_core/naive/#pydvl.value.least_core.naive.lc_prepare_problem","title":"<code>lc_prepare_problem(u, progress=False)</code>","text":"<p>Prepares a linear problem with all subsets of the data Use this to separate the problem preparation from the solving with lc_solve_problem(). Useful for parallel execution of multiple experiments.</p> <p>See exact_least_core() for argument descriptions.</p> Source code in <code>src/pydvl/value/least_core/naive.py</code> <pre><code>def lc_prepare_problem(u: Utility, progress: bool = False) -&gt; LeastCoreProblem:\n\"\"\"Prepares a linear problem with all subsets of the data\n    Use this to separate the problem preparation from the solving with\n    [lc_solve_problem()][pydvl.value.least_core.common.lc_solve_problem]. Useful for\n    parallel execution of multiple experiments.\n    See [exact_least_core()][pydvl.value.least_core.naive.exact_least_core] for argument\n    descriptions.\n    \"\"\"\nn = len(u.data)\nlogger.debug(\"Building vectors and matrices for linear programming problem\")\npowerset_size = 2**n\nA_lb = np.zeros((powerset_size, n))\nlogger.debug(\"Iterating over all subsets\")\nutility_values = np.zeros(powerset_size)\nfor i, subset in enumerate(\nmaybe_progress(\npowerset(u.data.indices), progress, total=powerset_size - 1, position=0\n)\n):\nindices: NDArray[np.bool_] = np.zeros(n, dtype=bool)\nindices[list(subset)] = True\nA_lb[i, indices] = 1\nutility_values[i] = u(subset)\nreturn LeastCoreProblem(utility_values, A_lb)\n</code></pre>"},{"location":"code-reference/pydvl/value/loo/","title":"loo","text":""},{"location":"code-reference/pydvl/value/loo/naive/","title":"naive","text":""},{"location":"code-reference/pydvl/value/loo/naive/#pydvl.value.loo.naive.naive_loo","title":"<code>naive_loo(u, *, progress=True)</code>","text":"<p>Computes leave one out value:</p> \\[v(i) = u(D) - u(D \\setminus \\{i\\}) \\] PARAMETER  DESCRIPTION <code>u</code> <p>Utility object with model, data, and scoring function</p> <p> TYPE: <code>Utility</code> </p> <code>progress</code> <p>If True, display a progress bar</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>ValuationResult</code> <p>Object with the data values.</p> Source code in <code>src/pydvl/value/loo/naive.py</code> <pre><code>def naive_loo(u: Utility, *, progress: bool = True) -&gt; ValuationResult:\nr\"\"\"Computes leave one out value:\n    $$v(i) = u(D) - u(D \\setminus \\{i\\}) $$\n    Args:\n        u: Utility object with model, data, and scoring function\n        progress: If True, display a progress bar\n    Returns:\n        Object with the data values.\n    \"\"\"\nif len(u.data) &lt; 3:\nraise ValueError(\"Dataset must have at least 2 elements\")\nvalues: NDArray[np.float_] = np.zeros_like(u.data.indices, dtype=np.float_)\nall_indices = set(u.data.indices)\ntotal_utility = u(u.data.indices)\nfor i in maybe_progress(u.data.indices, progress):  # type: ignore\nsubset = all_indices.difference({i})\nvalues[i] = total_utility - u(subset)\nreturn ValuationResult(\nalgorithm=\"naive_loo\",\nstatus=Status.Converged,\nvalues=values,\ndata_names=u.data.data_names,\n)\n</code></pre>"},{"location":"code-reference/pydvl/value/shapley/","title":"shapley","text":"<p>This package holds all routines for the computation of Shapley Data value. Users will want to use compute_shapley_values() as a single interface to all methods defined in the modules.</p> <p>Please refer to Data valuation for an overview of Shapley Data value.</p>"},{"location":"code-reference/pydvl/value/shapley/common/","title":"common","text":""},{"location":"code-reference/pydvl/value/shapley/common/#pydvl.value.shapley.common.compute_shapley_values","title":"<code>compute_shapley_values(u, *, done=MaxUpdates(100), mode=ShapleyMode.TruncatedMontecarlo, n_jobs=1, **kwargs)</code>","text":"<p>Umbrella method to compute Shapley values with any of the available algorithms.</p> <p>See Data valuation for an overview.</p> <p>The following algorithms are available. Note that the exact methods can only work with very small datasets and are thus intended only for testing. Some algorithms also accept additional arguments, please refer to the documentation of each particular method.</p> <ul> <li><code>combinatorial_exact</code>: uses the combinatorial implementation of data   Shapley. Implemented in   combinatorial_exact_shapley().</li> <li><code>combinatorial_montecarlo</code>:  uses the approximate Monte Carlo   implementation of combinatorial data Shapley. Implemented in   combinatorial_montecarlo_shapley().</li> <li><code>permutation_exact</code>: uses the permutation-based implementation of data   Shapley. Computation is not parallelized. Implemented in   permutation_exact_shapley().</li> <li><code>permutation_montecarlo</code>: uses the approximate Monte Carlo   implementation of permutation data Shapley. Implemented in   permutation_montecarlo_shapley().</li> <li><code>truncated_montecarlo</code>: default option, same as <code>permutation_montecarlo</code>   but stops the computation whenever a certain accuracy is reached.   Implemented in   truncated_montecarlo_shapley().</li> <li><code>owen_sampling</code>: Uses the Owen continuous extension of the utility   function to the unit cube. Implemented in   owen_sampling_shapley(). This   method does not take a StoppingCriterion   but instead requires a parameter <code>q_max</code> for the number of subdivisions   of the unit interval to use for integration, and another parameter   <code>n_samples</code> for the number of subsets to sample for each \\(q\\).</li> <li><code>owen_halved</code>: Same as 'owen_sampling' but uses correlated samples in the   expectation. Implemented in   owen_sampling_shapley().   This method  requires an additional parameter <code>q_max</code> for the number of   subdivisions of the interval [0,0.5] to use for integration, and another   parameter <code>n_samples</code> for the number of subsets to sample for each \\(q\\).</li> <li><code>group_testing</code>: estimates differences of Shapley values and solves a   constraint satisfaction problem. High sample complexity, not recommended.   Implemented in group_testing_shapley(). This   method does not take a StoppingCriterion   but instead requires a parameter <code>n_samples</code> for the number of   iterations to run.</li> </ul> <p>Additionally, one can use model-specific methods:</p> <ul> <li><code>knn</code>: Exact method for K-Nearest neighbour models. Implemented in   knn_shapley().</li> </ul> PARAMETER  DESCRIPTION <code>u</code> <p>Utility object with model, data, and scoring function.</p> <p> TYPE: <code>Utility</code> </p> <code>done</code> <p>StoppingCriterion object, used to determine when to stop the computation for Monte Carlo methods. The default is to stop after 100 iterations. See the available criteria in stopping. It is possible to combine several criteria using boolean operators. Some methods ignore this argument, others require specific subtypes.</p> <p> TYPE: <code>StoppingCriterion</code> DEFAULT: <code>MaxUpdates(100)</code> </p> <code>n_jobs</code> <p>Number of parallel jobs (available only to some methods)</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>mode</code> <p>Choose which shapley algorithm to use. See ShapleyMode for a list of allowed value.</p> <p> TYPE: <code>ShapleyMode</code> DEFAULT: <code>TruncatedMontecarlo</code> </p> RETURNS DESCRIPTION <code>ValuationResult</code> <p>A ValuationResult object with the results.</p> Source code in <code>src/pydvl/value/shapley/common.py</code> <pre><code>def compute_shapley_values(\nu: Utility,\n*,\ndone: StoppingCriterion = MaxUpdates(100),\nmode: ShapleyMode = ShapleyMode.TruncatedMontecarlo,\nn_jobs: int = 1,\n**kwargs: dict,\n) -&gt; ValuationResult:\n\"\"\"Umbrella method to compute Shapley values with any of the available\n    algorithms.\n    See [Data valuation][computing-data-values] for an overview.\n    The following algorithms are available. Note that the exact methods can only\n    work with very small datasets and are thus intended only for testing. Some\n    algorithms also accept additional arguments, please refer to the\n    documentation of each particular method.\n    - `combinatorial_exact`: uses the combinatorial implementation of data\n      Shapley. Implemented in\n      [combinatorial_exact_shapley()][pydvl.value.shapley.naive.combinatorial_exact_shapley].\n    - `combinatorial_montecarlo`:  uses the approximate Monte Carlo\n      implementation of combinatorial data Shapley. Implemented in\n      [combinatorial_montecarlo_shapley()][pydvl.value.shapley.montecarlo.combinatorial_montecarlo_shapley].\n    - `permutation_exact`: uses the permutation-based implementation of data\n      Shapley. Computation is **not parallelized**. Implemented in\n      [permutation_exact_shapley()][pydvl.value.shapley.naive.permutation_exact_shapley].\n    - `permutation_montecarlo`: uses the approximate Monte Carlo\n      implementation of permutation data Shapley. Implemented in\n      [permutation_montecarlo_shapley()][pydvl.value.shapley.montecarlo.permutation_montecarlo_shapley].\n    - `truncated_montecarlo`: default option, same as `permutation_montecarlo`\n      but stops the computation whenever a certain accuracy is reached.\n      Implemented in\n      [truncated_montecarlo_shapley()][pydvl.value.shapley.truncated.truncated_montecarlo_shapley].\n    - `owen_sampling`: Uses the Owen continuous extension of the utility\n      function to the unit cube. Implemented in\n      [owen_sampling_shapley()][pydvl.value.shapley.owen.owen_sampling_shapley]. This\n      method does not take a [StoppingCriterion][pydvl.value.stopping.StoppingCriterion]\n      but instead requires a parameter `q_max` for the number of subdivisions\n      of the unit interval to use for integration, and another parameter\n      `n_samples` for the number of subsets to sample for each $q$.\n    - `owen_halved`: Same as 'owen_sampling' but uses correlated samples in the\n      expectation. Implemented in\n      [owen_sampling_shapley()][pydvl.value.shapley.owen.owen_sampling_shapley].\n      This method  requires an additional parameter `q_max` for the number of\n      subdivisions of the interval [0,0.5] to use for integration, and another\n      parameter `n_samples` for the number of subsets to sample for each $q$.\n    - `group_testing`: estimates differences of Shapley values and solves a\n      constraint satisfaction problem. High sample complexity, not recommended.\n      Implemented in [group_testing_shapley()][pydvl.value.shapley.gt.group_testing_shapley]. This\n      method does not take a [StoppingCriterion][pydvl.value.stopping.StoppingCriterion]\n      but instead requires a parameter `n_samples` for the number of\n      iterations to run.\n    Additionally, one can use model-specific methods:\n    - `knn`: Exact method for K-Nearest neighbour models. Implemented in\n      [knn_shapley()][pydvl.value.shapley.knn.knn_shapley].\n    Args:\n        u: [Utility][pydvl.utils.utility.Utility] object with model, data, and\n            scoring function.\n        done: [StoppingCriterion][pydvl.value.stopping.StoppingCriterion] object, used to\n            determine when to stop the computation for Monte Carlo methods. The\n            default is to stop after 100 iterations. See the available criteria\n            in [stopping][pydvl.value.stopping]. It is possible to combine several\n            criteria using boolean operators. Some methods ignore this argument,\n            others require specific subtypes.\n        n_jobs: Number of parallel jobs (available only to some methods)\n        mode: Choose which shapley algorithm to use. See\n            [ShapleyMode][pydvl.value.shapley.ShapleyMode] for a list of allowed value.\n    Returns:\n        A [ValuationResult][pydvl.value.result.ValuationResult] object with the results.\n    \"\"\"\nprogress: bool = kwargs.pop(\"progress\", False)\nif mode not in list(ShapleyMode):\nraise ValueError(f\"Invalid value encountered in {mode=}\")\nif mode == ShapleyMode.TruncatedMontecarlo:\ntruncation = kwargs.pop(\"truncation\", NoTruncation())\nreturn truncated_montecarlo_shapley(  # type: ignore\nu=u, done=done, n_jobs=n_jobs, truncation=truncation, **kwargs\n)\nelif mode == ShapleyMode.CombinatorialMontecarlo:\nreturn combinatorial_montecarlo_shapley(\nu, done=done, n_jobs=n_jobs, progress=progress\n)\nelif mode in (ShapleyMode.PermutationMontecarlo, ShapleyMode.ApproShapley):\ntruncation = kwargs.pop(\"truncation\", NoTruncation())\nreturn permutation_montecarlo_shapley(\nu,\ndone=done,\nn_jobs=n_jobs,\nprogress=progress,\ntruncation=truncation,\n**kwargs,\n)\nelif mode == ShapleyMode.CombinatorialExact:\nreturn combinatorial_exact_shapley(u, n_jobs=n_jobs, progress=progress)\nelif mode == ShapleyMode.PermutationExact:\nreturn permutation_exact_shapley(u, progress=progress)\nelif mode == ShapleyMode.Owen or mode == ShapleyMode.OwenAntithetic:\nif kwargs.get(\"n_samples\") is None:\nraise ValueError(\"n_samples cannot be None for Owen methods\")\nif kwargs.get(\"max_q\") is None:\nraise ValueError(\"Owen Sampling requires max_q for the outer integral\")\nmethod = (\nOwenAlgorithm.Standard\nif mode == ShapleyMode.Owen\nelse OwenAlgorithm.Antithetic\n)\nreturn owen_sampling_shapley(\nu,\nn_samples=int(kwargs.get(\"n_samples\", -1)),\nmax_q=int(kwargs.get(\"max_q\", -1)),\nmethod=method,\nn_jobs=n_jobs,\n)\nelif mode == ShapleyMode.KNN:\nreturn knn_shapley(u, progress=progress)\nelif mode == ShapleyMode.GroupTesting:\nn_samples = kwargs.pop(\"n_samples\")\nif n_samples is None:\nraise ValueError(\"n_samples cannot be None for Group Testing\")\nepsilon = kwargs.pop(\"epsilon\")\nif epsilon is None:\nraise ValueError(\"Group Testing requires error bound epsilon\")\ndelta = kwargs.pop(\"delta\", 0.05)\nreturn group_testing_shapley(\nu,\nepsilon=epsilon,\ndelta=delta,\nn_samples=n_samples,\nn_jobs=n_jobs,\nprogress=progress,\n**kwargs,\n)\nelse:\nraise ValueError(f\"Invalid value encountered in {mode=}\")\n</code></pre>"},{"location":"code-reference/pydvl/value/shapley/gt/","title":"gt","text":"<p>This module implements Group Testing for the approximation of Shapley values, as introduced in [@jia_efficient_2019]. The sampling of index subsets is done in such a way that an approximation to the true Shapley values can be computed with guarantees.</p> <p>Warning</p> <p>This method is very inefficient. Potential improvements to the implementation notwithstanding, convergence seems to be very slow (in terms of evaluations of the utility required). We recommend other Monte Carlo methods instead.</p> <p>You can read more in the documentation.</p> <p>New in version 0.4.0</p>"},{"location":"code-reference/pydvl/value/shapley/gt/#pydvl.value.shapley.gt.num_samples_eps_delta","title":"<code>num_samples_eps_delta(eps, delta, n, utility_range)</code>","text":"<p>Implements the formula in Theorem 3 of [@jia_efficient_2019] which gives a lower bound on the number of samples required to obtain an (\u03b5/\u221an,\u03b4/(N(N-1))-approximation to all pair-wise differences of Shapley values, wrt. \\(\\ell_2\\) norm.</p> PARAMETER  DESCRIPTION <code>eps</code> <p>\u03b5</p> <p> TYPE: <code>float</code> </p> <code>delta</code> <p>\u03b4</p> <p> TYPE: <code>float</code> </p> <code>n</code> <p>Number of data points</p> <p> TYPE: <code>int</code> </p> <code>utility_range</code> <p>Range of the Utility function</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>int</code> <p>Number of samples from \\(2^{[n]}\\) guaranteeing \u03b5/\u221an-correct Shapley pair-wise differences of values with probability 1-\u03b4/(N(N-1)).</p> <p>New in version 0.4.0</p> Source code in <code>src/pydvl/value/shapley/gt.py</code> <pre><code>def num_samples_eps_delta(\neps: float, delta: float, n: int, utility_range: float\n) -&gt; int:\nr\"\"\"Implements the formula in Theorem 3 of [@jia_efficient_2019]\n    which gives a lower bound on the number of samples required to obtain an\n    (\u03b5/\u221an,\u03b4/(N(N-1))-approximation to all pair-wise differences of Shapley\n    values, wrt. $\\ell_2$ norm.\n    Args:\n        eps: \u03b5\n        delta: \u03b4\n        n: Number of data points\n        utility_range: Range of the [Utility][pydvl.utils.utility.Utility] function\n    Returns:\n        Number of samples from $2^{[n]}$ guaranteeing \u03b5/\u221an-correct Shapley\n            pair-wise differences of values with probability 1-\u03b4/(N(N-1)).\n    !!! tip \"New in version 0.4.0\"\n    \"\"\"\nconstants = _constants(n=n, epsilon=eps, delta=delta, utility_range=utility_range)\nreturn int(constants.T)\n</code></pre>"},{"location":"code-reference/pydvl/value/shapley/gt/#pydvl.value.shapley.gt.group_testing_shapley","title":"<code>group_testing_shapley(u, n_samples, epsilon, delta, *, n_jobs=1, config=ParallelConfig(), progress=False, **options)</code>","text":"<p>Implements group testing for approximation of Shapley values as described in [@jia_efficient_2019].</p> <p>Warning</p> <p>This method is very inefficient. It requires several orders of magnitude more evaluations of the utility than others in montecarlo. It also uses several intermediate objects like the results from the runners and the constraint matrices which can become rather large.</p> <p>By picking a specific distribution over subsets, the differences in Shapley values can be approximated with a Monte Carlo sum. These are then used to solve for the individual values in a feasibility problem.</p> PARAMETER  DESCRIPTION <code>u</code> <p>Utility object with model, data, and scoring function</p> <p> TYPE: <code>Utility</code> </p> <code>n_samples</code> <p>Number of tests to perform. Use num_samples_eps_delta to estimate this.</p> <p> TYPE: <code>int</code> </p> <code>epsilon</code> <p>From the (\u03b5,\u03b4) sample bound. Use the same as for the estimation of <code>n_iterations</code>.</p> <p> TYPE: <code>float</code> </p> <code>delta</code> <p>From the (\u03b5,\u03b4) sample bound. Use the same as for the estimation of <code>n_iterations</code>.</p> <p> TYPE: <code>float</code> </p> <code>n_jobs</code> <p>Number of parallel jobs to use. Each worker performs a chunk of all tests (i.e. utility evaluations).</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>config</code> <p>Object configuring parallel computation, with cluster address, number of cpus, etc.</p> <p> TYPE: <code>ParallelConfig</code> DEFAULT: <code>ParallelConfig()</code> </p> <code>progress</code> <p>Whether to display progress bars for each job.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>options</code> <p>Additional options to pass to cvxpy.Problem.solve(). E.g. to change the solver (which defaults to <code>cvxpy.SCS</code>) pass <code>solver=cvxpy.CVXOPT</code>.</p> <p> TYPE: <code>dict</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>ValuationResult</code> <p>Object with the data values.</p> <p>New in version 0.4.0</p> <p>Changed in version 0.5.0</p> <p>Changed the solver to cvxpy instead of scipy's linprog. Added the ability to pass arbitrary options to it.</p> Source code in <code>src/pydvl/value/shapley/gt.py</code> <pre><code>def group_testing_shapley(\nu: Utility,\nn_samples: int,\nepsilon: float,\ndelta: float,\n*,\nn_jobs: int = 1,\nconfig: ParallelConfig = ParallelConfig(),\nprogress: bool = False,\n**options: dict,\n) -&gt; ValuationResult:\n\"\"\"Implements group testing for approximation of Shapley values as described\n    in [@jia_efficient_2019].\n    !!! Warning\n        This method is very inefficient. It requires several orders of magnitude\n        more evaluations of the utility than others in\n        [montecarlo][pydvl.value.shapley.montecarlo]. It also uses several intermediate\n        objects like the results from the runners and the constraint matrices\n        which can become rather large.\n    By picking a specific distribution over subsets, the differences in Shapley\n    values can be approximated with a Monte Carlo sum. These are then used to\n    solve for the individual values in a feasibility problem.\n    Args:\n        u: Utility object with model, data, and scoring function\n        n_samples: Number of tests to perform. Use\n            [num_samples_eps_delta][pydvl.value.shapley.gt.num_samples_eps_delta]\n            to estimate this.\n        epsilon: From the (\u03b5,\u03b4) sample bound. Use the same as for the\n            estimation of `n_iterations`.\n        delta: From the (\u03b5,\u03b4) sample bound. Use the same as for the\n            estimation of `n_iterations`.\n        n_jobs: Number of parallel jobs to use. Each worker performs a chunk\n            of all tests (i.e. utility evaluations).\n        config: Object configuring parallel computation, with cluster\n            address, number of cpus, etc.\n        progress: Whether to display progress bars for each job.\n        options: Additional options to pass to\n            [cvxpy.Problem.solve()](https://www.cvxpy.org/tutorial/advanced/index.html#solve-method-options).\n            E.g. to change the solver (which defaults to `cvxpy.SCS`) pass\n            `solver=cvxpy.CVXOPT`.\n    Returns:\n        Object with the data values.\n    !!! tip \"New in version 0.4.0\"\n    !!! tip \"Changed in version 0.5.0\"\n        Changed the solver to cvxpy instead of scipy's linprog. Added the ability\n        to pass arbitrary options to it.\n    \"\"\"\nn = len(u.data.indices)\nconst = _constants(\nn=n,\nepsilon=epsilon,\ndelta=delta,\nutility_range=u.score_range.max() - u.score_range.min(),\n)\nT = n_samples\nif T &lt; const.T:\nlog.warning(\nf\"n_samples of {T} are below the required {const.T} for the \"\nf\"\u03b5={epsilon:.02f} guarantee at \u03b4={1 - delta:.02f} probability\"\n)\nsamples_per_job = max(1, n_samples // effective_n_jobs(n_jobs, config))\ndef reducer(\nresults_it: Iterable[Tuple[NDArray, NDArray]]\n) -&gt; Tuple[NDArray, NDArray]:\nreturn np.concatenate(list(x[0] for x in results_it)).astype(\nnp.float_\n), np.concatenate(list(x[1] for x in results_it)).astype(np.int_)\nmap_reduce_job: MapReduceJob[Utility, Tuple[NDArray, NDArray]] = MapReduceJob(\nu,\nmap_func=_group_testing_shapley,\nreduce_func=reducer,\nmap_kwargs=dict(n_samples=samples_per_job, progress=progress),\nconfig=config,\nn_jobs=n_jobs,\n)\nuu, betas = map_reduce_job()\n# Matrix of estimated differences. See Eqs. (3) and (4) in the paper.\nC = np.zeros(shape=(n, n))\nfor i in range(n):\nfor j in range(i + 1, n):\nC[i, j] = np.dot(uu, betas[:, i] - betas[:, j])\nC *= const.Z / T\ntotal_utility = u(u.data.indices)\n###########################################################################\n# Solution of the constraint problem with cvxpy\nv = cp.Variable(n)\nconstraints = [cp.sum(v) == total_utility]\nfor i in range(n):\nfor j in range(i + 1, n):\nconstraints.append(v[i] - v[j] &lt;= epsilon + C[i, j])\nconstraints.append(v[j] - v[i] &lt;= epsilon - C[i, j])\nproblem = cp.Problem(cp.Minimize(0), constraints)\nsolver = options.pop(\"solver\", cp.SCS)\nproblem.solve(solver=solver, **options)\nif problem.status != \"optimal\":\nlog.warning(f\"cvxpy returned status {problem.status}\")\nvalues = (\nnp.nan * np.ones_like(u.data.indices)\nif not hasattr(v.value, \"__len__\")\nelse v.value\n)\nstatus = Status.Failed\nelse:\nvalues = v.value\nstatus = Status.Converged\nreturn ValuationResult(\nalgorithm=\"group_testing_shapley\",\nstatus=status,\nvalues=values,\ndata_names=u.data.data_names,\nsolver_status=problem.status,\n)\n</code></pre>"},{"location":"code-reference/pydvl/value/shapley/knn/","title":"knn","text":"<p>This module contains Shapley computations for K-Nearest Neighbours.</p> <p>Todo</p> <p>Implement approximate KNN computation for sublinear complexity)</p>"},{"location":"code-reference/pydvl/value/shapley/knn/#pydvl.value.shapley.knn.knn_shapley","title":"<code>knn_shapley(u, *, progress=True)</code>","text":"<p>Computes exact Shapley values for a KNN classifier.</p> <p>This implements the method described in [@jia_efficient_2019a]. It exploits the local structure of K-Nearest Neighbours to reduce the number of calls to the utility function to a constant number per index, thus reducing computation time to \\(O(n)\\).</p> PARAMETER  DESCRIPTION <code>u</code> <p>Utility with a KNN model to extract parameters from. The object will not be modified nor used other than to call <code>get_params() &lt;https://scikit-learn.org/stable/modules/generated/sklearn.base.BaseEstimator.html#sklearn.base.BaseEstimator.get_params&gt;</code>_</p> <p> TYPE: <code>Utility</code> </p> <code>progress</code> <p>Whether to display a progress bar.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>ValuationResult</code> <p>Object with the data values.</p> <p>:raises TypeError: If the model in the utility is not a KNeighborsClassifier</p> <p>New in version 0.1.0</p> Source code in <code>src/pydvl/value/shapley/knn.py</code> <pre><code>def knn_shapley(u: Utility, *, progress: bool = True) -&gt; ValuationResult:\n\"\"\"Computes exact Shapley values for a KNN classifier.\n    This implements the method described in [@jia_efficient_2019a].\n    It exploits the local structure of K-Nearest Neighbours to reduce the number\n    of calls to the utility function to a constant number per index, thus\n    reducing computation time to $O(n)$.\n    Args:\n        u: Utility with a KNN model to extract parameters from. The object\n            will not be modified nor used other than to call `get_params()\n            &lt;https://scikit-learn.org/stable/modules/generated/sklearn.base.BaseEstimator.html#sklearn.base.BaseEstimator.get_params&gt;`_\n        progress: Whether to display a progress bar.\n    Returns:\n        Object with the data values.\n    :raises TypeError: If the model in the utility is not a [KNeighborsClassifier](https://scikit-learn.org/stable/modules/generated/sklearn.neighbors.KNeighborsClassifier.html)\n    !!! tip \"New in version 0.1.0\"\n    \"\"\"\nif not isinstance(u.model, KNeighborsClassifier):\nraise TypeError(\"KNN Shapley requires a K-Nearest Neighbours model\")\ndefaults: Dict[str, Union[int, str]] = {\n\"algorithm\": \"ball_tree\" if u.data.dim &gt;= 20 else \"kd_tree\",\n\"metric\": \"minkowski\",\n\"p\": 2,\n}\ndefaults.update(u.model.get_params())\n# HACK: NearestNeighbors doesn't support this. There will be more...\ndel defaults[\"weights\"]\nn_neighbors: int = int(defaults[\"n_neighbors\"])\ndefaults[\"n_neighbors\"] = len(u.data)  # We want all training points sorted\nassert n_neighbors &lt; len(u.data)\n# assert data.target_dim == 1\nnns = NearestNeighbors(**defaults).fit(u.data.x_train)\n# closest to farthest\n_, indices = nns.kneighbors(u.data.x_test)\nvalues: NDArray[np.float_] = np.zeros_like(u.data.indices, dtype=np.float_)\nn = len(u.data)\nyt = u.data.y_train\niterator = enumerate(zip(u.data.y_test, indices), start=1)\nfor j, (y, ii) in maybe_progress(iterator, progress):\nvalue_at_x = int(yt[ii[-1]] == y) / n\nvalues[ii[-1]] += (value_at_x - values[ii[-1]]) / j\nfor i in range(n - 2, n_neighbors, -1):  # farthest to closest\nvalue_at_x = (\nvalues[ii[i + 1]] + (int(yt[ii[i]] == y) - int(yt[ii[i + 1]] == y)) / i\n)\nvalues[ii[i]] += (value_at_x - values[ii[i]]) / j\nfor i in range(n_neighbors, -1, -1):  # farthest to closest\nvalue_at_x = (\nvalues[ii[i + 1]]\n+ (int(yt[ii[i]] == y) - int(yt[ii[i + 1]] == y)) / n_neighbors\n)\nvalues[ii[i]] += (value_at_x - values[ii[i]]) / j\nreturn ValuationResult(\nalgorithm=\"knn_shapley\",\nstatus=Status.Converged,\nvalues=values,\ndata_names=u.data.data_names,\n)\n</code></pre>"},{"location":"code-reference/pydvl/value/shapley/montecarlo/","title":"montecarlo","text":"<p>Monte Carlo approximations to Shapley Data values.</p> <p>Warning</p> <p>You probably want to use the common interface provided by compute_shapley_values() instead of directly using the functions in this module.</p> <p>Because exact computation of Shapley values requires \\(\\mathcal{O}(2^n)\\) re-trainings of the model, several Monte Carlo approximations are available. The first two sample from the powerset of the training data directly: combinatorial_montecarlo_shapley() and owen_sampling_shapley(). The latter uses a reformulation in terms of a continuous extension of the utility.</p> <p>Alternatively, employing another reformulation of the expression above as a sum over permutations, one has the implementation in permutation_montecarlo_shapley(), or using an early stopping strategy to reduce computation truncated_montecarlo_shapley().</p> <p>Also see</p> <p>It is also possible to use group_testing_shapley()    to reduce the number of evaluations of the utility. The method is however    typically outperformed by others in this module.</p> <p>Also see</p> <p>Additionally, you can consider grouping your data points using    GroupedDataset and computing the values of the    groups instead. This is not to be confused with \"group testing\" as    implemented in group_testing_shapley(): any of    the algorithms mentioned above, including Group Testing, can work to valuate    groups of samples as units.</p>"},{"location":"code-reference/pydvl/value/shapley/montecarlo/#pydvl.value.shapley.montecarlo.permutation_montecarlo_shapley","title":"<code>permutation_montecarlo_shapley(u, done, *, truncation=NoTruncation(), n_jobs=1, config=ParallelConfig(), progress=False)</code>","text":"<p>Computes an approximate Shapley value by sampling independent index permutations to approximate the sum:</p> \\[ v_u(x_i) = \\frac{1}{n!} \\sum_{\\sigma \\in \\Pi(n)} \\tilde{w}( | \\sigma_{:i} | )[u(\\sigma_{:i} \\cup \\{i\\}) \u2212 u(\\sigma_{:i})], \\] <p>where \\(\\sigma_{:i}\\) denotes the set of indices in permutation sigma before the position where \\(i\\) appears (see Data valuation for details).</p> PARAMETER  DESCRIPTION <code>u</code> <p>Utility object with model, data, and scoring function.</p> <p> TYPE: <code>Utility</code> </p> <code>done</code> <p>function checking whether computation must stop.</p> <p> TYPE: <code>StoppingCriterion</code> </p> <code>truncation</code> <p>An optional callable which decides whether to interrupt processing a permutation and set all subsequent marginals to zero. Typically used to stop computation when the marginal is small.</p> <p> TYPE: <code>TruncationPolicy</code> DEFAULT: <code>NoTruncation()</code> </p> <code>n_jobs</code> <p>number of jobs across which to distribute the computation.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>config</code> <p>Object configuring parallel computation, with cluster address, number of cpus, etc.</p> <p> TYPE: <code>ParallelConfig</code> DEFAULT: <code>ParallelConfig()</code> </p> <code>progress</code> <p>Whether to display progress bars for each job.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>ValuationResult</code> <p>Object with the data values.</p> Source code in <code>src/pydvl/value/shapley/montecarlo.py</code> <pre><code>def permutation_montecarlo_shapley(\nu: Utility,\ndone: StoppingCriterion,\n*,\ntruncation: TruncationPolicy = NoTruncation(),\nn_jobs: int = 1,\nconfig: ParallelConfig = ParallelConfig(),\nprogress: bool = False,\n) -&gt; ValuationResult:\nr\"\"\"Computes an approximate Shapley value by sampling independent index\n    permutations to approximate the sum:\n    $$\n    v_u(x_i) = \\frac{1}{n!} \\sum_{\\sigma \\in \\Pi(n)}\n    \\tilde{w}( | \\sigma_{:i} | )[u(\\sigma_{:i} \\cup \\{i\\}) \u2212 u(\\sigma_{:i})],\n    $$\n    where $\\sigma_{:i}$ denotes the set of indices in permutation sigma before the\n    position where $i$ appears (see [Data valuation][computing-data-values] for details).\n    Args:\n        u: Utility object with model, data, and scoring function.\n        done: function checking whether computation must stop.\n        truncation: An optional callable which decides whether to interrupt\n            processing a permutation and set all subsequent marginals to\n            zero. Typically used to stop computation when the marginal is small.\n        n_jobs: number of jobs across which to distribute the computation.\n        config: Object configuring parallel computation, with cluster address,\n            number of cpus, etc.\n        progress: Whether to display progress bars for each job.\n    Returns:\n        Object with the data values.\n    \"\"\"\nmap_reduce_job: MapReduceJob[Utility, ValuationResult] = MapReduceJob(\nu,\nmap_func=_permutation_montecarlo_shapley,\nreduce_func=lambda results: reduce(operator.add, results),\nmap_kwargs=dict(\nalgorithm_name=\"permutation_montecarlo_shapley\",\ndone=done,\ntruncation=truncation,\nprogress=progress,\n),\nconfig=config,\nn_jobs=n_jobs,\n)\nreturn map_reduce_job()\n</code></pre>"},{"location":"code-reference/pydvl/value/shapley/montecarlo/#pydvl.value.shapley.montecarlo.combinatorial_montecarlo_shapley","title":"<code>combinatorial_montecarlo_shapley(u, done, *, n_jobs=1, config=ParallelConfig(), progress=False)</code>","text":"<p>Computes an approximate Shapley value using the combinatorial definition:</p> \\[v_u(i) = \\frac{1}{n} \\sum_{S \\subseteq N \\setminus \\{i\\}} \\binom{n-1}{ | S | }^{-1} [u(S \\cup \\{i\\}) \u2212 u(S)]\\] <p>This consists of randomly sampling subsets of the power set of the training indices in data, and computing their marginal utilities. See Data valuation for details.</p> <p>Note that because sampling is done with replacement, the approximation is poor even for \\(2^{m}\\) subsets with \\(m&gt;n\\), even though there are \\(2^{n-1}\\) subsets for each \\(i\\). Prefer permutation_montecarlo_shapley().</p> <p>Parallelization is done by splitting the set of indices across processes and computing the sum over subsets \\(S \\subseteq N \\setminus \\{i\\}\\) separately.</p> PARAMETER  DESCRIPTION <code>u</code> <p>Utility object with model, data, and scoring function</p> <p> TYPE: <code>Utility</code> </p> <code>done</code> <p>Stopping criterion for the computation.</p> <p> TYPE: <code>StoppingCriterion</code> </p> <code>n_jobs</code> <p>number of parallel jobs across which to distribute the computation. Each worker receives a chunk of indices</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>config</code> <p>Object configuring parallel computation, with cluster address, number of cpus, etc.</p> <p> TYPE: <code>ParallelConfig</code> DEFAULT: <code>ParallelConfig()</code> </p> <code>progress</code> <p>Whether to display progress bars for each job.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>ValuationResult</code> <p>Object with the data values.</p> Source code in <code>src/pydvl/value/shapley/montecarlo.py</code> <pre><code>def combinatorial_montecarlo_shapley(\nu: Utility,\ndone: StoppingCriterion,\n*,\nn_jobs: int = 1,\nconfig: ParallelConfig = ParallelConfig(),\nprogress: bool = False,\n) -&gt; ValuationResult:\nr\"\"\"Computes an approximate Shapley value using the combinatorial\n    definition:\n    $$v_u(i) = \\frac{1}{n} \\sum_{S \\subseteq N \\setminus \\{i\\}}\n    \\binom{n-1}{ | S | }^{-1} [u(S \\cup \\{i\\}) \u2212 u(S)]$$\n    This consists of randomly sampling subsets of the power set of the training\n    indices in [data][pydvl.utils.utility.Utility.data], and computing their\n    marginal utilities. See [Data valuation][computing-data-values] for details.\n    Note that because sampling is done with replacement, the approximation is\n    poor even for $2^{m}$ subsets with $m&gt;n$, even though there are $2^{n-1}$\n    subsets for each $i$. Prefer\n    [permutation_montecarlo_shapley()][pydvl.value.shapley.montecarlo.permutation_montecarlo_shapley].\n    Parallelization is done by splitting the set of indices across processes and\n    computing the sum over subsets $S \\subseteq N \\setminus \\{i\\}$ separately.\n    Args:\n        u: Utility object with model, data, and scoring function\n        done: Stopping criterion for the computation.\n        n_jobs: number of parallel jobs across which to distribute the\n            computation. Each worker receives a chunk of\n            [indices][pydvl.utils.dataset.Dataset.indices]\n        config: Object configuring parallel computation, with cluster address,\n            number of cpus, etc.\n        progress: Whether to display progress bars for each job.\n    Returns:\n        Object with the data values.\n    \"\"\"\nmap_reduce_job: MapReduceJob[NDArray, ValuationResult] = MapReduceJob(\nu.data.indices,\nmap_func=_combinatorial_montecarlo_shapley,\nreduce_func=lambda results: reduce(operator.add, results),\nmap_kwargs=dict(u=u, done=done, progress=progress),\nn_jobs=n_jobs,\nconfig=config,\n)\nreturn map_reduce_job()\n</code></pre>"},{"location":"code-reference/pydvl/value/shapley/naive/","title":"naive","text":""},{"location":"code-reference/pydvl/value/shapley/naive/#pydvl.value.shapley.naive.permutation_exact_shapley","title":"<code>permutation_exact_shapley(u, *, progress=True)</code>","text":"<p>Computes the exact Shapley value using the formulation with permutations:</p> \\[v_u(x_i) = \\frac{1}{n!} \\sum_{\\sigma \\in \\Pi(n)} [u(\\sigma_{i-1} \\cup {i}) \u2212 u(\\sigma_{i})].\\] <p>See Data valuation for details.</p> <p>When the length of the training set is &gt; 10 this prints a warning since the computation becomes too expensive. Used mostly for internal testing and simple use cases. Please refer to the Monte Carlo approximations for practical applications.</p> PARAMETER  DESCRIPTION <code>u</code> <p>Utility object with model, data, and scoring function</p> <p> TYPE: <code>Utility</code> </p> <code>progress</code> <p>Whether to display progress bars for each job.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>ValuationResult</code> <p>Object with the data values.</p> Source code in <code>src/pydvl/value/shapley/naive.py</code> <pre><code>def permutation_exact_shapley(u: Utility, *, progress: bool = True) -&gt; ValuationResult:\nr\"\"\"Computes the exact Shapley value using the formulation with permutations:\n    $$v_u(x_i) = \\frac{1}{n!} \\sum_{\\sigma \\in \\Pi(n)} [u(\\sigma_{i-1} \\cup {i}) \u2212 u(\\sigma_{i})].$$\n    See [Data valuation][computing-data-values] for details.\n    When the length of the training set is &gt; 10 this prints a warning since the\n    computation becomes too expensive. Used mostly for internal testing and\n    simple use cases. Please refer to the [Monte Carlo\n    approximations][pydvl.value.shapley.montecarlo] for practical applications.\n    Args:\n        u: Utility object with model, data, and scoring function\n        progress: Whether to display progress bars for each job.\n    Returns:\n        Object with the data values.\n    \"\"\"\nn = len(u.data)\n# Note that the cache in utility saves most of the refitting because we\n# use frozenset for the input.\nif n &gt; 10:\nwarnings.warn(\nf\"Large dataset! Computation requires {n}! calls to utility()\",\nRuntimeWarning,\n)\nvalues = np.zeros(n)\nfor p in maybe_progress(\npermutations(u.data.indices),\nprogress,\ndesc=\"Permutation\",\ntotal=math.factorial(n),\n):\nfor i, idx in enumerate(p):\nvalues[idx] += u(p[: i + 1]) - u(p[:i])\nvalues /= math.factorial(n)\nreturn ValuationResult(\nalgorithm=\"permutation_exact_shapley\",\nstatus=Status.Converged,\nvalues=values,\ndata_names=u.data.data_names,\n)\n</code></pre>"},{"location":"code-reference/pydvl/value/shapley/naive/#pydvl.value.shapley.naive.combinatorial_exact_shapley","title":"<code>combinatorial_exact_shapley(u, *, n_jobs=1, config=ParallelConfig(), progress=False)</code>","text":"<p>Computes the exact Shapley value using the combinatorial definition.</p> \\[v_u(i) = \\frac{1}{n} \\sum_{S \\subseteq N \\setminus \\{i\\}} \\binom{n-1}{ | S | }^{-1} [u(S \\cup \\{i\\}) \u2212 u(S)].\\] <p>See Data valuation for details.</p> <p>Note</p> <p>If the length of the training set is &gt; n_jobs*20 this prints a warning because the computation is very expensive. Used mostly for internal testing and simple use cases. Please refer to the Monte Carlo approximations for practical applications.</p> PARAMETER  DESCRIPTION <code>u</code> <p>Utility object with model, data, and scoring function</p> <p> TYPE: <code>Utility</code> </p> <code>n_jobs</code> <p>Number of parallel jobs to use</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>config</code> <p>Object configuring parallel computation, with cluster address, number of cpus, etc.</p> <p> TYPE: <code>ParallelConfig</code> DEFAULT: <code>ParallelConfig()</code> </p> <code>progress</code> <p>Whether to display progress bars for each job.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>ValuationResult</code> <p>Object with the data values.</p> Source code in <code>src/pydvl/value/shapley/naive.py</code> <pre><code>def combinatorial_exact_shapley(\nu: Utility,\n*,\nn_jobs: int = 1,\nconfig: ParallelConfig = ParallelConfig(),\nprogress: bool = False,\n) -&gt; ValuationResult:\nr\"\"\"Computes the exact Shapley value using the combinatorial definition.\n    $$v_u(i) = \\frac{1}{n} \\sum_{S \\subseteq N \\setminus \\{i\\}} \\binom{n-1}{ | S | }^{-1} [u(S \\cup \\{i\\}) \u2212 u(S)].$$\n    See [Data valuation][computing-data-values] for details.\n    !!! Note\n        If the length of the training set is &gt; n_jobs*20 this prints a warning\n        because the computation is very expensive. Used mostly for internal testing\n        and simple use cases. Please refer to the\n        [Monte Carlo][pydvl.value.shapley.montecarlo] approximations for practical\n        applications.\n    Args:\n        u: Utility object with model, data, and scoring function\n        n_jobs: Number of parallel jobs to use\n        config: Object configuring parallel computation, with cluster address,\n            number of cpus, etc.\n        progress: Whether to display progress bars for each job.\n    Returns:\n        Object with the data values.\n    \"\"\"\n# Arbitrary choice, will depend on time required, caching, etc.\nif len(u.data) // n_jobs &gt; 20:\nwarnings.warn(\nf\"Large dataset! Computation requires 2^{len(u.data)} calls to model.fit()\"\n)\ndef reduce_fun(results: List[NDArray]) -&gt; NDArray:\nreturn np.array(results).sum(axis=0)  # type: ignore\nmap_reduce_job: MapReduceJob[NDArray, NDArray] = MapReduceJob(\nu.data.indices,\nmap_func=_combinatorial_exact_shapley,\nmap_kwargs=dict(u=u, progress=progress),\nreduce_func=reduce_fun,\nn_jobs=n_jobs,\nconfig=config,\n)\nvalues = map_reduce_job()\nreturn ValuationResult(\nalgorithm=\"combinatorial_exact_shapley\",\nstatus=Status.Converged,\nvalues=values,\ndata_names=u.data.data_names,\n)\n</code></pre>"},{"location":"code-reference/pydvl/value/shapley/owen/","title":"owen","text":""},{"location":"code-reference/pydvl/value/shapley/owen/#pydvl.value.shapley.owen.owen_sampling_shapley","title":"<code>owen_sampling_shapley(u, n_samples, max_q, *, method=OwenAlgorithm.Standard, n_jobs=1, config=ParallelConfig(), progress=False)</code>","text":"<p>Owen sampling of Shapley values as described in [@okhrati_multilinear_2021].</p> <p>This function computes a Monte Carlo approximation to</p> \\[v_u(i) = \\int_0^1 \\mathbb{E}_{S \\sim P_q(D_{\\backslash \\{i\\}})} [u(S \\cup \\{i\\}) - u(S)]\\] <p>using one of two methods. The first one, selected with the argument <code>mode = OwenAlgorithm.Standard</code>, approximates the integral with:</p> \\[\\hat{v}_u(i) = \\frac{1}{Q M} \\sum_{j=0}^Q \\sum_{m=1}^M [u(S^{(q_j)}_m \\cup \\{i\\}) - u(S^{(q_j)}_m)],\\] <p>where \\(q_j = \\frac{j}{Q} \\in [0,1]\\) and the sets \\(S^{(q_j)}\\) are such that a sample \\(x \\in S^{(q_j)}\\) if a draw from a \\(Ber(q_j)\\) distribution is 1.</p> <p>The second method, selected with the argument <code>mode = OwenAlgorithm.Antithetic</code>, uses correlated samples in the inner sum to reduce the variance:</p> \\[\\hat{v}_u(i) = \\frac{1}{2 Q M} \\sum_{j=0}^Q \\sum_{m=1}^M [u(S^{(q_j)}_m \\cup \\{i\\}) - u(S^{(q_j)}_m) + u((S^{(q_j)}_m)^c \\cup \\{i\\}) - u((S^{( q_j)}_m)^c)],\\] <p>where now \\(q_j = \\frac{j}{2Q} \\in [0,\\frac{1}{2}]\\), and \\(S^c\\) is the complement of \\(S\\).</p> <p>Note</p> <p>The outer integration could be done instead with a quadrature rule.</p> PARAMETER  DESCRIPTION <code>u</code> <p>Utility object holding data, model and scoring function.</p> <p> TYPE: <code>Utility</code> </p> <code>n_samples</code> <p>Numer of sets to sample for each value of q</p> <p> TYPE: <code>int</code> </p> <code>max_q</code> <p>Number of subdivisions for q \u2208 [0,1] (the element sampling probability) used to approximate the outer integral.</p> <p> TYPE: <code>int</code> </p> <code>method</code> <p>Selects the algorithm to use, see the description. Either Full for \\(q \\in [0,1]\\) or Halved for \\(q \\in [0,0.5]\\) and correlated samples</p> <p> TYPE: <code>OwenAlgorithm</code> DEFAULT: <code>Standard</code> </p> <code>n_jobs</code> <p>Number of parallel jobs to use. Each worker receives a chunk of the total of <code>max_q</code> values for q.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>config</code> <p>Object configuring parallel computation, with cluster address, number of cpus, etc.</p> <p> TYPE: <code>ParallelConfig</code> DEFAULT: <code>ParallelConfig()</code> </p> <code>progress</code> <p>Whether to display progress bars for each job.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>ValuationResult</code> <p>Object with the data values.</p> <p>New in version 0.3.0</p> <p>Changed in version 0.5.0</p> <p>Support for parallel computation and enable antithetic sampling.</p> Source code in <code>src/pydvl/value/shapley/owen.py</code> <pre><code>def owen_sampling_shapley(\nu: Utility,\nn_samples: int,\nmax_q: int,\n*,\nmethod: OwenAlgorithm = OwenAlgorithm.Standard,\nn_jobs: int = 1,\nconfig: ParallelConfig = ParallelConfig(),\nprogress: bool = False,\n) -&gt; ValuationResult:\nr\"\"\"Owen sampling of Shapley values as described in\n    [@okhrati_multilinear_2021].\n    This function computes a Monte Carlo approximation to\n    $$v_u(i) = \\int_0^1 \\mathbb{E}_{S \\sim P_q(D_{\\backslash \\{i\\}})}\n    [u(S \\cup \\{i\\}) - u(S)]$$\n    using one of two methods. The first one, selected with the argument ``mode =\n    OwenAlgorithm.Standard``, approximates the integral with:\n    $$\\hat{v}_u(i) = \\frac{1}{Q M} \\sum_{j=0}^Q \\sum_{m=1}^M [u(S^{(q_j)}_m\n    \\cup \\{i\\}) - u(S^{(q_j)}_m)],$$\n    where $q_j = \\frac{j}{Q} \\in [0,1]$ and the sets $S^{(q_j)}$ are such that a\n    sample $x \\in S^{(q_j)}$ if a draw from a $Ber(q_j)$ distribution is 1.\n    The second method, selected with the argument ``mode =\n    OwenAlgorithm.Antithetic``, uses correlated samples in the inner sum to\n    reduce the variance:\n    $$\\hat{v}_u(i) = \\frac{1}{2 Q M} \\sum_{j=0}^Q \\sum_{m=1}^M [u(S^{(q_j)}_m\n    \\cup \\{i\\}) - u(S^{(q_j)}_m) + u((S^{(q_j)}_m)^c \\cup \\{i\\}) - u((S^{(\n    q_j)}_m)^c)],$$\n    where now $q_j = \\frac{j}{2Q} \\in [0,\\frac{1}{2}]$, and $S^c$ is the\n    complement of $S$.\n    !!! Note\n        The outer integration could be done instead with a quadrature rule.\n    Args:\n        u: [Utility][pydvl.utils.utility.Utility] object holding data, model\n            and scoring function.\n        n_samples: Numer of sets to sample for each value of q\n        max_q: Number of subdivisions for q \u2208 [0,1] (the element sampling\n            probability) used to approximate the outer integral.\n        method: Selects the algorithm to use, see the description. Either\n            [Full][pydvl.value.shapley.owen.OwenAlgorithm.Full] for $q \\in [0,1]$\n            or [Halved][pydvl.value.shapley.owen.OwenAlgorithm.Halved] for\n            $q \\in [0,0.5]$ and correlated samples\n        n_jobs: Number of parallel jobs to use. Each worker receives a chunk\n            of the total of `max_q` values for q.\n        config: Object configuring parallel computation, with cluster address,\n            number of cpus, etc.\n        progress: Whether to display progress bars for each job.\n    Returns:\n        Object with the data values.\n    !!! tip \"New in version 0.3.0\"\n    !!! tip \"Changed in version 0.5.0\"\n        Support for parallel computation and enable antithetic sampling.\n    \"\"\"\nmap_reduce_job: MapReduceJob[NDArray, ValuationResult] = MapReduceJob(\nu.data.indices,\nmap_func=_owen_sampling_shapley,\nreduce_func=lambda results: reduce(operator.add, results),\nmap_kwargs=dict(\nu=u,\nmethod=OwenAlgorithm(method),\nn_samples=n_samples,\nmax_q=max_q,\nprogress=progress,\n),\nn_jobs=n_jobs,\nconfig=config,\n)\nreturn map_reduce_job()\n</code></pre>"},{"location":"code-reference/pydvl/value/shapley/truncated/","title":"truncated","text":""},{"location":"code-reference/pydvl/value/shapley/truncated/#pydvl.value.shapley.truncated.TruncationPolicy","title":"<code>TruncationPolicy()</code>","text":"<p>             Bases: <code>ABC</code></p> <p>A policy for deciding whether to stop computing marginals in a permutation.</p> <p>Statistics are kept on the number of calls and truncations as n_calls and n_truncations respectively.</p> ATTRIBUTE DESCRIPTION <code>n_calls</code> <p>Number of calls to the policy.</p> <p> TYPE: <code>int</code> </p> <code>n_truncations</code> <p>Number of truncations made by the policy.</p> <p> TYPE: <code>int</code> </p> <p>Todo</p> <p>Because the policy objects are copied to the workers, the statistics are not accessible from the coordinating process. We need to add methods for this.</p> Source code in <code>src/pydvl/value/shapley/truncated.py</code> <pre><code>def __init__(self):\nself.n_calls: int = 0\nself.n_truncations: int = 0\n</code></pre>"},{"location":"code-reference/pydvl/value/shapley/truncated/#pydvl.value.shapley.truncated.TruncationPolicy.reset","title":"<code>reset()</code>  <code>abstractmethod</code>","text":"<p>Reset the policy to a state ready for a new permutation.</p> Source code in <code>src/pydvl/value/shapley/truncated.py</code> <pre><code>@abc.abstractmethod\ndef reset(self):\n\"\"\"Reset the policy to a state ready for a new permutation.\"\"\"\n...\n</code></pre>"},{"location":"code-reference/pydvl/value/shapley/truncated/#pydvl.value.shapley.truncated.TruncationPolicy.__call__","title":"<code>__call__(idx, score)</code>","text":"<p>Check whether the computation should be interrupted.</p> PARAMETER  DESCRIPTION <code>idx</code> <p>Position in the permutation currently being computed.</p> <p> TYPE: <code>int</code> </p> <code>score</code> <p>Last utility computed.</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>bool</code> <p><code>True</code> if the computation should be interrupted.</p> Source code in <code>src/pydvl/value/shapley/truncated.py</code> <pre><code>def __call__(self, idx: int, score: float) -&gt; bool:\n\"\"\"Check whether the computation should be interrupted.\n    Args:\n        idx: Position in the permutation currently being computed.\n        score: Last utility computed.\n    Returns:\n        `True` if the computation should be interrupted.\n    \"\"\"\nret = self._check(idx, score)\nself.n_calls += 1\nself.n_truncations += 1 if ret else 0\nreturn ret\n</code></pre>"},{"location":"code-reference/pydvl/value/shapley/truncated/#pydvl.value.shapley.truncated.NoTruncation","title":"<code>NoTruncation</code>","text":"<p>             Bases: <code>TruncationPolicy</code></p> <p>A policy which never interrupts the computation.</p>"},{"location":"code-reference/pydvl/value/shapley/truncated/#pydvl.value.shapley.truncated.FixedTruncation","title":"<code>FixedTruncation(u, fraction)</code>","text":"<p>             Bases: <code>TruncationPolicy</code></p> <p>Break a permutation after computing a fixed number of marginals.</p> PARAMETER  DESCRIPTION <code>u</code> <p>Utility object with model, data, and scoring function</p> <p> TYPE: <code>Utility</code> </p> <code>fraction</code> <p>Fraction of marginals in a permutation to compute before stopping (e.g. 0.5 to compute half of the marginals).</p> <p> TYPE: <code>float</code> </p> Source code in <code>src/pydvl/value/shapley/truncated.py</code> <pre><code>def __init__(self, u: Utility, fraction: float):\nsuper().__init__()\nif fraction &lt;= 0 or fraction &gt; 1:\nraise ValueError(\"fraction must be in (0, 1]\")\nself.max_marginals = len(u.data) * fraction\nself.count = 0\n</code></pre>"},{"location":"code-reference/pydvl/value/shapley/truncated/#pydvl.value.shapley.truncated.RelativeTruncation","title":"<code>RelativeTruncation(u, rtol)</code>","text":"<p>             Bases: <code>TruncationPolicy</code></p> <p>Break a permutation if the marginal utility is too low.</p> <p>This is called \"performance tolerance\" in [@ghorbani_data_2019].</p> PARAMETER  DESCRIPTION <code>u</code> <p>Utility object with model, data, and scoring function</p> <p> TYPE: <code>Utility</code> </p> <code>rtol</code> <p>Relative tolerance. The permutation is broken if the last computed utility is less than <code>total_utility * rtol</code>.</p> <p> TYPE: <code>float</code> </p> Source code in <code>src/pydvl/value/shapley/truncated.py</code> <pre><code>def __init__(self, u: Utility, rtol: float):\nsuper().__init__()\nself.rtol = rtol\nlogger.info(\"Computing total utility for permutation truncation.\")\nself.total_utility = u(u.data.indices)\n</code></pre>"},{"location":"code-reference/pydvl/value/shapley/truncated/#pydvl.value.shapley.truncated.BootstrapTruncation","title":"<code>BootstrapTruncation(u, n_samples, sigmas=1)</code>","text":"<p>             Bases: <code>TruncationPolicy</code></p> <p>Break a permutation if the last computed utility is close to the total utility, measured as a multiple of the standard deviation of the utilities.</p> PARAMETER  DESCRIPTION <code>u</code> <p>Utility object with model, data, and scoring function</p> <p> TYPE: <code>Utility</code> </p> <code>n_samples</code> <p>Number of bootstrap samples to use to compute the variance of the utilities.</p> <p> TYPE: <code>int</code> </p> <code>sigmas</code> <p>Number of standard deviations to use as a threshold.</p> <p> TYPE: <code>float</code> DEFAULT: <code>1</code> </p> Source code in <code>src/pydvl/value/shapley/truncated.py</code> <pre><code>def __init__(self, u: Utility, n_samples: int, sigmas: float = 1):\nsuper().__init__()\nself.n_samples = n_samples\nlogger.info(\"Computing total utility for permutation truncation.\")\nself.total_utility = u(u.data.indices)\nself.count: int = 0\nself.variance: float = 0\nself.mean: float = 0\nself.sigmas: float = sigmas\n</code></pre>"},{"location":"code-reference/pydvl/value/shapley/truncated/#pydvl.value.shapley.truncated.truncated_montecarlo_shapley","title":"<code>truncated_montecarlo_shapley(u, *, done, truncation, config=ParallelConfig(), n_jobs=1, coordinator_update_period=10, worker_update_period=5)</code>","text":"<p>Monte Carlo approximation to the Shapley value of data points.</p> <p>This implements the permutation-based method described in [@ghorbani_data_2019]. It is a Monte Carlo estimate of the sum over all possible permutations of the index set, with a double stopping criterion.</p> <p>Todo</p> <p>Think of how to add Robin-Gelman or some other more principled stopping criterion.</p> <p>Instead of naively implementing the expectation, we sequentially add points to a dataset from a permutation and incrementally compute marginal utilities. We stop computing marginals for a given permutation based on a TruncationPolicy. [@ghorbani_data_2019] mention two policies: one that stops after a certain fraction of marginals are computed, implemented in FixedTruncation, and one that stops if the last computed utility (\"score\") is close to the total utility using the standard deviation of the utility as a measure of proximity, implemented in BootstrapTruncation.</p> <p>We keep sampling permutations and updating all shapley values until the StoppingCriterion returns <code>True</code>.</p> PARAMETER  DESCRIPTION <code>u</code> <p>Utility object with model, data, and scoring function</p> <p> TYPE: <code>Utility</code> </p> <code>done</code> <p>Check on the results which decides when to stop sampling permutations.</p> <p> TYPE: <code>StoppingCriterion</code> </p> <code>truncation</code> <p>callable that decides whether to stop computing marginals for a given permutation.</p> <p> TYPE: <code>TruncationPolicy</code> </p> <code>config</code> <p>Object configuring parallel computation, with cluster address, number of cpus, etc.</p> <p> TYPE: <code>ParallelConfig</code> DEFAULT: <code>ParallelConfig()</code> </p> <code>n_jobs</code> <p>Number of permutation monte carlo jobs to run concurrently.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>coordinator_update_period</code> <p>in seconds. How often to check the accumulated results from the workers for convergence.</p> <p> TYPE: <code>int</code> DEFAULT: <code>10</code> </p> <code>worker_update_period</code> <p>interval in seconds between different updates to and from the coordinator</p> <p> TYPE: <code>int</code> DEFAULT: <code>5</code> </p> RETURNS DESCRIPTION <code>ValuationResult</code> <p>Object with the data values.</p> Source code in <code>src/pydvl/value/shapley/truncated.py</code> <pre><code>@deprecated(\ntarget=True,\ndeprecated_in=\"0.6.1\",\nremove_in=\"0.7.0\",\nargs_mapping=dict(coordinator_update_period=None, worker_update_period=None),\n)\ndef truncated_montecarlo_shapley(\nu: Utility,\n*,\ndone: StoppingCriterion,\ntruncation: TruncationPolicy,\nconfig: ParallelConfig = ParallelConfig(),\nn_jobs: int = 1,\ncoordinator_update_period: int = 10,\nworker_update_period: int = 5,\n) -&gt; ValuationResult:\n\"\"\"Monte Carlo approximation to the Shapley value of data points.\n    This implements the permutation-based method described in\n    [@ghorbani_data_2019]. It is a Monte Carlo estimate of the sum\n    over all possible permutations of the index set, with a double stopping\n    criterion.\n    !!! Todo\n        Think of how to add Robin-Gelman or some other more principled stopping\n        criterion.\n    Instead of naively implementing the expectation, we sequentially add points\n    to a dataset from a permutation and incrementally compute marginal utilities.\n    We stop computing marginals for a given permutation based on a\n    [TruncationPolicy][pydvl.value.shapley.truncated.TruncationPolicy].\n    [@ghorbani_data_2019] mention two policies: one that stops after a certain\n    fraction of marginals are computed, implemented in\n    [FixedTruncation][pydvl.value.shapley.truncated.FixedTruncation], and one\n    that stops if the last computed utility (\"score\") is close to the total\n    utility using the standard deviation of the utility as a measure of proximity,\n    implemented in\n    [BootstrapTruncation][pydvl.value.shapley.truncated.BootstrapTruncation].\n    We keep sampling permutations and updating all shapley values until the\n    [StoppingCriterion][pydvl.value.stopping.StoppingCriterion] returns `True`.\n    Args:\n        u: Utility object with model, data, and scoring function\n        done: Check on the results which decides when to stop sampling\n            permutations.\n        truncation: callable that decides whether to stop computing marginals\n            for a given permutation.\n        config: Object configuring parallel computation, with cluster address,\n            number of cpus, etc.\n        n_jobs: Number of permutation monte carlo jobs to run concurrently.\n        coordinator_update_period: in seconds. How often to check the\n            accumulated results from the workers for convergence.\n        worker_update_period: interval in seconds between different updates to\n            and from the coordinator\n    Returns:\n        Object with the data values.\n    \"\"\"\nalgorithm = \"truncated_montecarlo_shapley\"\nparallel_backend = init_parallel_backend(config)\nu = parallel_backend.put(u)\n# This represents the number of jobs that are running\nn_jobs = effective_n_jobs(n_jobs, config)\n# This determines the total number of submitted jobs\n# including the ones that are running\nn_submitted_jobs = 2 * n_jobs\naccumulated_result = ValuationResult.zeros(algorithm=algorithm)\nwith init_executor(max_workers=n_jobs, config=config) as executor:\nfutures = set()\n# Initial batch of computations\nfor _ in range(n_submitted_jobs):\nfuture = executor.submit(\n_permutation_montecarlo_one_step,\nu,\ntruncation,\nalgorithm,\n)\nfutures.add(future)\nwhile futures:\n# Wait for the next futures to complete.\ncompleted_futures, futures = wait(\nfutures, timeout=60, return_when=FIRST_COMPLETED\n)\nfor future in completed_futures:\naccumulated_result += future.result()\nif done(accumulated_result):\nbreak\nif done(accumulated_result):\nbreak\n# Submit more computations\n# The goal is to always have `n_jobs`\n# computations running\nfor _ in range(n_submitted_jobs - len(futures)):\nfuture = executor.submit(\n_permutation_montecarlo_one_step,\nu,\ntruncation,\nalgorithm,\n)\nfutures.add(future)\nreturn accumulated_result\n</code></pre>"},{"location":"code-reference/pydvl/value/shapley/types/","title":"types","text":""},{"location":"code-reference/pydvl/value/shapley/types/#pydvl.value.shapley.types.ShapleyMode","title":"<code>ShapleyMode</code>","text":"<p>             Bases: <code>str</code>, <code>Enum</code></p> <p>Supported algorithms for the computation of Shapley values.</p> <p>Todo</p> <p>Make algorithms register themselves here.</p>"},{"location":"examples/","title":"Examples","text":"<p>This section contains worked-out examples illustrating pyDVL's capabilities.</p> <p>Use the navigation bar on the left to go through them.</p>"},{"location":"examples/influence_imagenet/","title":"Influence functions for neural networks","text":"<p>If you are reading this in the documentation, some boilerplate has been omitted for convenience.</p> In\u00a0[1]: Copied! <pre>%load_ext autoreload\n</pre> %load_ext autoreload In\u00a0[2]: Copied! <pre>%autoreload\n%matplotlib inline\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport os\nimport pandas as pd\nimport torch\nfrom torch import nn\nfrom notebook_support import (\n    plot_sample_images,\n    plot_lowest_highest_influence_images,\n    plot_losses,\n    corrupt_imagenet,\n    load_preprocess_imagenet,\n    plot_corrupted_influences_distribution,\n    compute_mean_corrupted_influences,\n    TrainingManager,\n    MODEL_PATH,\n    new_resnet_model,\n)\n\n\ndefault_figsize = (7, 7)\nplt.rcParams[\"figure.figsize\"] = default_figsize\nplt.rcParams[\"font.size\"] = 12\nplt.rcParams[\"xtick.labelsize\"] = 12\nplt.rcParams[\"ytick.labelsize\"] = 10\nhessian_reg = 1e4 if os.environ.get(\"CI\") else 1e-3\nrandom_state = 42\nnp.random.seed(random_state)\nDEVICE = torch.device(\"cuda:0\" if torch.cuda.is_available() else \"cpu\")\n</pre> %autoreload %matplotlib inline  import matplotlib.pyplot as plt import numpy as np import os import pandas as pd import torch from torch import nn from notebook_support import (     plot_sample_images,     plot_lowest_highest_influence_images,     plot_losses,     corrupt_imagenet,     load_preprocess_imagenet,     plot_corrupted_influences_distribution,     compute_mean_corrupted_influences,     TrainingManager,     MODEL_PATH,     new_resnet_model, )   default_figsize = (7, 7) plt.rcParams[\"figure.figsize\"] = default_figsize plt.rcParams[\"font.size\"] = 12 plt.rcParams[\"xtick.labelsize\"] = 12 plt.rcParams[\"ytick.labelsize\"] = 10 hessian_reg = 1e4 if os.environ.get(\"CI\") else 1e-3 random_state = 42 np.random.seed(random_state) DEVICE = torch.device(\"cuda:0\" if torch.cuda.is_available() else \"cpu\") In\u00a0[3]: Copied! <pre>from pydvl.influence.general import compute_influences\nfrom pydvl.reporting.plots import plot_influence_distribution_by_label\nfrom sklearn.metrics import confusion_matrix, ConfusionMatrixDisplay, f1_score\n</pre> from pydvl.influence.general import compute_influences from pydvl.reporting.plots import plot_influence_distribution_by_label from sklearn.metrics import confusion_matrix, ConfusionMatrixDisplay, f1_score In\u00a0[4]: Copied! <pre>label_names = {90: \"tables\", 100: \"boats\"}\ntrain_ds, val_ds, test_ds = load_preprocess_imagenet(\n    train_size=0.8,\n    test_size=0.1,\n    keep_labels=label_names,\n    downsampling_ratio=1,\n)\n\nprint(\"Normalised image dtype:\", train_ds[\"normalized_images\"][0].dtype)\nprint(\"Label type:\", type(train_ds[\"labels\"][0]))\nprint(\"Image type:\", type(train_ds[\"images\"][0]))\ntrain_ds.info()\n</pre> label_names = {90: \"tables\", 100: \"boats\"} train_ds, val_ds, test_ds = load_preprocess_imagenet(     train_size=0.8,     test_size=0.1,     keep_labels=label_names,     downsampling_ratio=1, )  print(\"Normalised image dtype:\", train_ds[\"normalized_images\"][0].dtype) print(\"Label type:\", type(train_ds[\"labels\"][0])) print(\"Image type:\", type(train_ds[\"images\"][0])) train_ds.info() <pre>Normalised image dtype: torch.float32\nLabel type: &lt;class 'str'&gt;\nImage type: &lt;class 'PIL.JpegImagePlugin.JpegImageFile'&gt;\n&lt;class 'pandas.core.frame.DataFrame'&gt;\nRangeIndex: 707 entries, 0 to 706\nData columns (total 3 columns):\n #   Column             Non-Null Count  Dtype \n---  ------             --------------  ----- \n 0   normalized_images  707 non-null    object\n 1   labels             707 non-null    object\n 2   images             707 non-null    object\ndtypes: object(3)\nmemory usage: 16.7+ KB\n</pre> <p>Let's take a closer look at a few image samples</p> In\u00a0[5]: Copied! <pre>plot_sample_images(train_ds, n_images_per_class=3)\n</pre> plot_sample_images(train_ds, n_images_per_class=3) <p>Let's now further pre-process the data and prepare for model training. The helper function <code>process_io</code> converts the normalized images into tensors and the labels to the indices 0 and 1 to train the classifier.</p> In\u00a0[6]: Copied! <pre>from typing import Tuple\n\n\ndef process_io(df: pd.DataFrame, labels: dict) -&gt; Tuple[torch.Tensor, torch.Tensor]:\n    x = df[\"normalized_images\"]\n    y = df[\"labels\"]\n    ds_label_to_model_label = {\n        ds_label: idx for idx, ds_label in enumerate(labels.values())\n    }\n    x_nn = torch.stack(x.tolist()).to(DEVICE)\n    y_nn = torch.tensor([ds_label_to_model_label[yi] for yi in y], device=DEVICE)\n    return x_nn, y_nn\n\n\ntrain_x, train_y = process_io(train_ds, label_names)\nval_x, val_y = process_io(val_ds, label_names)\ntest_x, test_y = process_io(test_ds, label_names)\n</pre> from typing import Tuple   def process_io(df: pd.DataFrame, labels: dict) -&gt; Tuple[torch.Tensor, torch.Tensor]:     x = df[\"normalized_images\"]     y = df[\"labels\"]     ds_label_to_model_label = {         ds_label: idx for idx, ds_label in enumerate(labels.values())     }     x_nn = torch.stack(x.tolist()).to(DEVICE)     y_nn = torch.tensor([ds_label_to_model_label[yi] for yi in y], device=DEVICE)     return x_nn, y_nn   train_x, train_y = process_io(train_ds, label_names) val_x, val_y = process_io(val_ds, label_names) test_x, test_y = process_io(test_ds, label_names) In\u00a0[7]: Copied! <pre>model_ft = new_resnet_model(output_size=len(label_names))\nmgr = TrainingManager(\n    \"model_ft\",\n    model_ft,\n    nn.CrossEntropyLoss(),\n    train_x,\n    train_y,\n    val_x,\n    val_y,\n    MODEL_PATH,\n)\n# Set use_cache=False to retrain the model\ntrain_loss, val_loss = mgr.train(n_epochs=50, use_cache=True)\n</pre> model_ft = new_resnet_model(output_size=len(label_names)) mgr = TrainingManager(     \"model_ft\",     model_ft,     nn.CrossEntropyLoss(),     train_x,     train_y,     val_x,     val_y,     MODEL_PATH, ) # Set use_cache=False to retrain the model train_loss, val_loss = mgr.train(n_epochs=50, use_cache=True) <pre>Cached model found, loading...\n</pre> In\u00a0[8]: Copied! <pre>plot_losses(train_loss, val_loss)\n</pre> plot_losses(train_loss, val_loss) <p>The confusion matrix and $F_1$ score look good, especially considering the low resolution of the images and their complexity (they contain different objects)</p> In\u00a0[9]: Copied! <pre>pred_y_test = np.argmax(model_ft(test_x).detach(), axis=1)\nmodel_score = f1_score(test_y, pred_y_test, average=\"weighted\")\n\ncm = confusion_matrix(test_y, pred_y_test)\ndisp = ConfusionMatrixDisplay(confusion_matrix=cm, display_labels=label_names.values())\nprint(\"f1_score of model:\", model_score)\ndisp.plot();\n</pre> pred_y_test = np.argmax(model_ft(test_x).detach(), axis=1) model_score = f1_score(test_y, pred_y_test, average=\"weighted\")  cm = confusion_matrix(test_y, pred_y_test) disp = ConfusionMatrixDisplay(confusion_matrix=cm, display_labels=label_names.values()) print(\"f1_score of model:\", model_score) disp.plot(); <pre>f1_score of model: 0.8468272032336833\n</pre> In\u00a0[\u00a0]: Copied! <pre>influences = compute_influences(\n    model=mgr.model,\n    loss=mgr.loss,\n    x=train_x,\n    y=train_y,\n    x_test=test_x,\n    y_test=test_y,\n    hessian_regularization=hessian_reg,\n    inversion_method=\"cg\",\n    influence_type=\"up\",\n    progress=True,\n)\n</pre> influences = compute_influences(     model=mgr.model,     loss=mgr.loss,     x=train_x,     y=train_y,     x_test=test_x,     y_test=test_y,     hessian_regularization=hessian_reg,     inversion_method=\"cg\",     influence_type=\"up\",     progress=True, ) In\u00a0[11]: Copied! <pre>test_image_idx = 42\n\nmodel_label_to_ds_label = {\n    idx: ds_label for idx, ds_label in enumerate(label_names.values())\n}\npredicted_label = model_label_to_ds_label[\n    np.argmax(model_ft(test_x[test_image_idx].unsqueeze(0)).detach(), axis=1).item()\n]\ntrue_label = test_ds[\"labels\"][test_image_idx]\n\nplt.rcParams[\"figure.figsize\"] = (3, 3)\nplt.imshow(test_ds[\"images\"][test_image_idx])\nplt.axis(\"off\")\nplt.title(f\"Predicted: {predicted_label} - True: {true_label}\")\nplt.show()\n</pre> test_image_idx = 42  model_label_to_ds_label = {     idx: ds_label for idx, ds_label in enumerate(label_names.values()) } predicted_label = model_label_to_ds_label[     np.argmax(model_ft(test_x[test_image_idx].unsqueeze(0)).detach(), axis=1).item() ] true_label = test_ds[\"labels\"][test_image_idx]  plt.rcParams[\"figure.figsize\"] = (3, 3) plt.imshow(test_ds[\"images\"][test_image_idx]) plt.axis(\"off\") plt.title(f\"Predicted: {predicted_label} - True: {true_label}\") plt.show() <p>Now we plot the histogram of the influence that all training images have on the image selected above, separated by their label.</p> In\u00a0[12]: Copied! <pre>plt.rcParams[\"figure.figsize\"] = default_figsize\nplot_influence_distribution_by_label(\n    influences[test_image_idx],\n    train_ds[\"labels\"].values,\n    title_extra=f\"over index {test_image_idx}\",\n)\n</pre> plt.rcParams[\"figure.figsize\"] = default_figsize plot_influence_distribution_by_label(     influences[test_image_idx],     train_ds[\"labels\"].values,     title_extra=f\"over index {test_image_idx}\", ) <p>Rather unsurprisingly, the training samples that have the same label as the test image have, on average, a higher influence on the classifier's output for it. Let's then take them and visualize those with the highest and lowest influence:</p> In\u00a0[13]: Copied! <pre>images_with_same_label = train_ds[\"labels\"] == test_ds[\"labels\"][test_image_idx]\ninfluence_values_with_same_label = influences[test_image_idx][images_with_same_label]\nimages_same_label = train_ds[\"images\"][images_with_same_label].values\nplot_lowest_highest_influence_images(\n    influence_values_with_same_label, subset_images=images_same_label, num_to_plot=3\n)\n</pre> images_with_same_label = train_ds[\"labels\"] == test_ds[\"labels\"][test_image_idx] influence_values_with_same_label = influences[test_image_idx][images_with_same_label] images_same_label = train_ds[\"images\"][images_with_same_label].values plot_lowest_highest_influence_images(     influence_values_with_same_label, subset_images=images_same_label, num_to_plot=3 ) <p>Looking at the images, it is difficult to explain why those on the right are more influential than those on the left. At first sight, the choice seems to be random (or at the very least noisy). Let's dig in a bit more by looking at average influences:</p> In\u00a0[14]: Copied! <pre>avg_influences = np.mean(influences, axis=0)\n</pre> avg_influences = np.mean(influences, axis=0) <p>Once again, let's plot the histogram of influence values by label.</p> In\u00a0[15]: Copied! <pre>plot_influence_distribution_by_label(\n    avg_influences, train_ds[\"labels\"].values, \"over all test samples\"\n)\n</pre> plot_influence_distribution_by_label(     avg_influences, train_ds[\"labels\"].values, \"over all test samples\" ) <p>Next, for each class (you can change value by changing label key) we can have a look at the top and bottom images by average influence, i.e. we can show the images that have the highest and lowest average influence over all test images.</p> In\u00a0[16]: Copied! <pre>label = \"tables\"\nimg_with_selected_label = train_ds[\"labels\"] == label\nif_selected_label = avg_influences[img_with_selected_label]\nimges_same_label = train_ds[\"images\"][img_with_selected_label].values\nplot_lowest_highest_influence_images(if_selected_label, imges_same_label, num_to_plot=3)\n</pre> label = \"tables\" img_with_selected_label = train_ds[\"labels\"] == label if_selected_label = avg_influences[img_with_selected_label] imges_same_label = train_ds[\"images\"][img_with_selected_label].values plot_lowest_highest_influence_images(if_selected_label, imges_same_label, num_to_plot=3) <p>Once again, it is not easy to explain why the images on the left have a lower influence than the ones on the right. One could argue that in order to predict that there is a dining table in the image it is beneficial to clearly see both the chairs and the table itself, a feature missing in some samples on the left. Also, color seems to be a discriminant: houses with a blue painting could get confused with the water around a boat. Of course, this is debatable and different people could come up with other explanations a posteriori.</p> In\u00a0[17]: Copied! <pre>corrupted_model = new_resnet_model(output_size=len(label_names))\ncorrupted_dataset, corrupted_indices = corrupt_imagenet(\n    dataset=train_ds,\n    fraction_to_corrupt=0.1,\n    avg_influences=avg_influences,\n)\n\ncorrupted_train_x, corrupted_train_y = process_io(corrupted_dataset, label_names)\n\nmgr = TrainingManager(\n    \"corrupted_model\",\n    corrupted_model,\n    nn.CrossEntropyLoss(),\n    corrupted_train_x,\n    corrupted_train_y,\n    val_x,\n    val_y,\n    MODEL_PATH,\n)\ntraining_loss, validation_loss = mgr.train(n_epochs=50, use_cache=True)\n</pre> corrupted_model = new_resnet_model(output_size=len(label_names)) corrupted_dataset, corrupted_indices = corrupt_imagenet(     dataset=train_ds,     fraction_to_corrupt=0.1,     avg_influences=avg_influences, )  corrupted_train_x, corrupted_train_y = process_io(corrupted_dataset, label_names)  mgr = TrainingManager(     \"corrupted_model\",     corrupted_model,     nn.CrossEntropyLoss(),     corrupted_train_x,     corrupted_train_y,     val_x,     val_y,     MODEL_PATH, ) training_loss, validation_loss = mgr.train(n_epochs=50, use_cache=True) <pre>Cached model found, loading...\n</pre> In\u00a0[18]: Copied! <pre>plot_losses(training_loss, validation_loss)\n</pre> plot_losses(training_loss, validation_loss) In\u00a0[19]: Copied! <pre>pred_y_test = np.argmax(corrupted_model(test_x).detach(), axis=1)\nmodel_score = f1_score(test_y, pred_y_test, average=\"weighted\")\nprint(\"F1 score of model with corrupted data:\", model_score)\n</pre> pred_y_test = np.argmax(corrupted_model(test_x).detach(), axis=1) model_score = f1_score(test_y, pred_y_test, average=\"weighted\") print(\"F1 score of model with corrupted data:\", model_score) <pre>F1 score of model with corrupted data: 0.8164795918367347\n</pre> <p>Interestingly, despite being trained on a corrupted dataset, the model has a fairly high $F_1$ score. Let's now calculate the influence of the corrupted training data points over the test data points.</p> In\u00a0[20]: Copied! <pre>influences = compute_influences(\n    model=mgr.model,\n    loss=mgr.loss,\n    x=corrupted_train_x,\n    y=corrupted_train_y,\n    x_test=test_x,\n    y_test=test_y,\n    hessian_regularization=hessian_reg,\n    inversion_method=\"cg\",\n    influence_type=\"up\",\n    progress=True,\n)\n</pre> influences = compute_influences(     model=mgr.model,     loss=mgr.loss,     x=corrupted_train_x,     y=corrupted_train_y,     x_test=test_x,     y_test=test_y,     hessian_regularization=hessian_reg,     inversion_method=\"cg\",     influence_type=\"up\",     progress=True, ) <pre>Split Gradient:   0%|          | 0/98 [00:00&lt;?, ?it/s]</pre> <pre>Conjugate gradient:   0%|          | 0/98 [00:00&lt;?, ?it/s]</pre> <pre>Split Gradient:   0%|          | 0/707 [00:00&lt;?, ?it/s]</pre> <p>As before, since we are interested in the average influence on the test dataset, we take the average of influences across rows, and then plot the highest and lowest influences for a chosen label</p> In\u00a0[21]: Copied! <pre>avg_corrupted_influences = np.mean(influences, axis=0)\n</pre> avg_corrupted_influences = np.mean(influences, axis=0) In\u00a0[22]: Copied! <pre>label = \"boats\"\nimg_with_selected_label = corrupted_dataset[\"labels\"] == label\nif_selected_label = avg_corrupted_influences[img_with_selected_label]\nimges_same_label = corrupted_dataset[\"images\"][img_with_selected_label].values\nplot_lowest_highest_influence_images(if_selected_label, imges_same_label, num_to_plot=3)\n</pre> label = \"boats\" img_with_selected_label = corrupted_dataset[\"labels\"] == label if_selected_label = avg_corrupted_influences[img_with_selected_label] imges_same_label = corrupted_dataset[\"images\"][img_with_selected_label].values plot_lowest_highest_influence_images(if_selected_label, imges_same_label, num_to_plot=3) <p>As expected, the samples with lowest (negative) influence for the label \"boats\" are those that have been corrupted: all the images on the left are tables! We can compare the average influence of corrupted data with non-corrupted ones</p> In\u00a0[23]: Copied! <pre>plot_corrupted_influences_distribution(\n    corrupted_dataset, corrupted_indices, avg_corrupted_influences\n)\n</pre> plot_corrupted_influences_distribution(     corrupted_dataset, corrupted_indices, avg_corrupted_influences ) In\u00a0[24]: Copied! <pre>compute_mean_corrupted_influences(\n    corrupted_dataset, corrupted_indices, avg_corrupted_influences\n)\n</pre> compute_mean_corrupted_influences(     corrupted_dataset, corrupted_indices, avg_corrupted_influences ) Out[24]: label avg_non_corrupted_infl avg_corrupted_infl score_diff 0 boats 0.945390 -0.890972 1.836362 1 tables -1.092637 -2.757206 1.664569 <p>And indeed corrupted data have a more negative influence on average than clean ones!</p> <p>Despite this being a useful property, influence functions are known to be unreliable for tasks of data valuation, especially in deep learning where the fundamental assumption of the theory (convexity) is grossly violated. A lot of factors (e.g. the size of the network, the training process or the Hessian regularization term) can interfere with the computation, to the point that often the results that we obtain cannot be trusted. This has been extensively studied in the recent paper:</p> <p>Basu, S., P. Pope, and S. Feizi. Influence Functions in Deep Learning Are Fragile. International Conference on Learning Representations (ICLR). 2021.</p> <p>Nevertheless, influence functions offer a relatively quick and mathematically rigorous way to evaluate (at first order) the importance of a training point for a model's prediction.</p>"},{"location":"examples/influence_imagenet/#influence-functions-for-neural-networks","title":"Influence functions for neural networks\u00b6","text":"<p>This notebook explores the use of influence functions for convolutional neural networks. In the first part we will investigate the usefulness, or lack thereof, of influence functions for the interpretation of a classifier's outputs.</p> <p>For our study we choose a pre-trained ResNet18, fine-tuned on the tiny-imagenet dataset. This dataset was created for a Stanford course on Deep Learning for Computer Vision, and is a subset of the famous ImageNet with 200 classes instead of 1000, and images down-sampled to a lower resolution of 64x64 pixels.</p> <p>After tuning the last layers of the network, we will use pyDVL to find the most and the least influential training images for the test set. This can sometimes be used to explain inference errors, or to direct efforts during data collection, although we will face inconclusive results with our model and data. This illustrates well-known issues of influence functions for neural networks.</p> <p>However, in the final part of the notebook we will see that influence functions are an effective tool for finding anomalous or corrupted data points.</p> <p>We conclude with an appendix with some basic theoretical concepts used.</p>"},{"location":"examples/influence_imagenet/#imports-and-setup","title":"Imports and setup\u00b6","text":""},{"location":"examples/influence_imagenet/#loading-and-preprocessing-the-dataset","title":"Loading and preprocessing the dataset\u00b6","text":"<p>We pick two classes arbitrarily to work with: 90 and 100, corresponding respectively to dining tables, and boats in Venice (you can of course select any other two classes, or more of them, although that would imply longer training times and some modifications in the notebook below). The dataset is loaded with <code>load_preprocess_imagenet()</code>, which returns three pandas <code>DataFrames</code> with training, validation and test sets respectively. Each dataframe has three columns: normalized images, labels and the original images. Note that you can load a subset of the data decreasing downsampling_ratio.</p>"},{"location":"examples/influence_imagenet/#model-definition-and-training","title":"Model definition and training\u00b6","text":"<p>We use a ResNet18 from <code>torchvision</code> with final layers modified for binary classification.</p> <p>Training for influence computation is facilitated by <code>:class:~pydvl.influence.model_wrappers.torch_wrappers.TorchModel</code>, a convenience wrapper around torch models which is part of pyDVL. We wrap this with a simple class <code>TrainingManager</code> which transparently handles persistence after training. The latter is not part of the main pyDVL package but just a way to reduce clutter in this notebook.</p> <p>We train the model for 50 epochs and save the results. Then we plot the train and validation loss curves.</p>"},{"location":"examples/influence_imagenet/#influence-computation","title":"Influence computation\u00b6","text":"<p>Let's now calculate influences! The main method is <code>:func:~pydvl.influence.general.compute_influences</code>, which takes a trained <code>nn.Model</code>, the training loss, some input dataset with labels (which typically is the training data, or a subset of it) and some test data.</p> <p>Other important parameters are the Hessian regularization term, which should be chosen as small as possible for the computation to converge (further details on why this is important can be found in the Appendix).</p> <p>Since Resnet18 is quite big, we pick conjugate gradient (<code>cg</code>) as the method for inversion of the Hessian. A naive computation would require a lot of memory. Finally, the influence type will be <code>up</code>. The other option, <code>perturbation</code>, is beyond the scope of this notebook, but more info can be found in the notebook using the Wine dataset or in the documentation for pyDVL.</p> <p>The output of <code>calculate_influences</code> is a matrix of size <code>test_set_length</code> x <code>training_set_length</code>. Each row represents a test data point, and each column a training data point, so that entry $(i,j)$ represents the influence of training point $j$ on test point $i$.</p>"},{"location":"examples/influence_imagenet/#analysing-influences","title":"Analysing influences\u00b6","text":"<p>With the computed influences we can study single images or all of them together:</p>"},{"location":"examples/influence_imagenet/#influence-on-a-single-test-image","title":"Influence on a single test image\u00b6","text":"<p>Let's take any image in the test set:</p>"},{"location":"examples/influence_imagenet/#analysing-the-average-influence-on-test-samples","title":"Analysing the average influence on test samples\u00b6","text":"<p>By averaging across the rows of the influence matrix, we obtain the average influence of each training sample on the whole test set:</p>"},{"location":"examples/influence_imagenet/#detecting-corrupted-data","title":"Detecting corrupted data\u00b6","text":"<p>After facing the shortcomings of influence functions for explaining decisions, we move to an application with clear-cut results. Influences can be successfully used to detect corrupted or mislabeled samples, making them an effective tool to \"debug\" training data.</p> <p>We begin by training a new model (with the same architecture as before) on a dataset with some corrupted labels. The method <code>get_corrupted_imagenet</code> will take the training dataset and corrupt a certain fraction of the labels by flipping them. We use the same number of epochs and optimizer as before.</p>"},{"location":"examples/influence_imagenet/#theory-of-influence-functions-for-neural-networks","title":"Theory of influence functions for neural networks\u00b6","text":"<p>In this appendix we will briefly go through the basic ideas of influence functions adapted for neural networks as introduced in Koh, Pang Wei, and Percy Liang. \"Understanding Black-box Predictions via Influence Functions\" International conference on machine learning. PMLR, 2017.</p> <p>Note however that this paper departs from the standard and established theory and notation for influence functions. For a rigorous introduction to the topic we recommend classical texts like Hampel, Frank R., Elvezio M. Ronchetti, Peter J. Rousseeuw, and Werner A. Stahel. Robust Statistics: The Approach Based on Influence Functions. 1st edition. Wiley Series in Probability and Statistics. New York: Wiley-Interscience, 2005. https://doi.org/10.1002/9781118186435.</p>"},{"location":"examples/influence_imagenet/#upweighting-points","title":"Upweighting points\u00b6","text":"<p>Let's start by considering some input space $\\mathcal{X}$ to a model (e.g. images) and an output space $\\mathcal{Y}$ (e.g. labels). Let's take $z_i = (x_i, y_i)$ to be the $i$-th training point, and $\\theta$ to be the (potentially highly) multi-dimensional parameters of the neural network (i.e. $\\theta$ is a big array with very many parameters). We will indicate with $L(z, \\theta)$ the loss of the model for point $z$ and parameters $\\theta$. When training the model we minimize the loss over all points, i.e. the optimal parameters are calculated through gradient descent on the following formula: $$ \\hat{\\theta} = \\arg \\min_\\theta \\frac{1}{n}\\sum_{i=1}^n L(z_i, \\theta) $$ where $n$ is the total number of training data points.</p> <p>For notational  convenience, let's define $$ \\hat{\\theta}_{-z} = \\arg \\min_\\theta \\frac{1}{n}\\sum_{z_i \\ne z} L(z_i, \\theta) \\ , $$ i.e. $\\hat{\\theta}_{-z}$ are the model parameters that minimize the total loss when $z$ is not in the training dataset.</p> <p>In order to check the impact of each training point on the model, we would need to calculate $\\hat{\\theta}_{-z}$ for each $z$ in the training dataset, thus re-training the model at least ~$n$ times (more if model training is noisy). This is computationally very expensive, especially for big neural networks. To circumvent this problem, we can just calculate a first order approximation of $\\hat{\\theta}$. This can be done through single backpropagation and without re-training the full model.</p> <p>Let's define $$ \\hat{\\theta}_{\\epsilon, z} = \\arg \\min_\\theta \\frac{1}{n}\\sum_{i=1}^n L(z_i, \\theta) + \\epsilon L(z, \\theta) \\ , $$ which is the optimal $\\hat{\\theta}$ if we were to up-weigh $z$ by an amount $\\epsilon$.</p> <p>From a classical result (a simple derivation is available in Appendix A of Koh and Liang's paper), we know that: $$ \\frac{d \\ \\hat{\\theta}_{\\epsilon, z}}{d \\epsilon} \\Big|_{\\epsilon=0} = -H_{\\hat{\\theta}}^{-1} \\nabla_\\theta L(z, \\hat{\\theta}) $$ where $H_{\\hat{\\theta}} = \\frac{1}{n} \\sum_{i=1}^n \\nabla_\\theta^2 L(z_i, \\hat{\\theta})$ is the Hessian of $L$. Importantly, notice that this expression is only valid when $\\hat{\\theta}$ is a minimum of $L$, or otherwise $H_{\\hat{\\theta}}$ cannot be inverted!</p>"},{"location":"examples/influence_imagenet/#approximating-the-influence-of-a-point","title":"Approximating the influence of a point\u00b6","text":"<p>We will define the influence of training point $z$ on test point $z_{\\text{test}}$ as $\\mathcal{I}(z, z_{\\text{test}}) =  L(z_{\\text{test}}, \\hat{\\theta}_{-z}) - L(z_{\\text{test}}, \\hat{\\theta})$ (notice that it is higher for points $z$ which positively impact the model score, since if they are excluded, the loss is higher). In practice, however, we will always use the infinitesimal approximation $\\mathcal{I}_{up}(z, z_{\\text{test}})$, defined as $$  \\mathcal{I}_{up}(z, z_{\\text{test}}) = - \\frac{d L(z_{\\text{test}}, \\hat{\\theta}_{\\epsilon, z})}{d \\epsilon} \\Big|_{\\epsilon=0} $$</p> <p>Using the chain rule and the results calculated above, we thus have:</p> <p>$$  \\mathcal{I}_{up}(z, z_{\\text{test}}) = - \\nabla_\\theta L(z_{\\text{test}}, \\hat{\\theta})^\\top \\ \\frac{d \\hat{\\theta}_{\\epsilon, z}}{d \\epsilon} \\Big|_{\\epsilon=0} = \\nabla_\\theta L(z_{\\text{test}}, \\hat{\\theta})^\\top \\ H_{\\hat{\\theta}}^{-1} \\ \\nabla_\\theta L(z, \\hat{\\theta}) $$</p> <p>In order to calculate this expression we need the gradient and the Hessian of the loss wrt. the model parameters $\\hat{\\theta}$. This can be easily done through a single backpropagation pass.</p>"},{"location":"examples/influence_imagenet/#regularizing-the-hessian","title":"Regularizing the Hessian\u00b6","text":"<p>One very important assumption that we make when approximating influence is that $\\hat{\\theta}$ is at least a local minimum of the loss. However, we clearly cannot guarantee this except for convex models, and despite good apparent convergence, $\\hat{\\theta}$ might be located in a region with flat curvature or close to a saddle point. In particular, the Hessian might have vanishing eigenvalues making its direct inversion impossible.</p> <p>To circumvent this problem, instead of inverting the true Hessian $H_{\\hat{\\theta}}$, one can invert a small perturbation thereof: $H_{\\hat{\\theta}} + \\lambda \\mathbb{I}$, with $\\mathbb{I}$ being the identity matrix. This standard trick ensures that the eigenvalues of $H_{\\hat{\\theta}}$ are bounded away from zero and therefore the matrix is invertible. In order for this regularization not to corrupt the outcome too much, the parameter $\\lambda$ should be as small as possible while still allowing a reliable inversion of $H_{\\hat{\\theta}} + \\lambda \\mathbb{I}$.</p>"},{"location":"examples/influence_synthetic/","title":"Influence functions for data mislabeling","text":"In\u00a0[1]: Copied! <pre>%load_ext autoreload\n</pre> %load_ext autoreload In\u00a0[2]: Copied! <pre>%autoreload\n%matplotlib inline\n\nimport os\nimport random\n\nimport numpy as np\nimport torch\nimport torch.nn.functional as F\nimport matplotlib.pyplot as plt\nfrom pydvl.influence import compute_influences, TorchTwiceDifferentiable\nfrom support.shapley import (\n    synthetic_classification_dataset,\n    decision_boundary_fixed_variance_2d,\n)\nfrom support.common import (\n    plot_gaussian_blobs,\n    plot_losses,\n    plot_influences,\n)\nfrom support.torch import (\n    fit_torch_model,\n    TorchLogisticRegression,\n)\nfrom sklearn.metrics import confusion_matrix, ConfusionMatrixDisplay\nfrom torch.optim import AdamW, lr_scheduler\nfrom torch.utils.data import DataLoader\n</pre> %autoreload %matplotlib inline  import os import random  import numpy as np import torch import torch.nn.functional as F import matplotlib.pyplot as plt from pydvl.influence import compute_influences, TorchTwiceDifferentiable from support.shapley import (     synthetic_classification_dataset,     decision_boundary_fixed_variance_2d, ) from support.common import (     plot_gaussian_blobs,     plot_losses,     plot_influences, ) from support.torch import (     fit_torch_model,     TorchLogisticRegression, ) from sklearn.metrics import confusion_matrix, ConfusionMatrixDisplay from torch.optim import AdamW, lr_scheduler from torch.utils.data import DataLoader <pre>/Users/fabio/miniconda3/envs/pydvl_env/lib/python3.9/site-packages/tqdm/auto.py:21: TqdmWarning: IProgress not found. Please update jupyter and ipywidgets. See https://ipywidgets.readthedocs.io/en/stable/user_install.html\n  from .autonotebook import tqdm as notebook_tqdm\n</pre> In\u00a0[3]: Copied! <pre>plt.rcParams[\"figure.figsize\"] = (16, 8)\nplt.rcParams[\"font.size\"] = 12\nplt.rcParams[\"xtick.labelsize\"] = 12\nplt.rcParams[\"ytick.labelsize\"] = 10\n</pre> plt.rcParams[\"figure.figsize\"] = (16, 8) plt.rcParams[\"font.size\"] = 12 plt.rcParams[\"xtick.labelsize\"] = 12 plt.rcParams[\"ytick.labelsize\"] = 10 In\u00a0[4]: Copied! <pre>random_state = 24\nis_CI = os.environ.get(\"CI\")\n</pre> random_state = 24 is_CI = os.environ.get(\"CI\") In\u00a0[5]: Copied! <pre>num_samples = 10000\nnum_features = 2\nsigma = 0.2\nmeans = np.asarray([[0.0, 0.0], [1.0, 1.0]])\n</pre> num_samples = 10000 num_features = 2 sigma = 0.2 means = np.asarray([[0.0, 0.0], [1.0, 1.0]]) In\u00a0[6]: Copied! <pre>random.seed(random_state)\nnp.random.seed(random_state)\n</pre> random.seed(random_state) np.random.seed(random_state) <p>The following code snippet generates the aforementioned dataset.</p> In\u00a0[7]: Copied! <pre>train_data, val_data, test_data = synthetic_classification_dataset(\n    means, sigma, num_samples, train_size=0.7, test_size=0.2\n)\n# In CI we only use a subset of the training set\nif is_CI:\n    train_data = (train_data[0][:10], train_data[1][:10])\n</pre> train_data, val_data, test_data = synthetic_classification_dataset(     means, sigma, num_samples, train_size=0.7, test_size=0.2 ) # In CI we only use a subset of the training set if is_CI:     train_data = (train_data[0][:10], train_data[1][:10]) <p>Given the simplicity of the dataset, we can calculate exactly the optimal decision boundary(that which maximizes our accuracy). The following code maps a continuous line of z values to a 2-dimensional vector in feature space (More details are in the appendix to this notebook.)</p> In\u00a0[8]: Copied! <pre>decision_boundary_fn = decision_boundary_fixed_variance_2d(means[0], means[1])\ndecision_boundary = decision_boundary_fn(np.linspace(-1.5, 1.5, 100))\n</pre> decision_boundary_fn = decision_boundary_fixed_variance_2d(means[0], means[1]) decision_boundary = decision_boundary_fn(np.linspace(-1.5, 1.5, 100)) In\u00a0[9]: Copied! <pre>plot_gaussian_blobs(\n    train_data,\n    test_data,\n    xlabel=\"$x_0$\",\n    ylabel=\"$x_1$\",\n    legend_title=\"$y - labels$\",\n    line=decision_boundary,\n    s=10,\n    suptitle=\"Plot of train-test data\",\n)\n</pre> plot_gaussian_blobs(     train_data,     test_data,     xlabel=\"$x_0$\",     ylabel=\"$x_1$\",     legend_title=\"$y - labels$\",     line=decision_boundary,     s=10,     suptitle=\"Plot of train-test data\", ) <p>Note that there are samples which go across the optimal decision boundary and will be wrongly labelled. The optimal decision boundary can not discriminate these as the mislabelling is a consequence of the presence of random noise.</p> In\u00a0[10]: Copied! <pre>model = TorchLogisticRegression(num_features)\ndevice = torch.device(\"cuda:0\" if torch.cuda.is_available() else \"cpu\")\nmodel.to(device)\n\nnum_epochs = 50\nlr = 0.05\nweight_decay = 0.05\nbatch_size = 256\n\ntrain_data_loader = DataLoader(\n    list(zip(train_data[0], train_data[1].astype(float))),\n    batch_size=batch_size,\n    shuffle=True,\n)\nval_data_loader = DataLoader(\n    list(zip(val_data[0], val_data[1].astype(float))),\n    batch_size=batch_size,\n    shuffle=True,\n)\n\noptimizer = AdamW(params=model.parameters(), lr=lr, weight_decay=weight_decay)\nscheduler = lr_scheduler.CosineAnnealingLR(optimizer, T_max=num_epochs)\nlosses = fit_torch_model(\n    model=model,\n    training_data=train_data_loader,\n    val_data=val_data_loader,\n    loss=F.binary_cross_entropy,\n    optimizer=optimizer,\n    scheduler=scheduler,\n    num_epochs=num_epochs,\n)\n</pre> model = TorchLogisticRegression(num_features) device = torch.device(\"cuda:0\" if torch.cuda.is_available() else \"cpu\") model.to(device)  num_epochs = 50 lr = 0.05 weight_decay = 0.05 batch_size = 256  train_data_loader = DataLoader(     list(zip(train_data[0], train_data[1].astype(float))),     batch_size=batch_size,     shuffle=True, ) val_data_loader = DataLoader(     list(zip(val_data[0], val_data[1].astype(float))),     batch_size=batch_size,     shuffle=True, )  optimizer = AdamW(params=model.parameters(), lr=lr, weight_decay=weight_decay) scheduler = lr_scheduler.CosineAnnealingLR(optimizer, T_max=num_epochs) losses = fit_torch_model(     model=model,     training_data=train_data_loader,     val_data=val_data_loader,     loss=F.binary_cross_entropy,     optimizer=optimizer,     scheduler=scheduler,     num_epochs=num_epochs, ) <pre>Model fitting:   0%|          | 0/50 [00:00&lt;?, ?it/s]Model fitting: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 50/50 [00:02&lt;00:00, 19.41it/s]\n</pre> <p>And let's check that the model is not overfitting</p> In\u00a0[11]: Copied! <pre>plot_losses(losses)\n</pre> plot_losses(losses) <p>A look at the confusion matrix also shows good results</p> In\u00a0[12]: Copied! <pre>model.eval()\npred_probabilities = model(test_data[0]).detach()\npred_y_test = [1 if prob &gt; 0.5 else 0 for prob in pred_probabilities]\n\ncm = confusion_matrix(test_data[1], pred_y_test)\ndisp = ConfusionMatrixDisplay(confusion_matrix=cm)\ndisp.plot();\n</pre> model.eval() pred_probabilities = model(test_data[0]).detach() pred_y_test = [1 if prob &gt; 0.5 else 0 for prob in pred_probabilities]  cm = confusion_matrix(test_data[1], pred_y_test) disp = ConfusionMatrixDisplay(confusion_matrix=cm) disp.plot(); <p>It is important that the model converges to a point near the optimum, since the influence values assume that we are at a minimum (or close) in the loss landscape. The function</p> <p>$$I(x_1, y_1, x_2, y_2) \\colon \\mathbb{R}^d \\times \\mathbb{R}^d \\to \\mathbb{R}$$</p> <p>measures the influence of the data point $x_1$ onto $x_2$ conditioned on the training targets $y_1$ and $y_2$ trough some model parameters $\\theta$. If the loss function L is differentiable, we can take $I$ to be</p> <p>$$ I(x_1, x_2) = \\nabla_\\theta\\; L(x_1, y_1) ^\\mathsf{T} \\; H_\\theta^{-1} \\; \\nabla_\\theta \\; L(x_2, y_2) $$ See \"Understanding Black-box Predictions via Influence Functions\" for a detailed derivation of this formula</p> <p>Let's take a subset of the training data points, which we will calculate the influence values of.</p> In\u00a0[13]: Copied! <pre>x = train_data[0][:100]\ny = train_data[1][:100]\n</pre> x = train_data[0][:100] y = train_data[1][:100] <p>In pyDVL, the influence of the training points on the test points can be calculated with the following</p> In\u00a0[14]: Copied! <pre>train_data_loader = DataLoader(list(zip(x, y.astype(float))), batch_size=batch_size)\ntest_data_loader = DataLoader(\n    list(zip(test_data[0], test_data[1].astype(float))), batch_size=batch_size\n)\n\ninfluence_values = compute_influences(\n    differentiable_model=TorchTwiceDifferentiable(model, F.binary_cross_entropy),\n    training_data=train_data_loader,\n    test_data=test_data_loader,\n    influence_type=\"up\",\n    inversion_method=\"direct\",  # use 'cg' for big models\n)\n</pre> train_data_loader = DataLoader(list(zip(x, y.astype(float))), batch_size=batch_size) test_data_loader = DataLoader(     list(zip(test_data[0], test_data[1].astype(float))), batch_size=batch_size )  influence_values = compute_influences(     differentiable_model=TorchTwiceDifferentiable(model, F.binary_cross_entropy),     training_data=train_data_loader,     test_data=test_data_loader,     influence_type=\"up\",     inversion_method=\"direct\",  # use 'cg' for big models ) <p>The above explicitly constructs the Hessian. This can often be computationally expensive and conjugate gradient approximate calculation should be used for bigger models.</p> <p>With the influence type 'up', training influences have shape [NxM] where N is the number of test samples and M is the number of training samples. They therefore associate to each training sample its influence on each test sample. Influence type 'perturbation', instead, return an array of shape  [NxMxF], where F is the number of features in input, ie. the length of x.</p> <p>In our case, in order to have a value of the total average influence of a point we can just average across training samples.</p> In\u00a0[15]: Copied! <pre>mean_train_influences = np.mean(influence_values.numpy(), axis=0)\n</pre> mean_train_influences = np.mean(influence_values.numpy(), axis=0) <p>Let's plot the results (adjust colorbar_limits for better color gradient)</p> In\u00a0[16]: Copied! <pre>plot_influences(\n    x,\n    mean_train_influences,\n    line=decision_boundary,\n    xlabel=\"$x_0$\",\n    ylabel=\"$x_1$\",\n    suptitle=\"Influences of input points\",\n    legend_title=\"influence values\",\n    # colorbar_limits=(-0.3,),\n);\n</pre> plot_influences(     x,     mean_train_influences,     line=decision_boundary,     xlabel=\"$x_0$\",     ylabel=\"$x_1$\",     suptitle=\"Influences of input points\",     legend_title=\"influence values\",     # colorbar_limits=(-0.3,), ); <p>We can see that, as we approach the separation line, the influences tend to move away from zero, i.e. the points become more decisive for model training, some in a positive way, some negative.</p> <p>As a further test, let's introduce some labelling errors into $y$ and see how the distribution of the influences changes. Let's flip the first 10 labels and calculate influences</p> In\u00a0[17]: Copied! <pre>y_corrupted = np.copy(y)\ny_corrupted[:10] = [1 - yi for yi in y[:10]]\n\ntrain_corrupted_data_loader = DataLoader(\n    list(zip(x, y_corrupted.astype(float))), batch_size=batch_size\n)\n\ninfluence_values = compute_influences(\n    differentiable_model=TorchTwiceDifferentiable(model, F.binary_cross_entropy),\n    training_data=train_corrupted_data_loader,\n    test_data=test_data_loader,\n    influence_type=\"up\",\n    inversion_method=\"direct\",\n)\n\nmean_train_influences = np.mean(influence_values.numpy(), axis=0)\n</pre> y_corrupted = np.copy(y) y_corrupted[:10] = [1 - yi for yi in y[:10]]  train_corrupted_data_loader = DataLoader(     list(zip(x, y_corrupted.astype(float))), batch_size=batch_size )  influence_values = compute_influences(     differentiable_model=TorchTwiceDifferentiable(model, F.binary_cross_entropy),     training_data=train_corrupted_data_loader,     test_data=test_data_loader,     influence_type=\"up\",     inversion_method=\"direct\", )  mean_train_influences = np.mean(influence_values.numpy(), axis=0) In\u00a0[18]: Copied! <pre>print(\"Average mislabelled data influence:\", np.mean(mean_train_influences[:10]))\nprint(\"Average correct data influence:\", np.mean(mean_train_influences[10:]))\n</pre> print(\"Average mislabelled data influence:\", np.mean(mean_train_influences[:10])) print(\"Average correct data influence:\", np.mean(mean_train_influences[10:])) <pre>Average mislabelled data influence: -0.8225848370029777\nAverage correct data influence: 0.011277048916970962\n</pre> In\u00a0[19]: Copied! <pre>plot_influences(\n    x,\n    mean_train_influences,\n    corrupted_indices=np.array(range(10)),\n    line=decision_boundary,\n    xlabel=\"$x_0$\",\n    ylabel=\"$x_1$\",\n    suptitle=\"Influences of input points with corrupted data\",\n    legend_title=\"influence values\",\n    # colorbar_limits=(-0.3,),\n);\n</pre> plot_influences(     x,     mean_train_influences,     corrupted_indices=np.array(range(10)),     line=decision_boundary,     xlabel=\"$x_0$\",     ylabel=\"$x_1$\",     suptitle=\"Influences of input points with corrupted data\",     legend_title=\"influence values\",     # colorbar_limits=(-0.3,), ); <p>Red circles indicate the points which have been corrupted. We can see that the mislabelled data have a more negative average influence on the model, especially those that are farther away from the decision boundary.</p> <p>The \"direct\" method that we have used above involves the inversion of the Hessian matrix of the model. If a model has $n$ training points and $\\theta  \\in \\mathbb{R}^p$ parameters, this requires $O(n \\ p^2 + p^3)$ operations, which for larger models, like neural networks, becomes quickly unfeasible. Conjugate gradient avoids the explicit computation of the Hessian via a technique called implicit Hessian-vector products (HVPs), which typically takes $O(n \\ p)$ operations.</p> <p>In the next cell we will use conjugate gradient to compute the influence factors. Since logistic regression is a very simple model, \"cg\" actually slows computation with respect to the direct method, which in this case is a much better choice. Nevertheless, we are able to verify that the influences calculated with \"cg\" are the same (to a minor error) as those calculated directly.</p> In\u00a0[20]: Copied! <pre>influence_values = compute_influences(\n    differentiable_model=TorchTwiceDifferentiable(model, F.binary_cross_entropy),\n    training_data=train_corrupted_data_loader,\n    test_data=test_data_loader,\n    influence_type=\"up\",\n    inversion_method=\"cg\",\n    progress=True,\n)\nmean_train_influences = np.mean(influence_values.numpy(), axis=0)\n\nprint(\"Average mislabelled data influence:\", np.mean(mean_train_influences[:10]))\nprint(\"Average correct data influence:\", np.mean(mean_train_influences[10:]))\n</pre> influence_values = compute_influences(     differentiable_model=TorchTwiceDifferentiable(model, F.binary_cross_entropy),     training_data=train_corrupted_data_loader,     test_data=test_data_loader,     influence_type=\"up\",     inversion_method=\"cg\",     progress=True, ) mean_train_influences = np.mean(influence_values.numpy(), axis=0)  print(\"Average mislabelled data influence:\", np.mean(mean_train_influences[:10])) print(\"Average correct data influence:\", np.mean(mean_train_influences[10:])) <pre>Batch Test Gradients: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 8/8 [00:00&lt;00:00, 17.89it/s]\nBatch Train Gradients: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1/1 [00:00&lt;00:00, 308.47it/s]\nConjugate gradient: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 2000/2000 [00:16&lt;00:00, 118.24it/s]\nBatch Split Input Gradients: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1/1 [00:00&lt;00:00, 44.89it/s]</pre> <pre>Average mislabelled data influence: -0.82248804123547\nAverage correct data influence: 0.01127580743952819\n</pre> <pre>\n</pre> <p>Averages are very similar to the ones calculated through direct method. Same is true for the plot</p> In\u00a0[21]: Copied! <pre>plot_influences(\n    x,\n    mean_train_influences,\n    corrupted_indices=np.array(range(10)),\n    line=decision_boundary,\n    xlabel=\"$x_0$\",\n    ylabel=\"$x_1$\",\n    suptitle=\"Influences of input points with corrupted data\",\n    legend_title=\"influence values\",\n    # colorbar_limits=(-0.1, 0.1),\n);\n</pre> plot_influences(     x,     mean_train_influences,     corrupted_indices=np.array(range(10)),     line=decision_boundary,     xlabel=\"$x_0$\",     ylabel=\"$x_1$\",     suptitle=\"Influences of input points with corrupted data\",     legend_title=\"influence values\",     # colorbar_limits=(-0.1, 0.1), );"},{"location":"examples/influence_synthetic/#influence-functions-for-data-mislabeling","title":"Influence functions for data mislabeling\u00b6","text":"<p>In this notebook, we will take a closer look at the theory of influence functions with the help of a synthetic dataset. Data mislabeling occurs whenever some examples from a usually big dataset are wrongly-labeled. In real-life this happens fairly often, e.g. as a consequence of human error, or noise in the data.</p> <p>Let's consider a classification problem with the following notation:</p> <p>$$ \\begin{align*} x_i &amp;\\in \\mathbb{R}^d \\\\ y_i &amp;\\in \\{0, 1\\} \\\\ \\forall i &amp;\\in [ N ] \\end{align*} $$</p> <p>In other words, we have a dataset containing $N$ samples, each with label 1 or 0. As typical example you can think of y indicating whether a patient has a disease based on some feature representation $x$.</p> <p>Let's now introduce a toy model that will help us delve into the theory and practical utility of influence functions. We will assume that $y$ is a Bernoulli binary random variable while the input $x$ is d-dimensional Gaussian distribution which depends on the label $y$. More precisely:</p> <p>$$ y_i \\sim \\text{Ber}\\left (0.5 \\right) \\\\ x_i \\sim \\mathcal{N}\\left ((1 - y_i) \\mu_1 + y_i \\mu_2, \\sigma^2 I \\right), $$</p> <p>with fixed means and diagonal covariance. Implementing the sampling scheme in python is straightforward and can be achieved by first sampling $y$ and afterward $x$.</p>"},{"location":"examples/influence_synthetic/#imports","title":"Imports\u00b6","text":""},{"location":"examples/influence_synthetic/#constants","title":"Constants\u00b6","text":""},{"location":"examples/influence_synthetic/#dataset","title":"Dataset\u00b6","text":""},{"location":"examples/influence_synthetic/#plotting-the-dataset","title":"Plotting the dataset\u00b6","text":"<p>Let's plot the dataset is plotted with their respective labels and the optimal decision line</p>"},{"location":"examples/influence_synthetic/#training-the-model","title":"Training the model\u00b6","text":"<p>We will now train a logistic regression model on the training data. This can be done with the following</p>"},{"location":"examples/influence_synthetic/#calculating-influences","title":"Calculating influences\u00b6","text":""},{"location":"examples/influence_synthetic/#inversion-through-conjugate-gradient","title":"Inversion through conjugate gradient\u00b6","text":""},{"location":"examples/influence_synthetic/#appendix-calculating-the-decision-boundary","title":"Appendix: Calculating the decision boundary\u00b6","text":"<p>For obtaining the optimal discriminator one has to solve the equation</p> <p>$$p(x|y=0)=p(x|y=1)$$</p> <p>and determine the solution set $X$. Let's take the following probabilities</p> <p>$$ \\begin{align*} p(x|y=0)&amp;=\\mathcal{N}\\left (\\mu_1, \\sigma^2 I \\right) \\\\ p(x|y=1)&amp;=\\mathcal{N}\\left (\\mu_2, \\sigma^2 I \\right) \\end{align*} $$</p> <p>For a single fixed diagonal variance parameterized by $\\sigma$, the optimal discriminator lays at points which are equidistant from the means of the two distributions, i.e.</p> <p>$$ \\begin{align*} \\| x - \\mu_1 \\|^2 &amp;= \\| x - \\mu_2 \\|^2 \\\\ \\| \\mu_1 \\|^2 -2 x^\\mathsf{T} \\mu_1 &amp;= \\| \\mu_2 \\|^2 -2 x^\\mathsf{T} \\mu_2 \\\\ \\implies 0 &amp;= 2 (\\mu_2 - \\mu_1)^\\mathsf{T} x + \\| \\mu_1 \\|^2 - \\| \\mu_2 \\|^2 \\\\ 0 &amp;= \\mu_1^\\mathsf{T}x - \\mu_2^\\mathsf{T}x - \\frac{1}{2} \\mu_1^\\mathsf{T} \\mu_1 + \\frac{1}{2} \\mu_2^\\mathsf{T} \\mu_2 \\end{align*} $$</p> <p>This is just the implicit description of the line. Solving for the explicit form can be achieved by enforcing a functional form $f(z) = x = a z + b$ with $z \\in \\mathbb{R}$ onto $x$. After the term is inserted in the previous equation</p> <p>$$ 0 = (\\mu_2 - \\mu_1)^\\mathsf{T} (az + b) + \\frac{1}{2} \\| \\mu_1 \\|^2 - \\| \\mu_2 \\|^2 $$</p> <p>We can write $a$ since, by symmetry, it is expected to be explicitly orthogonal to $\\mu_2 - \\mu_1$. Then, solving for $b$, the solution can be found to be</p> <p>$$ f(z) = \\underbrace{\\begin{bmatrix} 0 &amp; 1 \\\\ -1 &amp; 0 \\end{bmatrix} (\\mu_2 - \\mu_1)}_a z + \\underbrace{\\frac{\\mu_1 + \\mu_2}{2}}_b $$</p>"},{"location":"examples/influence_wine/","title":"Influence functions for outlier detection","text":"<p>Let's start by loading the imports, the dataset and splitting it into train, validation and test sets. We will use a large test set to have a less noisy estimate of the average influence.</p> In\u00a0[1]: Copied! <pre>%load_ext autoreload\n</pre> %load_ext autoreload In\u00a0[\u00a0]: Copied! <pre>%autoreload\n%matplotlib inline\n\nimport os\nimport random\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport torch\nimport torch.nn.functional as F\nfrom support.common import plot_losses\nfrom support.torch import TorchMLP, fit_torch_model\nfrom pydvl.influence import compute_influences, TorchTwiceDifferentiable\nfrom support.shapley import load_wine_dataset\nfrom sklearn.metrics import confusion_matrix, ConfusionMatrixDisplay, f1_score\nfrom torch.optim import Adam, lr_scheduler\nfrom torch.utils.data import DataLoader, TensorDataset\n</pre> %autoreload %matplotlib inline  import os import random  import matplotlib.pyplot as plt import numpy as np import torch import torch.nn.functional as F from support.common import plot_losses from support.torch import TorchMLP, fit_torch_model from pydvl.influence import compute_influences, TorchTwiceDifferentiable from support.shapley import load_wine_dataset from sklearn.metrics import confusion_matrix, ConfusionMatrixDisplay, f1_score from torch.optim import Adam, lr_scheduler from torch.utils.data import DataLoader, TensorDataset In\u00a0[3]: Copied! <pre>plt.rcParams[\"figure.figsize\"] = (16, 8)\nplt.rcParams[\"font.size\"] = 12\nplt.rcParams[\"xtick.labelsize\"] = 12\nplt.rcParams[\"ytick.labelsize\"] = 10\n</pre> plt.rcParams[\"figure.figsize\"] = (16, 8) plt.rcParams[\"font.size\"] = 12 plt.rcParams[\"xtick.labelsize\"] = 12 plt.rcParams[\"ytick.labelsize\"] = 10 In\u00a0[4]: Copied! <pre>random_state = 24\nis_CI = os.environ.get(\"CI\")\n</pre> random_state = 24 is_CI = os.environ.get(\"CI\") In\u00a0[5]: Copied! <pre>random.seed(random_state)\nnp.random.seed(random_state)\n</pre> random.seed(random_state) np.random.seed(random_state) In\u00a0[6]: Copied! <pre>training_data, val_data, test_data, feature_names = load_wine_dataset(\n    train_size=0.3, test_size=0.6\n)\n# In CI we only use a subset of the training set\nif is_CI:\n    train_data = (training_data[0][:10], training_data[1][:10])\n</pre> training_data, val_data, test_data, feature_names = load_wine_dataset(     train_size=0.3, test_size=0.6 ) # In CI we only use a subset of the training set if is_CI:     train_data = (training_data[0][:10], training_data[1][:10]) <p>We will corrupt some of the training points by flipping their labels</p> In\u00a0[7]: Copied! <pre>num_corrupted_idxs = 10\ntraining_data[1][:num_corrupted_idxs] = torch.tensor(\n    [(val + 1) % 3 for val in training_data[1][:num_corrupted_idxs]]\n)\n</pre> num_corrupted_idxs = 10 training_data[1][:num_corrupted_idxs] = torch.tensor(     [(val + 1) % 3 for val in training_data[1][:num_corrupted_idxs]] ) <p>and let's wrap it in a pytorch data loader</p> In\u00a0[8]: Copied! <pre>training_data_loader = DataLoader(\n    TensorDataset(*training_data), batch_size=32, shuffle=False\n)\nval_data_loader = DataLoader(TensorDataset(*val_data), batch_size=32, shuffle=False)\ntest_data_loader = DataLoader(TensorDataset(*test_data), batch_size=32, shuffle=False)\n</pre> training_data_loader = DataLoader(     TensorDataset(*training_data), batch_size=32, shuffle=False ) val_data_loader = DataLoader(TensorDataset(*val_data), batch_size=32, shuffle=False) test_data_loader = DataLoader(TensorDataset(*test_data), batch_size=32, shuffle=False) In\u00a0[9]: Copied! <pre>feature_dimension = 13\nnum_classes = 3\nnetwork_size = [16, 16]\nlayers_size = [feature_dimension, *network_size, num_classes]\nnum_epochs = 300\nlr = 0.005\nweight_decay = 0.01\ndevice = torch.device(\"cuda:0\" if torch.cuda.is_available() else \"cpu\")\n\nnn_model = TorchMLP(layers_size)\nnn_model.to(device)\n\noptimizer = Adam(params=nn_model.parameters(), lr=lr, weight_decay=weight_decay)\nscheduler = lr_scheduler.CosineAnnealingLR(optimizer, T_max=num_epochs)\n\nlosses = fit_torch_model(\n    model=nn_model,\n    training_data=training_data_loader,\n    val_data=val_data_loader,\n    loss=F.cross_entropy,\n    optimizer=optimizer,\n    scheduler=scheduler,\n    num_epochs=num_epochs,\n)\n</pre> feature_dimension = 13 num_classes = 3 network_size = [16, 16] layers_size = [feature_dimension, *network_size, num_classes] num_epochs = 300 lr = 0.005 weight_decay = 0.01 device = torch.device(\"cuda:0\" if torch.cuda.is_available() else \"cpu\")  nn_model = TorchMLP(layers_size) nn_model.to(device)  optimizer = Adam(params=nn_model.parameters(), lr=lr, weight_decay=weight_decay) scheduler = lr_scheduler.CosineAnnealingLR(optimizer, T_max=num_epochs)  losses = fit_torch_model(     model=nn_model,     training_data=training_data_loader,     val_data=val_data_loader,     loss=F.cross_entropy,     optimizer=optimizer,     scheduler=scheduler,     num_epochs=num_epochs, ) <pre>Model fitting: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 300/300 [00:00&lt;00:00, 307.77it/s]\n</pre> <p>Let's check that the training has found a stable minimum by plotting the training and validation loss</p> In\u00a0[10]: Copied! <pre>plot_losses(losses)\n</pre> plot_losses(losses) <p>Since it is a classification problem, let's also take a look at the confusion matrix on the test set</p> In\u00a0[11]: Copied! <pre>nn_model.eval()\npred_y_test = np.argmax(nn_model(test_data[0]).detach(), axis=1)\n\ncm = confusion_matrix(test_data[1], pred_y_test)\ndisp = ConfusionMatrixDisplay(confusion_matrix=cm)\ndisp.plot();\n</pre> nn_model.eval() pred_y_test = np.argmax(nn_model(test_data[0]).detach(), axis=1)  cm = confusion_matrix(test_data[1], pred_y_test) disp = ConfusionMatrixDisplay(confusion_matrix=cm) disp.plot(); <p>And let's compute the f1 score of the model</p> In\u00a0[12]: Copied! <pre>f1_score(test_data[1], pred_y_test, average=\"weighted\")\n</pre> f1_score(test_data[1], pred_y_test, average=\"weighted\") Out[12]: <pre>0.9906846833902615</pre> <p>Let's now move to calculating influences of each point on the total score.</p> In\u00a0[13]: Copied! <pre>train_influences = compute_influences(\n    TorchTwiceDifferentiable(nn_model, F.cross_entropy),\n    training_data=training_data_loader,\n    test_data=test_data_loader,\n    influence_type=\"up\",\n    inversion_method=\"direct\",\n    hessian_regularization=0.1,\n    progress=True,\n)\n</pre> train_influences = compute_influences(     TorchTwiceDifferentiable(nn_model, F.cross_entropy),     training_data=training_data_loader,     test_data=test_data_loader,     influence_type=\"up\",     inversion_method=\"direct\",     hessian_regularization=0.1,     progress=True, ) <pre>Batch Test Gradients: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 4/4 [00:00&lt;00:00, 67.10it/s]\nMVP: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 547/547 [00:00&lt;00:00, 742.01it/s] \nBatch Split Input Gradients: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 2/2 [00:00&lt;00:00, 85.02it/s]\n</pre> <p>the returned matrix, train_influences, has a quantity of columns equal to the points in the training set, and a number of rows equal to the points in the test set. At each element $a_{i,j}$ it stores the influence that training point $j$ has on the classification of test point $i$.</p> <p>If we take the average across every column of the influences matrix, we obtain an estimate of the overall influence of a training point on the total accuracy of the network.</p> In\u00a0[14]: Copied! <pre>mean_train_influences = np.mean(train_influences.numpy(), axis=0)\n</pre> mean_train_influences = np.mean(train_influences.numpy(), axis=0) <p>The following histogram shows that there are big differences in score within the training set (notice the log-scale on the y axis).</p> In\u00a0[15]: Copied! <pre>_, ax = plt.subplots()\nax.hist(mean_train_influences[num_corrupted_idxs:], label=\"normal\")\nax.hist(mean_train_influences[:num_corrupted_idxs], label=\"corrupted\", bins=5)\nax.set_title(\"Influece scores distribution\")\nax.set_xlabel(\"influece score\")\nax.set_ylabel(\"number of points\")\nax.legend()\nplt.show()\n</pre> _, ax = plt.subplots() ax.hist(mean_train_influences[num_corrupted_idxs:], label=\"normal\") ax.hist(mean_train_influences[:num_corrupted_idxs], label=\"corrupted\", bins=5) ax.set_title(\"Influece scores distribution\") ax.set_xlabel(\"influece score\") ax.set_ylabel(\"number of points\") ax.legend() plt.show() <p>We can see that the corrupted points tend to have a negative effect on the model, as expected</p> In\u00a0[16]: Copied! <pre>print(\n    \"Average influence of corrupted points: \",\n    np.mean(mean_train_influences[:num_corrupted_idxs]),\n)\nprint(\n    \"Average influence of other points: \",\n    np.mean(mean_train_influences[num_corrupted_idxs:]),\n)\n</pre> print(     \"Average influence of corrupted points: \",     np.mean(mean_train_influences[:num_corrupted_idxs]), ) print(     \"Average influence of other points: \",     np.mean(mean_train_influences[num_corrupted_idxs:]), ) <pre>Average influence of corrupted points:  -0.05317057\nAverage influence of other points:  0.034408495\n</pre> <p>We have seen how to calculate the influence of single training points on each test point using influence_type 'up'. Using influence_type 'perturbation' we can also calculate the influence of the input features of each point. In the next cell we will calculate the average influence of each feature on training and test points, and ultimately assess which are the most relevant to model performance.</p> In\u00a0[17]: Copied! <pre>feature_influences = compute_influences(\n    TorchTwiceDifferentiable(nn_model, F.cross_entropy),\n    training_data=training_data_loader,\n    test_data=test_data_loader,\n    influence_type=\"perturbation\",\n    inversion_method=\"direct\",\n    hessian_regularization=1,\n    progress=True,\n)\n</pre> feature_influences = compute_influences(     TorchTwiceDifferentiable(nn_model, F.cross_entropy),     training_data=training_data_loader,     test_data=test_data_loader,     influence_type=\"perturbation\",     inversion_method=\"direct\",     hessian_regularization=1,     progress=True, ) <pre>Batch Test Gradients: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 4/4 [00:00&lt;00:00, 61.20it/s]\nMVP: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 547/547 [00:00&lt;00:00, 1265.72it/s]\nBatch Influence Perturbation: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 2/2 [00:03&lt;00:00,  1.66s/it]\n</pre> In\u00a0[18]: Copied! <pre>mean_feature_influences = np.mean(feature_influences.numpy(), axis=(0, 1))\n\n_, ax = plt.subplots()\nax.bar(feature_names, mean_feature_influences)\nax.set_xlabel(\"training features\")\nax.set_ylabel(\"influence values\")\nax.set_title(\"Average feature influence\")\nplt.xticks(rotation=60)\nplt.show()\n</pre> mean_feature_influences = np.mean(feature_influences.numpy(), axis=(0, 1))  _, ax = plt.subplots() ax.bar(feature_names, mean_feature_influences) ax.set_xlabel(\"training features\") ax.set_ylabel(\"influence values\") ax.set_title(\"Average feature influence\") plt.xticks(rotation=60) plt.show() <p>The calculation of the Hessian matrix (necessary to calculate the influences) can be quite numerically challenging, but there are some techniques to speed up its calculation. PyDVL allows to use the full method (\"direct\") or the conjugate gradient method (\"cg\"). The first one should be used only for very small networks (like our current example), while for bigger ones \"cg\" is advisable.</p> In\u00a0[19]: Copied! <pre>cg_train_influences = compute_influences(\n    TorchTwiceDifferentiable(nn_model, F.cross_entropy),\n    training_data=training_data_loader,\n    test_data=test_data_loader,\n    influence_type=\"up\",\n    inversion_method=\"cg\",\n    hessian_regularization=0.1,\n    progress=True,\n)\nmean_cg_train_influences = np.mean(cg_train_influences.numpy(), axis=0)\n</pre> cg_train_influences = compute_influences(     TorchTwiceDifferentiable(nn_model, F.cross_entropy),     training_data=training_data_loader,     test_data=test_data_loader,     influence_type=\"up\",     inversion_method=\"cg\",     hessian_regularization=0.1,     progress=True, ) mean_cg_train_influences = np.mean(cg_train_influences.numpy(), axis=0) <pre>Batch Test Gradients: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 4/4 [00:00&lt;00:00, 81.02it/s]\nBatch Train Gradients: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 2/2 [00:00&lt;00:00, 535.33it/s]\nConjugate gradient: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 107/107 [00:04&lt;00:00, 22.66it/s]\nBatch Split Input Gradients: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 2/2 [00:00&lt;00:00, 98.91it/s]\n</pre> <p>Let's compare the results obtained through conjugate gradient with those from the direct method</p> In\u00a0[20]: Copied! <pre>print(\n    f\"Percentage error of cg over direct method:{np.mean(np.abs(mean_cg_train_influences - mean_train_influences)/np.abs(mean_train_influences))*100} %\"\n)\n</pre> print(     f\"Percentage error of cg over direct method:{np.mean(np.abs(mean_cg_train_influences - mean_train_influences)/np.abs(mean_train_influences))*100} %\" ) <pre>Percentage error of cg over direct method:1.5124550145628746e-05 %\n</pre> <p>This was a quick introduction to the pyDVL interface for influence functions. Despite their speed and simplicity, influence functions are known to be a very noisy estimator of data quality, as pointed out in the paper \"Influence functions in deep learning are fragile\". The size of the network, the weight decay, the inversion method used for calculating influences, the size of the test set: they all add up to the total amount of noise. Experiments may therefore give quantitative and qualitatively different results if not averaged across several realisations. Shapley values, on the contrary, have shown to be a more robust, but this comes at the cost of high computational requirements. PyDVL employs several parallelization and caching techniques to optimize such calculations.</p>"},{"location":"examples/influence_wine/#influence-functions-for-outlier-detection","title":"Influence functions for outlier detection\u00b6","text":"<p>This notebook shows how to calculate influences on a NN model using pyDVL for an arbitrary dataset, and how this can be used to find anomalous or corrupted data points.</p> <p>It uses the wine dataset from sklearn: given a set of 13 different input parameters regarding a particular bottle, each related to some physical property (e.g. concentration of magnesium, malic acidity, alcoholic percentage, etc.), the model will need to predict to which of 3 classes the wine belongs to. For more details, please refer to the sklearn documentation.</p>"},{"location":"examples/influence_wine/#imports","title":"Imports\u00b6","text":""},{"location":"examples/influence_wine/#constants","title":"Constants\u00b6","text":""},{"location":"examples/influence_wine/#dataset","title":"Dataset\u00b6","text":""},{"location":"examples/influence_wine/#fit-a-neural-network-to-the-data","title":"Fit a neural network to the data\u00b6","text":"<p>We will train a 2-layer neural network. PyDVL has some convenience wrappers to initialize a pytorch NN. If you already have a model loaded and trained, you can skip this section.</p>"},{"location":"examples/influence_wine/#calculating-influences-for-small-neural-networks","title":"Calculating influences for small neural networks\u00b6","text":"<p>The following cell calculates the influences of each training data point on the neural network. Neural networks have typically a very bumpy parameter space, which, during training, is explored until the configuration that minimises the loss is found. There is an important assumption in influence functions that the model lays at a (at least local) minimum of such loss, and if this is not fulfilled many issues can arise. In order to avoid this scenario, a regularisation term should be used whenever dealing with big and noisy models.</p>"},{"location":"examples/influence_wine/#influence-of-training-features","title":"Influence of training features\u00b6","text":""},{"location":"examples/influence_wine/#speeding-up-influences-for-big-models","title":"Speeding up influences for big models\u00b6","text":""},{"location":"examples/least_core_basic/","title":"Least Core for Data Valuation","text":"<p>We will be using the following functions and classes from pyDVL.</p> In\u00a0[3]: Copied! <pre>%autoreload\nfrom pydvl.utils import (\n    Dataset,\n    Utility,\n)\nfrom pydvl.value import compute_least_core_values, LeastCoreMode, ValuationResult\nfrom pydvl.reporting.plots import shaded_mean_std\nfrom pydvl.reporting.scores import compute_removal_score\n</pre> %autoreload from pydvl.utils import (     Dataset,     Utility, ) from pydvl.value import compute_least_core_values, LeastCoreMode, ValuationResult from pydvl.reporting.plots import shaded_mean_std from pydvl.reporting.scores import compute_removal_score In\u00a0[4]: Copied! <pre>X, y = make_classification(\n    n_samples=200,\n    n_features=50,\n    n_informative=25,\n    n_classes=3,\n    random_state=random_state,\n)\n</pre> X, y = make_classification(     n_samples=200,     n_features=50,     n_informative=25,     n_classes=3,     random_state=random_state, ) In\u00a0[5]: Copied! <pre>full_dataset = Dataset.from_arrays(\n    X, y, stratify_by_target=True, random_state=random_state\n)\nsmall_dataset = Dataset.from_arrays(\n    X,\n    y,\n    stratify_by_target=True,\n    train_size=10,\n    random_state=random_state,\n)\n</pre> full_dataset = Dataset.from_arrays(     X, y, stratify_by_target=True, random_state=random_state ) small_dataset = Dataset.from_arrays(     X,     y,     stratify_by_target=True,     train_size=10,     random_state=random_state, ) In\u00a0[6]: Copied! <pre>model = LogisticRegression(max_iter=500, solver=\"liblinear\")\n</pre> model = LogisticRegression(max_iter=500, solver=\"liblinear\") In\u00a0[7]: Copied! <pre>model.fit(full_dataset.x_train, full_dataset.y_train)\nprint(\n    f\"Training accuracy: {100 * model.score(full_dataset.x_train, full_dataset.y_train):0.2f}%\"\n)\nprint(\n    f\"Testing accuracy: {100 * model.score(full_dataset.x_test, full_dataset.y_test):0.2f}%\"\n)\n</pre> model.fit(full_dataset.x_train, full_dataset.y_train) print(     f\"Training accuracy: {100 * model.score(full_dataset.x_train, full_dataset.y_train):0.2f}%\" ) print(     f\"Testing accuracy: {100 * model.score(full_dataset.x_test, full_dataset.y_test):0.2f}%\" ) <pre>Training accuracy: 86.25%\nTesting accuracy: 70.00%\n</pre> In\u00a0[8]: Copied! <pre>model.fit(small_dataset.x_train, small_dataset.y_train)\nprint(\n    f\"Training accuracy: {100 * model.score(small_dataset.x_train, small_dataset.y_train):0.2f}%\"\n)\nprint(\n    f\"Testing accuracy: {100 * model.score(small_dataset.x_test, small_dataset.y_test):0.2f}%\"\n)\n</pre> model.fit(small_dataset.x_train, small_dataset.y_train) print(     f\"Training accuracy: {100 * model.score(small_dataset.x_train, small_dataset.y_train):0.2f}%\" ) print(     f\"Testing accuracy: {100 * model.score(small_dataset.x_test, small_dataset.y_test):0.2f}%\" ) <pre>Training accuracy: 100.00%\nTesting accuracy: 47.89%\n</pre> In\u00a0[9]: Copied! <pre>utility = Utility(model=model, data=small_dataset)\n</pre> utility = Utility(model=model, data=small_dataset) In\u00a0[10]: Copied! <pre>exact_values = compute_least_core_values(\n    u=utility,\n    mode=LeastCoreMode.Exact,\n    progress=True,\n)\n</pre> exact_values = compute_least_core_values(     u=utility,     mode=LeastCoreMode.Exact,     progress=True, ) <pre>  0%|          | 0/1023 [00:00&lt;?, ?it/s]</pre> In\u00a0[11]: Copied! <pre>exact_values_df = exact_values.to_dataframe(column=\"exact_value\").T\nexact_values_df = exact_values_df[sorted(exact_values_df.columns)]\n</pre> exact_values_df = exact_values.to_dataframe(column=\"exact_value\").T exact_values_df = exact_values_df[sorted(exact_values_df.columns)] In\u00a0[12]: Copied! <pre>budget_array = np.linspace(200, 2 ** len(small_dataset), num=10, dtype=int)\n\nall_estimated_values_df = []\nall_errors = {budget: [] for budget in budget_array}\n\nfor budget in tqdm(budget_array):\n    dfs = []\n    errors = []\n    column_name = f\"estimated_value_{budget}\"\n    for i in range(20):\n        values = compute_least_core_values(\n            u=utility,\n            mode=LeastCoreMode.MonteCarlo,\n            n_iterations=budget,\n            n_jobs=n_jobs,\n        )\n        df = (\n            values.to_dataframe(column=column_name)\n            .drop(columns=[f\"{column_name}_stderr\"])\n            .T\n        )\n        df = df[sorted(df.columns)]\n        error = mean_squared_error(\n            exact_values_df.loc[\"exact_value\"].values, df.values.ravel()\n        )\n        all_errors[budget].append(error)\n        df[\"budget\"] = budget\n        dfs.append(df)\n    estimated_values_df = pd.concat(dfs)\n    all_estimated_values_df.append(estimated_values_df)\n\nvalues_df = pd.concat(all_estimated_values_df)\nerrors_df = pd.DataFrame(all_errors)\n</pre> budget_array = np.linspace(200, 2 ** len(small_dataset), num=10, dtype=int)  all_estimated_values_df = [] all_errors = {budget: [] for budget in budget_array}  for budget in tqdm(budget_array):     dfs = []     errors = []     column_name = f\"estimated_value_{budget}\"     for i in range(20):         values = compute_least_core_values(             u=utility,             mode=LeastCoreMode.MonteCarlo,             n_iterations=budget,             n_jobs=n_jobs,         )         df = (             values.to_dataframe(column=column_name)             .drop(columns=[f\"{column_name}_stderr\"])             .T         )         df = df[sorted(df.columns)]         error = mean_squared_error(             exact_values_df.loc[\"exact_value\"].values, df.values.ravel()         )         all_errors[budget].append(error)         df[\"budget\"] = budget         dfs.append(df)     estimated_values_df = pd.concat(dfs)     all_estimated_values_df.append(estimated_values_df)  values_df = pd.concat(all_estimated_values_df) errors_df = pd.DataFrame(all_errors) <pre>  0%|          | 0/10 [00:00&lt;?, ?it/s]</pre> <p>We can see that the approximation error decreases, on average, as the we increase the budget.</p> <p>Still, the decrease may not always necessarily happen when we increase the number of iterations because of the fact that we sample the subsets with replacement in the Monte Carlo method i.e there may be repeated subsets.</p> In\u00a0[17]: Copied! <pre>utility = Utility(model=model, data=full_dataset)\n</pre> utility = Utility(model=model, data=full_dataset) In\u00a0[18]: Copied! <pre>method_names = [\"Random\", \"Least Core\"]\nremoval_percentages = np.arange(0, 0.41, 0.05)\n</pre> method_names = [\"Random\", \"Least Core\"] removal_percentages = np.arange(0, 0.41, 0.05) In\u00a0[19]: Copied! <pre>all_scores = []\n\nfor i in trange(5):\n    for method_name in method_names:\n        if method_name == \"Random\":\n            values = ValuationResult.from_random(size=len(utility.data))\n        else:\n            values = compute_least_core_values(\n                u=utility,\n                mode=LeastCoreMode.MonteCarlo,\n                n_iterations=25000,\n                n_jobs=n_jobs,\n            )\n        scores = compute_removal_score(\n            u=utility,\n            values=values,\n            percentages=removal_percentages,\n            remove_best=True,\n        )\n        scores[\"method_name\"] = method_name\n        all_scores.append(scores)\n\nscores_df = pd.DataFrame(all_scores)\n</pre> all_scores = []  for i in trange(5):     for method_name in method_names:         if method_name == \"Random\":             values = ValuationResult.from_random(size=len(utility.data))         else:             values = compute_least_core_values(                 u=utility,                 mode=LeastCoreMode.MonteCarlo,                 n_iterations=25000,                 n_jobs=n_jobs,             )         scores = compute_removal_score(             u=utility,             values=values,             percentages=removal_percentages,             remove_best=True,         )         scores[\"method_name\"] = method_name         all_scores.append(scores)  scores_df = pd.DataFrame(all_scores) <pre>  0%|          | 0/5 [00:00&lt;?, ?it/s]</pre> <p>We can clearly see that removing the most valuable data points, as given by the Least Core method, leads to, on average, a decrease in the model's performance and that the method outperforms random removal of data points.</p> In\u00a0[22]: Copied! <pre>all_scores = []\n\nfor i in trange(5):\n    for method_name in method_names:\n        if method_name == \"Random\":\n            values = ValuationResult.from_random(size=len(utility.data))\n        else:\n            values = compute_least_core_values(\n                u=utility,\n                mode=LeastCoreMode.MonteCarlo,\n                n_iterations=25000,\n                n_jobs=n_jobs,\n            )\n        scores = compute_removal_score(\n            u=utility,\n            values=values,\n            percentages=removal_percentages,\n        )\n        scores[\"method_name\"] = method_name\n        all_scores.append(scores)\n\nscores_df = pd.DataFrame(all_scores)\n</pre> all_scores = []  for i in trange(5):     for method_name in method_names:         if method_name == \"Random\":             values = ValuationResult.from_random(size=len(utility.data))         else:             values = compute_least_core_values(                 u=utility,                 mode=LeastCoreMode.MonteCarlo,                 n_iterations=25000,                 n_jobs=n_jobs,             )         scores = compute_removal_score(             u=utility,             values=values,             percentages=removal_percentages,         )         scores[\"method_name\"] = method_name         all_scores.append(scores)  scores_df = pd.DataFrame(all_scores) <pre>  0%|          | 0/5 [00:00&lt;?, ?it/s]</pre> <p>We can clearly see that removing the least valuable data points, as given by the Least Core method, leads to, on average, an increase in the model's performance and that the method outperforms the random removal of data points.</p>"},{"location":"examples/least_core_basic/#least-core-for-data-valuation","title":"Least Core for Data Valuation\u00b6","text":"<p>This notebook introduces Least Core methods for the computation of data values using pyDVL.</p> <p>Shapley values define a fair way of distributing the worth of the whole training set when every data point is part of it. But they do not consider the question of stability of subsets: Could some data points obtain a higher payoff if they formed smaller subsets? It is argued that this might be relevant if data providers are paid based on data value, since Shapley values can incentivise them not to contribute their data to the \"grand coalition\", but instead try to form smaller ones. Whether this is of actual practical relevance is debatable, but in any case, the least core is an alternative tool available for any task of Data Valuation</p> <p>The Core is another approach to compute data values originating in cooperative game theory that attempts to answer those questions. It is the set of feasible payoffs that cannot be improved upon by a coalition of the participants.</p> <p>Its use for Data Valuation was first described in the paper If You Like Shapley Then You\u2019ll Love the Core by Tom Yan and Ariel D. Procaccia.</p> <p>The Least Core value $v$ of the $i$-th sample in dataset $D$ wrt. utility $u$ is computed by solving the following Linear Program:</p> <p>$$ \\begin{array}{lll} \\text{minimize} &amp; \\displaystyle{e} &amp; \\\\ \\text{subject to} &amp; \\displaystyle\\sum_{x_i\\in D} v_u(x_i) = u(D) &amp; \\\\ &amp; \\displaystyle\\sum_{x_i\\in S} v_u(x_i) + e \\geq u(S) &amp;, \\forall S \\subset D, S \\neq \\emptyset \\\\ \\end{array} $$</p> <p>To illustrate this method we will use a synthetic dataset. We will first use a subset of 10 data point to compute the exact values and use them to assess the Monte Carlo approximation. Afterwards, we will conduct the data removal experiments as described by Ghorbani and Zou in their paper Data Shapley: Equitable Valuation of Data for Machine Learning: We compute the data valuation given different computation budgets and incrementally remove a percentage of the best, respectively worst, data points and observe how that affects the utility.</p>"},{"location":"examples/least_core_basic/#setup","title":"Setup\u00b6","text":"<p>We begin by importing the main libraries and setting some defaults.</p> <p>If you are reading this in the documentation, some boilerplate (including most plotting code) has been omitted for convenience.</p>"},{"location":"examples/least_core_basic/#dataset","title":"Dataset\u00b6","text":"<p>We generate a synthetic dataset using the <code>make_classification</code> function from scikit-learn.</p> <p>We sample 200 data points from a 50-dimensional Gaussian distribution with 25 informative features and 25 non-informative features (generated as random linear combinations of the informative features).</p> <p>The 200 samples are uniformly distributed across 3 classes with a small percentage of noise added to the labels to make the task a bit more difficult.</p>"},{"location":"examples/least_core_basic/#estimating-least-core-values","title":"Estimating Least Core Values\u00b6","text":"<p>In this first section we will use a smaller subset of the dataset containing 10 samples in order to be able to compute exact values in a reasonable amount of time. Afterwards, we will use the Monte Carlo method with a limited budget (maximum number of subsets) to approximate these values.</p>"},{"location":"examples/least_core_basic/#data-removal","title":"Data Removal\u00b6","text":"<p>We now move on to the data removal experiments using the full dataset.</p> <p>In these experiments, we first rank the data points from most valuable to least valuable using the values estimated by the Monte Carlo Least Core method. Then, we gradually remove from 5 to 40 percent, by increments of 5 percentage points, of the most valuable/least valuable ones, train the model on this subset and compute its accuracy.</p>"},{"location":"examples/least_core_basic/#remove-best","title":"Remove Best\u00b6","text":"<p>We start by removing the best data points and seeing how the model's accuracy evolves.</p>"},{"location":"examples/least_core_basic/#remove-worst","title":"Remove Worst\u00b6","text":"<p>We then proceed to removing the worst data points and seeing how the model's accuracy evolves.</p>"},{"location":"examples/shapley_basic_spotify/","title":"Shapley for data valuation","text":"<p>This notebook introduces Shapley methods for the computation of data value using pyDVL.</p> <p>In order to illustrate the practical advantages, we will predict the popularity of songs in the dataset Top Hits Spotify from 2000-2019, and highlight how data valuation can help investigate and boost the performance of the models. In doing so, we will describe the basic usage patterns of pyDVL.</p> <p>Recall that data value is a function of three things:</p> <ol> <li>The dataset.</li> <li>The model.</li> <li>The performance metric or scoring function.</li> </ol> <p>Below we will describe how to instantiate each one of these objects and how to use them for data valuation. Please also see the documentation on data valuation.</p> <p>We will be using the following functions from pyDVL. The main entry point is the function compute_shapley_values(), which provides a facade to all Shapley methods. In order to use it we need the classes Dataset, Utility and Scorer.</p> In\u00a0[3]: Copied! <pre>%autoreload\nfrom pydvl.reporting.plots import plot_shapley\nfrom pydvl.utils.dataset import GroupedDataset\nfrom support.shapley import load_spotify_dataset\nfrom pydvl.value import *\n</pre> %autoreload from pydvl.reporting.plots import plot_shapley from pydvl.utils.dataset import GroupedDataset from support.shapley import load_spotify_dataset from pydvl.value import * In\u00a0[4]: Copied! <pre>training_data, val_data, test_data = load_spotify_dataset(\n    val_size=0.3, test_size=0.3, target_column=\"popularity\", random_state=random_state\n)\n</pre> training_data, val_data, test_data = load_spotify_dataset(     val_size=0.3, test_size=0.3, target_column=\"popularity\", random_state=random_state ) In\u00a0[6]: Copied! <pre>training_data[0].head()\n</pre> training_data[0].head() Out[6]: artist song duration_ms explicit year danceability energy key loudness mode speechiness acousticness instrumentalness liveness valence tempo genre 1561 Fetty Wap 679 (feat. Remy Boyz) 196693 True 2015 0.618 0.717 7 -5.738 1 0.3180 0.00256 0.000000 0.6250 0.603 190.050 8 1410 Meghan Trainor All About That Bass 187920 True 2015 0.807 0.887 9 -3.726 1 0.0503 0.05730 0.000003 0.1240 0.961 134.052 14 1772 Katy Perry Chained To The Rhythm 237733 False 2017 0.562 0.800 0 -5.404 1 0.1120 0.08140 0.000000 0.1990 0.471 95.029 14 1670 Sigala Sweet Lovin' - Radio Edit 202149 False 2015 0.683 0.910 10 -1.231 1 0.0515 0.05530 0.000005 0.3360 0.674 124.977 15 1780 Liam Payne Strip That Down 204502 False 2017 0.869 0.485 6 -5.595 1 0.0545 0.24600 0.000000 0.0765 0.527 106.028 14 <p>The dataset has many high-level features, some quite intuitive ('duration_ms' or 'tempo'), while others are a bit more cryptic ('valence'?). For information on each feature, please consult the dataset's website.</p> <p>In our analysis, we will use all the columns, except for 'artist' and 'song', to predict the 'popularity' of each song. We will nonetheless keep the information on song and artist in a separate object for future reference.</p> In\u00a0[7]: Copied! <pre>song_name = training_data[0][\"song\"]\nartist = training_data[0][\"artist\"]\ntraining_data[0] = training_data[0].drop([\"song\", \"artist\"], axis=1)\ntest_data[0] = test_data[0].drop([\"song\", \"artist\"], axis=1)\nval_data[0] = val_data[0].drop([\"song\", \"artist\"], axis=1)\n</pre> song_name = training_data[0][\"song\"] artist = training_data[0][\"artist\"] training_data[0] = training_data[0].drop([\"song\", \"artist\"], axis=1) test_data[0] = test_data[0].drop([\"song\", \"artist\"], axis=1) val_data[0] = val_data[0].drop([\"song\", \"artist\"], axis=1) <p>Input and label data are then used to instantiate a Dataset object:</p> In\u00a0[8]: Copied! <pre>dataset = Dataset(*training_data, *val_data)\n</pre> dataset = Dataset(*training_data, *val_data) <p>The calculation of exact Shapley values is computationally very expensive (exponentially so!) because it requires training the model on every possible subset of the training set. For this reason, PyDVL implements techniques to speed up the calculation, such as Monte Carlo approximations, surrogate models or caching of intermediate results and grouping of data to calculate group Shapley values instead of single data points.</p> <p>In our case, we will group songs by artist and calculate the Shapley value for the artists. Given the pandas Series for 'artist', to group the dataset by it, one does the following:</p> In\u00a0[9]: Copied! <pre>grouped_dataset = GroupedDataset.from_dataset(dataset=dataset, data_groups=artist)\n</pre> grouped_dataset = GroupedDataset.from_dataset(dataset=dataset, data_groups=artist) In\u00a0[10]: Copied! <pre>utility = Utility(\n    model=GradientBoostingRegressor(n_estimators=3),\n    data=grouped_dataset,\n    scorer=Scorer(\"neg_mean_absolute_error\", default=0.0),\n)\nvalues = compute_shapley_values(\n    utility,\n    mode=ShapleyMode.TruncatedMontecarlo,\n    # Stop if the standard error is below 1% of the range of the values (which is ~2),\n    # or if the number of updates exceeds 1000\n    done=AbsoluteStandardError(threshold=0.2, fraction=0.9) | MaxUpdates(1000),\n    n_jobs=-1,\n)\nvalues.sort(key=\"value\")\ndf = values.to_dataframe(column=\"data_value\", use_names=True)\n</pre> utility = Utility(     model=GradientBoostingRegressor(n_estimators=3),     data=grouped_dataset,     scorer=Scorer(\"neg_mean_absolute_error\", default=0.0), ) values = compute_shapley_values(     utility,     mode=ShapleyMode.TruncatedMontecarlo,     # Stop if the standard error is below 1% of the range of the values (which is ~2),     # or if the number of updates exceeds 1000     done=AbsoluteStandardError(threshold=0.2, fraction=0.9) | MaxUpdates(1000),     n_jobs=-1, ) values.sort(key=\"value\") df = values.to_dataframe(column=\"data_value\", use_names=True) <p>The function compute_shapley_values() serves as a common access point to all Shapley methods. For several of them, we choose a <code>StoppingCriterion</code> with the argument <code>done=</code>. In this case we choose to stop when the ratio of standard error to value is below 0.3 for at least 90% of the training points, or if the number of updates of any index exceeds 200. The <code>mode</code> argument specifies the Shapley method to use. In this case, we use the Truncated Monte Carlo approximation, which is the fastest of the Monte Carlo methods.</p> <p>Let's take a look at the returned dataframe:</p> In\u00a0[11]: Copied! <pre>df.head()\n</pre> df.head() Out[11]: data_value data_value_stderr Kendrick Lamar -1.279149 0.091670 BLACKPINK -1.277363 0.177476 Adele -1.241698 0.183732 5 Seconds of Summer -1.228002 0.103377 Flume -1.197065 0.102345 <p>The first thing to notice is that we sorted the results in ascending order of Shapley value. The index holds the labels for each data group: in this case, artist names. The column <code>data_value</code> is just that: the Shapley Data value, and <code>data_value_stderr</code> is its estimated standard error because we are using a Monte Carlo approximation.</p> <p>Let us plot the results. In the next cell we will take the 30 artists with the lowest score and plot their values with 95% Normal confidence intervals. Keep in mind that Monte Carlo Shapley is typically very noisy, and it can take many steps to arrive at a clean estimate.</p> <p>We can immediately see that many artists (groups of samples) have very low, even negative value, which means that they tend to decrease the total score of the model when present in the training set! What happens if we remove them?</p> <p>In the next cell we create a new training set excluding the artists with the lowest scores:</p> In\u00a0[14]: Copied! <pre>low_dvl_artists = df.iloc[:30].index.to_list()\nartist_filter = ~artist.isin(low_dvl_artists)\nX_train_good_dvl = training_data[0][artist_filter]\ny_train_good_dvl = training_data[1][artist_filter]\n</pre> low_dvl_artists = df.iloc[:30].index.to_list() artist_filter = ~artist.isin(low_dvl_artists) X_train_good_dvl = training_data[0][artist_filter] y_train_good_dvl = training_data[1][artist_filter] <p>Now we will use this \"cleaned\" dataset to retrain the same model and compare its mean absolute error to the one trained on the full dataset. Notice that the score now is calculated using the test set, while in the calculation of the Shapley values we were using the validation set.</p> In\u00a0[15]: Copied! <pre>model_good_data = GradientBoostingRegressor(n_estimators=3).fit(\n    X_train_good_dvl, y_train_good_dvl\n)\nerror_good_data = mean_absolute_error(\n    model_good_data.predict(test_data[0]), test_data[1]\n)\n\nmodel_all_data = GradientBoostingRegressor(n_estimators=3).fit(\n    training_data[0], training_data[1]\n)\nerror_all_data = mean_absolute_error(model_all_data.predict(test_data[0]), test_data[1])\n\nprint(f\"Improvement: {100*(error_all_data - error_good_data)/error_all_data:02f}%\")\n</pre> model_good_data = GradientBoostingRegressor(n_estimators=3).fit(     X_train_good_dvl, y_train_good_dvl ) error_good_data = mean_absolute_error(     model_good_data.predict(test_data[0]), test_data[1] )  model_all_data = GradientBoostingRegressor(n_estimators=3).fit(     training_data[0], training_data[1] ) error_all_data = mean_absolute_error(model_all_data.predict(test_data[0]), test_data[1])  print(f\"Improvement: {100*(error_all_data - error_good_data)/error_all_data:02f}%\") <pre>Improvement: 13.940685%\n</pre> <p>The score has improved by almost 14%! This is quite an important result, as it shows a consistent process to improve the performance of a model by excluding data points from its training set.</p> <p>One must however proceed with caution instead of simply throwing away data. For one, <code>mean_absolute_error</code> is an estimate of generalization error on unseen data, so the improvement we see on the test set might not be as large upon deployment. It would be advisable to cross-validate this whole process to obtain more conservative estimates. It is also advisable to manually inspect the artists with low value and to try to understand the reason why the model behaves like it does. Finally, remember that the value depends on the model chosen! Artists that are detrimental to the Gradient Boosting Regressor might be informative for a different model (although it is likely that the worst ones share some characteristic making them \"bad\" for other regressors).</p> <p>Let us take all the songs by Rihanna, set their score to 0 and re-calculate the Shapley values.</p> In\u00a0[18]: Copied! <pre>y_train_anomalous = training_data[1].copy(deep=True)\ny_train_anomalous[artist == \"Rihanna\"] = 0\nanomalous_dataset = Dataset(\n    x_train=training_data[0],\n    y_train=y_train_anomalous,\n    x_test=val_data[0],\n    y_test=val_data[1],\n)\ngrouped_anomalous_dataset = GroupedDataset.from_dataset(anomalous_dataset, artist)\nanomalous_utility = Utility(\n    model=GradientBoostingRegressor(n_estimators=3),\n    data=grouped_anomalous_dataset,\n    scorer=Scorer(\"neg_mean_absolute_error\", default=0.0),\n)\nvalues = compute_shapley_values(\n    anomalous_utility,\n    mode=ShapleyMode.TruncatedMontecarlo,\n    done=AbsoluteStandardError(threshold=0.2, fraction=0.9) | MaxUpdates(1000),\n    n_jobs=-1,\n)\nvalues.sort(key=\"value\")\ndf = values.to_dataframe(column=\"data_value\", use_names=True)\n</pre> y_train_anomalous = training_data[1].copy(deep=True) y_train_anomalous[artist == \"Rihanna\"] = 0 anomalous_dataset = Dataset(     x_train=training_data[0],     y_train=y_train_anomalous,     x_test=val_data[0],     y_test=val_data[1], ) grouped_anomalous_dataset = GroupedDataset.from_dataset(anomalous_dataset, artist) anomalous_utility = Utility(     model=GradientBoostingRegressor(n_estimators=3),     data=grouped_anomalous_dataset,     scorer=Scorer(\"neg_mean_absolute_error\", default=0.0), ) values = compute_shapley_values(     anomalous_utility,     mode=ShapleyMode.TruncatedMontecarlo,     done=AbsoluteStandardError(threshold=0.2, fraction=0.9) | MaxUpdates(1000),     n_jobs=-1, ) values.sort(key=\"value\") df = values.to_dataframe(column=\"data_value\", use_names=True) <p>Let us now consider the low-value artists (at least for predictive purposes, no claims are made about their artistic value!) and plot the results</p> <p>And Rihanna (our anomalous data group) has moved from top contributor to having negative impact on the performance of the model, as expected!</p> <p>What is going on? A popularity of 0 for Rihanna's songs is inconsistent with listening patterns for other artists. In artificially setting this, we degrade the predictive power of the model.</p> <p>By dropping low-value groups or samples, one can often increase model performance, but by inspecting them, it is possible to identify bogus data sources or acquisition methods.</p>"},{"location":"examples/shapley_basic_spotify/#shapley-for-data-valuation","title":"Shapley for data valuation\u00b6","text":""},{"location":"examples/shapley_basic_spotify/#setup","title":"Setup\u00b6","text":"<p>We begin by importing the main libraries and setting some defaults.</p> <p>If you are reading this in the documentation, some boilerplate (including most plotting code) has been omitted for convenience.</p>"},{"location":"examples/shapley_basic_spotify/#loading-and-grouping-the-dataset","title":"Loading and grouping the dataset\u00b6","text":"<p>pyDVL provides a support function for this notebook, <code>load_spotify_dataset()</code>, which downloads data on songs published after 2014, and splits 30% of data for testing, and 30% of the remaining data for validation. The return value is a triple of training, validation and test data as lists of the form <code>[X_input, Y_label]</code>.</p>"},{"location":"examples/shapley_basic_spotify/#creating-the-utility-and-computing-values","title":"Creating the utility and computing values\u00b6","text":"<p>Now we can calculate the contribution of each group to the model performance.</p> <p>As a model, we use scikit-learn's GradientBoostingRegressor, but pyDVL can work with any model from sklearn, xgboost or lightgbm. More precisely, any model that implements the protocol pydvl.utils.types.SupervisedModel, which is just the standard sklearn interface of <code>fit()</code>,<code>predict()</code> and <code>score()</code> can be used to construct the utility.</p> <p>The third and final component is the scoring function. It can be anything like accuracy or $R^2$, and is set with a string from the standard sklearn scoring methods. Please refer to that documentation on information on how to define your own scoring function.</p> <p>We group dataset, model and scoring function into an instance of Utility.</p>"},{"location":"examples/shapley_basic_spotify/#evaluation-on-anomalous-data","title":"Evaluation on anomalous data\u00b6","text":"<p>One interesting test is to corrupt some data and to monitor how their value changes. To do this, we will take one of the artists with the highest value and set the popularity of all their songs to 0.</p>"},{"location":"examples/shapley_knn_flowers/","title":"KNN Shapley","text":"<p>This notebook shows how to calculate Shapley values for the K-Nearest Neighbours algorithm. By making use of the local structure of KNN, it is possible to compute an exact value in almost linear time, as opposed to exponential complexity of exact, model-agnostic Shapley.</p> <p>The main idea is to exploit the fact that adding or removing points beyond the k-ball doesn't influence the score. Because the algorithm then essentially only needs to do a search it runs in $\\mathcal{O}(N \\log N)$ time.</p> <p>By further using approximate nearest neighbours, it is possible to achieve $(\\epsilon,\\delta)$-approximations in sublinear time. However, this is not implemented in pyDVL yet.</p> <p>We refer to the original paper that pyDVL implements for details: Jia, Ruoxi, David Dao, Boxin Wang, Frances Ann Hubis, Nezihe Merve Gurel, Bo Li, Ce Zhang, Costas Spanos, and Dawn Song. Efficient Task-Specific Data Valuation for Nearest Neighbor Algorithms. Proceedings of the VLDB Endowment 12, no. 11 (1 July 2019): 1610\u201323.</p> <p>The main entry point is the function compute_shapley_values(), which provides a facade to all Shapley methods. In order to use it we need the classes Dataset, Utility and Scorer, all of which can be imported from <code>pydvl.value</code>:</p> In\u00a0[3]: Copied! <pre>from pydvl.value import *\n</pre> from pydvl.value import * In\u00a0[4]: Copied! <pre>sklearn_dataset = sk.datasets.load_iris()\ndata = Dataset.from_sklearn(sklearn_dataset)\nknn = sk.neighbors.KNeighborsClassifier(n_neighbors=5)\nutility = Utility(knn, data)\n</pre> sklearn_dataset = sk.datasets.load_iris() data = Dataset.from_sklearn(sklearn_dataset) knn = sk.neighbors.KNeighborsClassifier(n_neighbors=5) utility = Utility(knn, data) In\u00a0[5]: Copied! <pre>shapley_values = compute_shapley_values(utility, mode=ShapleyMode.KNN, progress=True)\nshapley_values.sort(key=\"value\")\nvalues = shapley_values.values\n</pre> shapley_values = compute_shapley_values(utility, mode=ShapleyMode.KNN, progress=True) shapley_values.sort(key=\"value\") values = shapley_values.values <pre>0it [00:00, ?it/s]</pre> <p>If we now look at  the distribution of Shapley values for each class, we see that each has samples with both high and low scores. This is expected, because an accurate model uses information of all classes.</p> In\u00a0[8]: Copied! <pre>corrupted_data = deepcopy(data)\nn_corrupted = 10\ncorrupted_data.y_train[:n_corrupted] = (corrupted_data.y_train[:n_corrupted] + 1) % 3\nknn = sk.neighbors.KNeighborsClassifier(n_neighbors=5)\ncontaminated_values = compute_shapley_values(\n    Utility(knn, corrupted_data), mode=ShapleyMode.KNN\n)\n</pre> corrupted_data = deepcopy(data) n_corrupted = 10 corrupted_data.y_train[:n_corrupted] = (corrupted_data.y_train[:n_corrupted] + 1) % 3 knn = sk.neighbors.KNeighborsClassifier(n_neighbors=5) contaminated_values = compute_shapley_values(     Utility(knn, corrupted_data), mode=ShapleyMode.KNN ) <p>Taking the average corrupted value and comparing it to non-corrupted ones, we notice that on average anomalous points have a much lower score, i.e. they tend to be much less valuable to the model.</p> <p>To do this, first we make sure that we access the results by data index with a call to <code>ValuationResult.sort()</code>, then we split the values into two groups: corrupted and non-corrupted. Note how we access property <code>values</code> of the <code>ValuationResult</code> object. This is a numpy array of values, sorted however the object was sorted. Finally, we compute the quantiles of the two groups and compare them. We see that the corrupted mean is in the lowest percentile of the value distribution, while the correct mean is in the 70th percentile.</p> In\u00a0[9]: Copied! <pre>contaminated_values.sort(\n    key=\"index\"\n)  # This is redundant, but illustrates sorting, which is in-place\n\ncorrupted_shapley_values = contaminated_values.values[:n_corrupted]\ncorrect_shapley_values = contaminated_values.values[n_corrupted:]\n\nmean_corrupted = np.mean(corrupted_shapley_values)\nmean_correct = np.mean(correct_shapley_values)\npercentile_corrupted = np.round(100 * np.mean(values &lt; mean_corrupted), 0)\npercentile_correct = np.round(100 * np.mean(values &lt; mean_correct), 0)\n\nprint(\n    f\"The corrupted mean is at percentile {percentile_corrupted:.0f} of the value distribution.\"\n)\nprint(\n    f\"The correct mean is percentile {percentile_correct:.0f} of the value distribution.\"\n)\n</pre> contaminated_values.sort(     key=\"index\" )  # This is redundant, but illustrates sorting, which is in-place  corrupted_shapley_values = contaminated_values.values[:n_corrupted] correct_shapley_values = contaminated_values.values[n_corrupted:]  mean_corrupted = np.mean(corrupted_shapley_values) mean_correct = np.mean(correct_shapley_values) percentile_corrupted = np.round(100 * np.mean(values &lt; mean_corrupted), 0) percentile_correct = np.round(100 * np.mean(values &lt; mean_correct), 0)  print(     f\"The corrupted mean is at percentile {percentile_corrupted:.0f} of the value distribution.\" ) print(     f\"The correct mean is percentile {percentile_correct:.0f} of the value distribution.\" ) <pre>The corrupted mean is at percentile 1 of the value distribution.\nThe correct mean is percentile 71 of the value distribution.\n</pre> <p>This is confirmed if we plot the distribution of Shapley values and circle corrupt points in red. They all tend to have low Shapley scores, regardless of their position in space and assigned label:</p>"},{"location":"examples/shapley_knn_flowers/#knn-shapley","title":"KNN Shapley\u00b6","text":""},{"location":"examples/shapley_knn_flowers/#setup","title":"Setup\u00b6","text":"<p>We begin by importing the main libraries and setting some defaults.</p> <p>If you are reading this in the documentation, some boilerplate (including most plotting code) has been omitted for convenience.</p>"},{"location":"examples/shapley_knn_flowers/#building-a-dataset-and-a-utility","title":"Building a Dataset and a Utility\u00b6","text":"<p>We use the sklearn iris dataset and wrap it into a pydvl.utils.dataset.Dataset calling the factory pydvl.utils.dataset.Dataset.from_sklearn(). This automatically creates a train/test split for us which will be used to compute the utility.</p> <p>We then create a model and instantiate a Utility using data and model. The model needs to implement the protocol pydvl.utils.types.SupervisedModel, which is just the standard sklearn interface of <code>fit()</code>,<code>predict()</code> and <code>score()</code>. In constructing the <code>Utility</code> one can also choose a scoring function, but we pick the default which is just the model's <code>knn.score()</code>.</p>"},{"location":"examples/shapley_knn_flowers/#computing-values","title":"Computing values\u00b6","text":"<p>Calculating the Shapley values is straightforward. We just call compute_shapley_values() with the utility object we created above. The function returns a ValuationResult. This object contains the values themselves, data indices and labels.</p>"},{"location":"examples/shapley_knn_flowers/#inspecting-the-results","title":"Inspecting the results\u00b6","text":"<p>Let us first look at the labels' distribution as a function of petal and sepal length:</p>"},{"location":"examples/shapley_knn_flowers/#corrupting-labels","title":"Corrupting labels\u00b6","text":"<p>To test how informative values are, we can corrupt some training labels and see how their Shapley values change with respect to the non-corrupted points.</p>"},{"location":"examples/shapley_utility_learning/","title":"Data Utility Learning","text":"<p>This notebook introduces Data Utility Learning, a method of approximating Data Shapley values by learning to estimate the utility function.</p> <p>The idea is to employ a model to learn the performance of the learning algorithm of interest on unseen data combinations (i.e. subsets of the dataset). The method was originally described in Wang, Tianhao, Yu Yang, and Ruoxi Jia. Improving Cooperative Game Theory-Based Data Valuation via Data Utility Learning. arXiv, 2022.</p> <p>Warning: Work on Data Utility Learning is preliminary. It remains to be seen when or whether it can be put effectively into application. For this further testing and benchmarking are required.</p> <p>Recall the definition of Shapley value $v_u(i)$ for data point $i$:</p> <p>\\begin{equation} v_u(i) = \\frac{1}{n} \\sum_{S \\subseteq N \\setminus \\{i\\}} \\binom{n-1}{|S|}^{-1} [u(S \\cup \\{i\\}) \u2212 u(S)] , \\tag{1} \\label{eq:shapley-def} \\end{equation}</p> <p>where $N$ is the set of all indices in the training set and $u$ is the utility.</p> <p>In Data Utility Learning, to avoid the exponential cost of computing this sum, one learns a surrogate model for $u$. We start by sampling so-called utility samples to form a training set $S_\\mathrm{train}$ for our utility model. Each utility sample is a tuple consisting of a subset of indices $S_j$ in the dataset and its utility $u(S_j)$:</p> <p>$$\\mathcal{S}_\\mathrm{train} = \\{(S_j, u(S_j): j = 1 , ..., m_\\mathrm{train}\\}$$</p> <p>where $m_\\mathrm{train}$ denotes the training budget for the learned utility function.</p> <p>The subsets are then transformed into boolean vectors $\\phi$ in which a $1$ at index $k$ means that the $k$-th sample of the dataset is present in the subset:</p> <p>$$S_j \\mapsto \\phi_j \\in \\{ 0, 1 \\}^{N}$$</p> <p>We fit a regression model $\\tilde{u}$, called data utility model, on the transformed utility samples $\\phi (\\mathcal{S}_\\mathrm{train}) := \\{(\\phi(S_j), u(S_j): j = 1 , ..., m_\\mathrm{train}\\}$ and use it to predict instead of computing the utility for any $S_j \\notin \\mathcal{S}_\\mathrm{train}$. We abuse notation and identify $\\tilde{u}$ with the composition $\\tilde{u} \\circ \\phi : N \\rightarrow \\mathbb{R}$.</p> <p>The main assumption is that it is much faster to fit and use $\\tilde{u}$ than it is to compute $u$ and that for most $i$, $v_\\tilde{u}(i) \\approx v_u(i)$ in some sense.</p> <p>As is the case with all other Shapley methods, the main entry point is the function compute_shapley_values(), which provides a facade to all algorithms in this family. We use it with the usual classes Dataset and Utility. In addition, we must import the core class for learning a utility, DataUtilityLearning.</p> In\u00a0[3]: Copied! <pre>%autoreload\nfrom pydvl.utils import DataUtilityLearning, top_k_value_accuracy\nfrom pydvl.reporting.plots import shaded_mean_std\nfrom pydvl.value import *\n</pre> %autoreload from pydvl.utils import DataUtilityLearning, top_k_value_accuracy from pydvl.reporting.plots import shaded_mean_std from pydvl.value import * In\u00a0[4]: Copied! <pre>dataset = Dataset.from_sklearn(\n    load_iris(), train_size=0.1, random_state=random_state, stratify_by_target=True\n)\n</pre> dataset = Dataset.from_sklearn(     load_iris(), train_size=0.1, random_state=random_state, stratify_by_target=True ) <p>We verify that, as in the paper, if we fit a Support-Vector Classifier to the training data, we obtain an accuracy of around 92%:</p> In\u00a0[5]: Copied! <pre>model = LinearSVC()\nmodel.fit(dataset.x_train, dataset.y_train)\nprint(f\"Mean accuracy: {100 * model.score(dataset.x_test, dataset.y_test):0.2f}%\")\n</pre> model = LinearSVC() model.fit(dataset.x_train, dataset.y_train) print(f\"Mean accuracy: {100 * model.score(dataset.x_test, dataset.y_test):0.2f}%\") <pre>Mean accuracy: 92.59%\n</pre> In\u00a0[6]: Copied! <pre>computation_times = {}\n</pre> computation_times = {} In\u00a0[7]: Copied! <pre>utility = Utility(model=model, data=dataset)\n</pre> utility = Utility(model=model, data=dataset) In\u00a0[8]: Copied! <pre>start_time = time.monotonic()\n\nresult = compute_shapley_values(\n    u=utility,\n    mode=ShapleyMode.CombinatorialExact,\n    n_jobs=-1,\n    progress=False,  # Does not display correctly in a notebook\n)\n\ncomputation_time = time.monotonic() - start_time\ncomputation_times[\"exact\"] = computation_time\n\ndf = result.to_dataframe(column=\"exact\").drop(columns=[\"exact_stderr\"])\n</pre> start_time = time.monotonic()  result = compute_shapley_values(     u=utility,     mode=ShapleyMode.CombinatorialExact,     n_jobs=-1,     progress=False,  # Does not display correctly in a notebook )  computation_time = time.monotonic() - start_time computation_times[\"exact\"] = computation_time  df = result.to_dataframe(column=\"exact\").drop(columns=[\"exact_stderr\"]) <p>We now estimate the Data Shapley values using the DataUtilityLearning wrapper. This class wraps a Utility and delegates calls to it, up until a given budget. Every call yields a utility sample which is saved under the hood for training of the given utility model. Once the budget is exhausted, <code>DataUtilityLearning</code> fits the model to the utility samples and all subsequent calls use the learned model to predict the wrapped utility instead of delegating to it.</p> <p>For the utility model we follow the paper and use a fully connected neural network. To train it we use a total of <code>training_budget</code> utility samples. We repeat this multiple times for each training budget.</p> <p>Note how we use a MonteCarlo approximation instead of <code>combinatorial_exact</code> as before. This is because the exact computation samples subsets in a particular order, from the lowest size to the largest. Because the training budget for the model to learn the utility is around 1/4th of the total number of subsets, this would mean that we would never see utility samples for the larger sizes and the model would be biased (try it!)</p> In\u00a0[9]: Copied! <pre>mlp_kwargs = dict(\n    hidden_layer_sizes=(20, 10),\n    activation=\"relu\",\n    solver=\"adam\",\n    learning_rate_init=0.001,\n    batch_size=32,\n    max_iter=800,\n)\n\nprint(\n    f\"Doing {n_runs} runs for each of {len(training_budget_values)} different training budgets.\"\n)\n\npbar = tqdm(\n    product(range(n_runs), training_budget_values),\n    total=n_runs * len(training_budget_values),\n)\nfor idx, budget in pbar:\n    pbar.set_postfix_str(f\"Run {idx} for training budget: {budget}\")\n    dul_utility = DataUtilityLearning(\n        u=utility, training_budget=budget, model=MLPRegressor(**mlp_kwargs)\n    )\n\n    start_time = time.monotonic()\n\n    # DUL will kick in after training_budget calls to utility\n    result = compute_shapley_values(\n        u=dul_utility,\n        mode=ShapleyMode.PermutationMontecarlo,\n        done=MaxUpdates(300),\n        n_jobs=-1,\n    )\n\n    computation_time = time.monotonic() - start_time\n    if budget in computation_times:\n        computation_times[budget].append(computation_time)\n    else:\n        computation_times[budget] = [computation_time]\n\n    dul_df = result.to_dataframe(column=f\"{budget}_{idx}\").drop(\n        columns=[f\"{budget}_{idx}_stderr\"]\n    )\n    df = pd.concat([df, dul_df], axis=1)\n\ncomputation_times_df = pd.DataFrame(computation_times)\n</pre> mlp_kwargs = dict(     hidden_layer_sizes=(20, 10),     activation=\"relu\",     solver=\"adam\",     learning_rate_init=0.001,     batch_size=32,     max_iter=800, )  print(     f\"Doing {n_runs} runs for each of {len(training_budget_values)} different training budgets.\" )  pbar = tqdm(     product(range(n_runs), training_budget_values),     total=n_runs * len(training_budget_values), ) for idx, budget in pbar:     pbar.set_postfix_str(f\"Run {idx} for training budget: {budget}\")     dul_utility = DataUtilityLearning(         u=utility, training_budget=budget, model=MLPRegressor(**mlp_kwargs)     )      start_time = time.monotonic()      # DUL will kick in after training_budget calls to utility     result = compute_shapley_values(         u=dul_utility,         mode=ShapleyMode.PermutationMontecarlo,         done=MaxUpdates(300),         n_jobs=-1,     )      computation_time = time.monotonic() - start_time     if budget in computation_times:         computation_times[budget].append(computation_time)     else:         computation_times[budget] = [computation_time]      dul_df = result.to_dataframe(column=f\"{budget}_{idx}\").drop(         columns=[f\"{budget}_{idx}_stderr\"]     )     df = pd.concat([df, dul_df], axis=1)  computation_times_df = pd.DataFrame(computation_times) <pre>Doing 10 runs for each of 10 different training budgets.\n</pre> <pre>  0%|          | 0/100 [00:00&lt;?, ?it/s]</pre> <p>Next we compute the $l_1$ error for the different training budgets across all runs and plot mean and standard deviation. We obtain results analogous to Figure 1 of the paper, verifying that the method indeed works for estimating the Data Shapley values (at least in this context).</p> <p>In the plot we also display the mean and standard deviation of the computation time taken for each training budget.</p> In\u00a0[10]: Copied! <pre>errors = np.zeros((len(training_budget_values), n_runs), dtype=float)\naccuracies = np.zeros((len(training_budget_values), n_runs), dtype=float)\n\ntop_k = 3\n\nfor i, budget in enumerate(training_budget_values):\n    for j in range(n_runs):\n        y_true = df[\"exact\"].values\n        y_estimated = df[f\"{budget}_{j}\"].values\n        errors[i, j] = np.linalg.norm(y_true - y_estimated, ord=2)\n        accuracies[i, j] = top_k_value_accuracy(y_true, y_estimated, k=top_k)\n\nerror_from_mean = np.linalg.norm(df[\"exact\"].values - df[\"exact\"].values.mean(), ord=2)\n</pre> errors = np.zeros((len(training_budget_values), n_runs), dtype=float) accuracies = np.zeros((len(training_budget_values), n_runs), dtype=float)  top_k = 3  for i, budget in enumerate(training_budget_values):     for j in range(n_runs):         y_true = df[\"exact\"].values         y_estimated = df[f\"{budget}_{j}\"].values         errors[i, j] = np.linalg.norm(y_true - y_estimated, ord=2)         accuracies[i, j] = top_k_value_accuracy(y_true, y_estimated, k=top_k)  error_from_mean = np.linalg.norm(df[\"exact\"].values - df[\"exact\"].values.mean(), ord=2) <p>Let us next look at how well the ranking of values resulting from using the surrogate $\\tilde{u}$ matches the ranking by the exact values. For this we fix $k=3$ and consider the $k$ samples with the highest value according to $\\tilde{u}$ and $u$:</p> <p>Finally, for each sample, we look at the distance of the estimates to the exact value across runs. Boxes are centered at the 50th percentile with wiskers at the 25th and 75th. We plot relative distances, as a percentage. We observe a general tendency to underestimate the value:</p> In\u00a0[17]: Copied! <pre>highest_value_index = df.index[df[\"exact\"].argmax()]\ny_train_corrupted = dataset.y_train.copy()\ny_train_corrupted[highest_value_index] = (\n    y_train_corrupted[highest_value_index] + 1\n) % 3\n\ncorrupted_dataset = Dataset(\n    x_train=dataset.x_train,\n    y_train=y_train_corrupted,\n    x_test=dataset.x_test,\n    y_test=dataset.y_test,\n)\n</pre> highest_value_index = df.index[df[\"exact\"].argmax()] y_train_corrupted = dataset.y_train.copy() y_train_corrupted[highest_value_index] = (     y_train_corrupted[highest_value_index] + 1 ) % 3  corrupted_dataset = Dataset(     x_train=dataset.x_train,     y_train=y_train_corrupted,     x_test=dataset.x_test,     y_test=dataset.y_test, ) <p>We retrain the model on the new dataset and verify that the accuracy decreases:</p> In\u00a0[18]: Copied! <pre>model = LinearSVC()\nmodel.fit(dataset.x_train, y_train_corrupted)\nprint(f\"Mean accuracy: {100 * model.score(dataset.x_test, dataset.y_test):0.2f}%\")\n</pre> model = LinearSVC() model.fit(dataset.x_train, y_train_corrupted) print(f\"Mean accuracy: {100 * model.score(dataset.x_test, dataset.y_test):0.2f}%\") <pre>Mean accuracy: 82.96%\n</pre> <p>Finally, we recompute the values of all samples using the exact method and the best training budget previously obtained and then plot the resulting scores.</p> In\u00a0[19]: Copied! <pre>best_training_budget = training_budget_values[errors.mean(axis=1).argmin()]\n\nutility = Utility(\n    model=LinearSVC(),\n    data=corrupted_dataset,\n)\n\nresult = compute_shapley_values(\n    u=utility,\n    mode=ShapleyMode.CombinatorialExact,\n    n_jobs=-1,\n    progress=False,\n)\ndf_corrupted = result.to_dataframe(column=\"exact\").drop(columns=[\"exact_stderr\"])\n\ndul_utility = DataUtilityLearning(\n    u=utility, training_budget=best_training_budget, model=MLPRegressor(**mlp_kwargs)\n)\n\nresult = compute_shapley_values(\n    u=dul_utility,\n    mode=ShapleyMode.PermutationMontecarlo,\n    done=MaxUpdates(300),\n    n_jobs=-1,\n)\ndul_df = result.to_dataframe(column=\"estimated\").drop(columns=[\"estimated_stderr\"])\ndf_corrupted = pd.concat([df_corrupted, dul_df], axis=1)\n</pre> best_training_budget = training_budget_values[errors.mean(axis=1).argmin()]  utility = Utility(     model=LinearSVC(),     data=corrupted_dataset, )  result = compute_shapley_values(     u=utility,     mode=ShapleyMode.CombinatorialExact,     n_jobs=-1,     progress=False, ) df_corrupted = result.to_dataframe(column=\"exact\").drop(columns=[\"exact_stderr\"])  dul_utility = DataUtilityLearning(     u=utility, training_budget=best_training_budget, model=MLPRegressor(**mlp_kwargs) )  result = compute_shapley_values(     u=dul_utility,     mode=ShapleyMode.PermutationMontecarlo,     done=MaxUpdates(300),     n_jobs=-1, ) dul_df = result.to_dataframe(column=\"estimated\").drop(columns=[\"estimated_stderr\"]) df_corrupted = pd.concat([df_corrupted, dul_df], axis=1) <p>We can see in the figure that both methods assign the lowest value to the sample with the corrupted label.</p>  As mentioned above, despite the previous results, this work is preliminary and the usefulness of Data Utility Learning remains to be tested in practice."},{"location":"examples/shapley_utility_learning/#data-utility-learning","title":"Data Utility Learning\u00b6","text":""},{"location":"examples/shapley_utility_learning/#setup","title":"Setup\u00b6","text":"<p>We begin by importing the main libraries and setting some defaults.</p> <p>If you are reading this in the documentation, some boilerplate (including most plotting code) has been omitted for convenience.</p>"},{"location":"examples/shapley_utility_learning/#dataset","title":"Dataset\u00b6","text":"<p>Following the paper, we take 15 samples (10%) from the Iris dataset and compute their Data Shapley values by using all the remaining samples as test set for computing the utility, which in this case is accuracy.</p>"},{"location":"examples/shapley_utility_learning/#data-shapley","title":"Data Shapley\u00b6","text":"<p>We start by defining the utility using the model and computing the exact Data Shapley values by definition $\\ref{eq:shapley-def}$.</p>"},{"location":"examples/shapley_utility_learning/#evaluation-on-anomalous-data","title":"Evaluation on anomalous data\u00b6","text":"<p>One interesting way to assess the Data Utility Learning approach is to corrupt some data and monitor how the value changes. To do this, we will take the sample with the highest score and change its label.</p>"}]}